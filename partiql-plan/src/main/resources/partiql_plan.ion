imports::{
  kotlin: [
    partiql_value::'org.partiql.value.PartiQLValue',
    partiql_value_type::'org.partiql.types.PType',
    static_type::'org.partiql.types.PType',
    function::'org.partiql.spi.function.Function',
    aggregation::'org.partiql.spi.function.Aggregation',
  ],
}

parti_q_l_plan::{
  catalogs:   list::[catalog],      // (catalogs ...)
  statement:  statement,            // (statement ...)
}

catalog::{
  name:   string,
  items:  list::[item],
  _: [
    item::[
      value::{
        path: list::[string],
        type: static_type,
      },
      fn::{
        path:     list::[string],
        function: function,
      },
      agg::{
        path:     list::[string],
        aggregation: aggregation,
      },
    ]
  ]
}

// Reference to some item in a catalog.

ref::{
  catalog: int,
  symbol: int,
  _: [
    cast::{
      input: partiql_value_type,
      target: partiql_value_type,
      isNullable: bool
    }
  ]
}

// Statements

statement::[
  query::{
    root: rex,
  },
]

// Identifiers

identifier::[
  symbol::{
    symbol:           string,
    case_sensitivity: case_sensitivity,
  },
  qualified::{
    root:   symbol,
    steps:  list::[symbol],
  },
  _::[
    case_sensitivity::[
      SENSITIVE,
      INSENSITIVE,
    ],
  ],
]

// [ ALL | DISTINCT ]
set_quantifier::[
  ALL,
  DISTINCT,
]

// Rex
rex::{
  type: static_type,
  op:[

    lit::{
      value: partiql_value,
    },

    // Refers to a value in the variables environment.
    var::{
      depth: int, // A depth of 0 would indicate that the variable is coming from the current variable scope
      ref: int,   // Value reference within the scope
    },

    // Refers to a value in the database environment.
    global::{
      ref: ref,
    },

    path::[
      // The key MUST be an integer expression. Ex: a[0], a[1 + 1]
      index::{ root: rex, key: rex },

      // Case-sensitive lookup. The key MUST be a string expression. Ex: a["b"], a."b", a[CAST(b AS STRING)]
      key::{ root: rex, key: rex },

      // Case-insensitive lookup. The key MUST be a literal string. Ex: a.b
      symbol::{ root: rex, key: string },
    ],

    cast::{
      cast: '.ref.cast',
      arg: rex,
    },

    call::[
      static::{
        fn: ref,
        args: list::[rex],
      },

      // Represents a dynamic function call. If all candidates are exhausted, dynamic calls will return MISSING.
      //
      // args: represent the original typed arguments. These will eventually be wrapped by coercions from [candidates].
      // candidates: represent the potentially applicable resolved functions with coercions. Each of these candidates
      //  should be overloaded functions of the same name and number of arguments.
      dynamic::{
        args: list::[rex],
        candidates: list::[candidate],
        _: [
          // Represents a potential candidate for dynamic dispatch. AKA `SELECT abs(a) FROM << 1, 2.0 >> AS a` can invoke
          // ABS(INT32) -> INT32 or ABS(DEC) -> DEC. In this scenario, we maintain the two potential candidates.
          //
          // @param fn - represents the function to invoke (ex: ABS(INT32) -> INT32)
          // @param coercions - represents the optional coercion to use on the argument(s). It will be NULL if no coercion
          //  is necessary.
          candidate::{
            fn: ref,
            coercions: list::[optional::'.ref.cast'],
          }
        ]
      },
    ],

    case::{
      branches: list::[branch],
      default: rex,
      _: [
        branch::{
          condition:  rex,
          rex:        rex,
        },
      ],
    },

    nullif::{
      value: rex,
      nullifier: rex
    },

    coalesce::{
      args: list::[rex]
    },

    collection::{
      values: list::[rex],
    },

    struct::{
      fields: list::[field],
      _: [
        field::{
          k: rex,
          v: rex,
        },
      ],
    },

    pivot::{
      key:    rex,
      value:  rex,
      rel:    rel,
    },

    subquery::{
      constructor:  rex,
      rel:          rel,
      coercion:     [ SCALAR, ROW ],
    },

    select::{
      constructor:  rex,
      rel:          rel,
    },

    // SELECT v1.*, e2 AS a, v3.*
    //
    // SELECT VALUE TUPLEUNION(
    //   CASE WHEN v1 IS TUPLE THEN v1 ELSE {'_1': v1} END,
    //   {'a':e2 },
    //   CASE WHEN v3 IS TUPLE THEN v3 ELSE {'_2': v3} END
    // )
    //
    // Tuple Union Function Signature: (Array<Struct>) -> Struct
    tuple_union::{
      args: list::[rex],
    },

    err::{
      message: string,
      causes: list::['.rex.op']
    },

    missing::{
      message: string,
      causes: list::['.rex.op']
    },
  ],
}

// Rel

rel::{
  type: {
    schema: list::[binding],
    props:  set::[prop],
  },
  op: [

    scan::{
      rex: rex,
    },

    scan_indexed::{
      rex: rex,
    },

    unpivot::{
      rex:  rex,
    },

    distinct::{
      input: rel,
    },

    filter::{
      input:      rel,
      predicate:  rex,
    },

    sort::{
      input: rel,
      specs: list::[spec],
      _: [
        spec::{
          rex: rex,
          order: order,
        },
        order::[
          ASC_NULLS_LAST,
          ASC_NULLS_FIRST,
          DESC_NULLS_LAST,
          DESC_NULLS_FIRST,
        ],
      ],
    },

    // SQL set ops
    union::{
      setq: set_quantifier,
      lhs: rel,
      rhs: rel,
    },

    intersect::{
      setq: set_quantifier,
      lhs: rel,
      rhs: rel,
    },

    except::{
      setq: set_quantifier,
      lhs: rel,
      rhs: rel,
    },

    limit::{
      input:  rel,
      limit:  rex,
    },

    offset::{
      input:  rel,
      offset: rex,
    },

    project::{
      input:        rel,
      projections:  list::[rex],
    },

    // TODO: Specify that this is a LATERAL JOIN. Create a separate JOIN. Also, determine the allowable types of JOIN.
    // For context: Oracle SQL doesn't allow ... FULL OUTER JOIN LATERAL ... or ... RIGHT OUTER JOIN LATERAL ...
    join::{
      lhs: rel,
      rhs: rel,
      rex: rex, // The Join Expression (required) (can be set to TRUE)
      type: [
        INNER, // Inner Join
        LEFT,  // Left Outer Join
        RIGHT, // Right Outer Join
        FULL   // Full Outer Join
      ],
    },

    aggregate::{
      input:    rel,
      strategy: [ FULL, PARTIAL ],
      calls:    list::[call],
      groups:   list::[rex],
      _: [
        call::{
          agg:  ref,
          setq: set_quantifier,
          args: list::[rex],
        },
      ],
    },

    exclude::{
      input: rel,
      paths: list::[path],
      _: [
        path::{
          root: '.rex.op.var',
          steps: list::[step],
        },
        step::{
          type: type,
          substeps: list::[step],
        },
        type::[
          struct_symbol::{ symbol: string },
          struct_key::{ key: string },
          coll_index::{ index: int },
          struct_wildcard::{},
          coll_wildcard::{},
        ]
      ],
    },

    err::{
      message: string,
    },
  ],
  _: [
    prop::[
      ORDERED,
    ],
    binding::{
      name: string,
      type: static_type,
    },
  ]
}
