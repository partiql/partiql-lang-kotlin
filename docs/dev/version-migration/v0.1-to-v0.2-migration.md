# v0.2.* (latest v0.2.7)

* New features
    * Adds support for `DISTINCT`, `LET` (from `FROM` clause), system stored procedure calls (`EXEC`)
    * Adds parser support for DML statements (`INSERT`, `UPDATE`, `DELETE`), `Parameter`, `BY` variable
    * Improvements to `LIKE` pattern compilation performance
    * Adds function to convert from UNIX epoch to TIMESTAMP and TIMESTAMP to UNIX epoch
* Deprecated items
    * `AstRewriter`, `AstRewriterBase`, `MetaStrippingRewriter`, `RewriterTestBase`
        * Existing AST rewriters migrated to use PIG’s `VisitorTransform`s
        * Migration guide provided [here](https://github.com/partiql/partiql-lang-kotlin/blob/feb84730c64a2ad0f12c57bef3b1c45e21279538/docs/dev/RewriterToVisitorTransformGuide.md)
* Misc/bug fixes
    * New error codes for division by `0` and modulo `0`
    * [fix] float negative zero equality
    * Removes invalid syntax check on case expressions w/ type parameters e.g., `CAST(a AS DECIMAL(1, 2))` now does not throw
    * [fix] `LIMIT` with value over 2^31 returning no values
    * [fix] `LIMIT` clause execution order
    * [fix] stop treating date parts as if they are string literals
    * [fix] parsing of `TRIM` specification keywords (`BOTH`, `LEADING`, and `TRAILING`)
    * Adds some AST rewriters — `SelectStarRewriter` and `StaticTypeRewriter`
## Breaking changes
### Breaking behavioral changes
1. `JOIN` requires an `ON` clause. In v0.1.*, the `ON` clause was optional, which caused ambiguous parsing of multiple `JOIN`
```kotlin
// v0.1.*
// Initialization of components related to evaluating a query end-to-end
val ion = IonSystemBuilder.standard().build()
val parser = SqlParser(ion)
val pipeline = CompilerPipeline.standard(ion)
val evaluationSession = EvaluationSession.standard()

// Query with a JOIN without an ON clause. In v0.1.*, the ON condition is optional.
val query = "SELECT * FROM <<{'a': 1}>> INNER JOIN <<{'a': 2}>>"
val parsedQuery = parser.parseExprNode(query)
val compiledQuery = pipeline.compile(parsedQuery)
val result = compiledQuery.eval(evaluationSession)

// Query successfully evaluates. Here we compare the result to its string representation.
assertEquals("<<{'a': 1, 'a': 2}>>", result.toString())
```

```kotlin
// v0.2.*
// Initialization of components related to parsing a query end-to-end
val ion = IonSystemBuilder.standard().build()
val parser = SqlParser(ion)

// Query with a JOIN without an ON clause. Starting in v0.2.0, the ON condition is REQUIRED except for cross
// joins. When not provided, a parser error is thrown.
val query = "SELECT * FROM <<{'a': 1}>> INNER JOIN <<{'a': 2}>>"
assertFailsWith<ParserException> {
    parser.parseExprNode(query)
}
```
### Breaking API changes
1. Refactoring of `ExprNode` AST (see [16fefe0](https://github.com/partiql/partiql-lang-kotlin/commit/16fefe0f096175a6a7b284313634dfad23858a38)) `FromSourceExpr` variables (changed to use `LetVariables`)
```kotlin
// v0.1.*
// FROM source and FROM source UNPIVOT are modeled differently between v0.1.* and v0.2.*
// The following is an AstNode/ExprNode representation of '... FROM foo AS f AT g'
val fromExpr = VariableReference(id = "foo", case = CaseSensitivity.INSENSITIVE, metas = metaContainerOf())
FromSourceExpr(
    expr = fromExpr,
    asName = SymbolicName(name = "f", metas = metaContainerOf()),
    atName = SymbolicName(name = "g", metas = metaContainerOf())
)

// The following models '... FROM UNPIVOT foo AS f AT g'
FromSourceUnpivot(
    expr = fromExpr,
    asName = SymbolicName(name = "f", metas = metaContainerOf()),
    atName = SymbolicName(name = "g", metas = metaContainerOf()),
    metas = metaContainerOf()
)
```
```kotlin
// v0.2.*
// FROM source and FROM source UNPIVOT are modeled differently between v0.1.* and v0.2.*
// The following is an AstNode/ExprNode representation of '... FROM foo AS f AT g'
val fromExpr = VariableReference(id = "foo", case = CaseSensitivity.INSENSITIVE, metas = metaContainerOf())
FromSourceExpr(
    expr = fromExpr,
    variables = LetVariables(
        asName = SymbolicName(name = "f", metas = metaContainerOf()),
        atName = SymbolicName(name = "g", metas = metaContainerOf())
        // v0.2.0 onwards also allows specifying a `BY` variable in FROM sources
    )
)

// The following models '... FROM UNPIVOT foo AS f AT g'
FromSourceUnpivot(
    expr = fromExpr,
    variables = LetVariables(
        asName = SymbolicName(name = "f", metas = metaContainerOf()),
        atName = SymbolicName(name = "g", metas = metaContainerOf())
    ),
    metas = metaContainerOf()
)
```
2. Refactoring of `ExprNode` AST (see [16fefe0](https://github.com/partiql/partiql-lang-kotlin/commit/16fefe0f096175a6a7b284313634dfad23858a38)) `List` and `Bag` `ExprNode`s defined under a `Seq` class
```kotlin
// v0.1.*
val ion = IonSystemBuilder.standard().build()
val elem1 = Literal(ionValue = ion.singleValue("1"), metas = metaContainerOf())
val elem2 = Literal(ionValue = ion.singleValue("2"), metas = metaContainerOf())
val elem3 = Literal(ionValue = ion.singleValue("3"), metas = metaContainerOf())

// LIST and BAG are modeled differently between v0.1.* and v0.2.*
// The following is an AstNode/ExprNode representation of [1, 2, 3]
ListExprNode(
    values = listOf(
        elem1,
        elem2,
        elem3
    ),
    metas = metaContainerOf()
)

// The following is an AstNode/ExprNode representation of <<1, 2, 3>>
Bag(
    bag = listOf(
        elem1,
        elem2,
        elem3
    ),
    metas = metaContainerOf()
)
```
```kotlin
// v0.2.*
val ion = IonSystemBuilder.standard().build()
val elem1 = Literal(ionValue = ion.singleValue("1"), metas = metaContainerOf())
val elem2 = Literal(ionValue = ion.singleValue("2"), metas = metaContainerOf())
val elem3 = Literal(ionValue = ion.singleValue("3"), metas = metaContainerOf())
// LIST and BAG are modeled differently between v0.1.* and v0.2.*
// The following is an AstNode/ExprNode representation of [1, 2, 3]
Seq(
    type = SeqType.LIST,
    values = listOf(
        elem1,
        elem2,
        elem3
    ),
    metas = metaContainerOf()
)

// The following is an AstNode/ExprNode representation of <<1, 2, 3>>
Seq(
    type = SeqType.BAG,
    values = listOf(
        elem1,
        elem2,
        elem3
    ),
    metas = metaContainerOf()
)

// v0.2.0 onwards also allows for specifying s-expressions. E.g. (1 2 3)
Seq(
    type = SeqType.SEXP,
    values = listOf(
        elem1,
        elem2,
        elem3
    ),
    metas = metaContainerOf()
)
```