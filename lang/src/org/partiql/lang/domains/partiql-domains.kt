/**
 * This code was generated by the PartiQL I.R. Generator.
 * Do not modify this file.  
 */
@file:Suppress("unused", "MemberVisibilityCanBePrivate", "FunctionName",
    "CanBePrimaryConstructorProperty", "UNNECESSARY_SAFE_CALL",
    "USELESS_ELVIS", "RemoveRedundantQualifierName", "LocalVariableName")

package org.partiql.lang.domains

import com.amazon.ionelement.api.*
import org.partiql.pig.runtime.*

class PartiqlAst private constructor() {
    /////////////////////////////////////////////////////////////////////////////
    // Builder
    /////////////////////////////////////////////////////////////////////////////
    companion object {
        @JvmStatic
        fun BUILDER() : Builder = PartiqlAstBuilder
    
        fun <T: PartiqlAstNode> build(block: Builder.() -> T) =
            PartiqlAstBuilder.block()
    
        fun transform(element: AnyElement): PartiqlAstNode =
            transform(element.asSexp())
    
        fun transform(element: SexpElement): PartiqlAstNode =
            IonElementTransformer().transform(element)
    }
    
    interface Builder {
        fun newMetaContainer() = emptyMetaContainer()
    
        // Tuples 
        /**
         * Creates an instance of [PartiqlAst.TimeValue].
         */
        fun timeValue(
            hour: Long,
            minute: Long,
            second: Long,
            nano: Long,
            precision: Long,
            tzMinutes: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.TimeValue =
            PartiqlAst.TimeValue(
                hour = hour.asPrimitive(),
                minute = minute.asPrimitive(),
                second = second.asPrimitive(),
                nano = nano.asPrimitive(),
                precision = precision.asPrimitive(),
                tzMinutes = tzMinutes?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.TimeValue].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun timeValue_(
            hour: org.partiql.pig.runtime.LongPrimitive,
            minute: org.partiql.pig.runtime.LongPrimitive,
            second: org.partiql.pig.runtime.LongPrimitive,
            nano: org.partiql.pig.runtime.LongPrimitive,
            precision: org.partiql.pig.runtime.LongPrimitive,
            tzMinutes: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.TimeValue =
            PartiqlAst.TimeValue(
                hour = hour,
                minute = minute,
                second = second,
                nano = nano,
                precision = precision,
                tzMinutes = tzMinutes,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Let].
         */
        fun let(
            letBindings: kotlin.collections.List<LetBinding>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Let =
            PartiqlAst.Let(
                letBindings = letBindings,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Let].
         */
        fun let(
            letBindings0: LetBinding,
            vararg letBindings: LetBinding,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Let =
            PartiqlAst.Let(
                letBindings = listOf(letBindings0) + letBindings.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.LetBinding].
         */
        fun letBinding(
            expr: Expr,
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.LetBinding =
            PartiqlAst.LetBinding(
                expr = expr,
                name = name.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.LetBinding].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun letBinding_(
            expr: Expr,
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.LetBinding =
            PartiqlAst.LetBinding(
                expr = expr,
                name = name,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ExprPair].
         */
        fun exprPair(
            first: Expr,
            second: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ExprPair =
            PartiqlAst.ExprPair(
                first = first,
                second = second,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ExprPairList].
         */
        fun exprPairList(
            pairs: kotlin.collections.List<ExprPair> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ExprPairList =
            PartiqlAst.ExprPairList(
                pairs = pairs,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.ExprPairList].
         */
        fun exprPairList(
            vararg pairs: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ExprPairList =
            PartiqlAst.ExprPairList(
                pairs = pairs.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.GroupBy].
         */
        fun groupBy(
            strategy: GroupingStrategy,
            keyList: GroupKeyList,
            groupAsAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupBy =
            PartiqlAst.GroupBy(
                strategy = strategy,
                keyList = keyList,
                groupAsAlias = groupAsAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.GroupBy].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupBy_(
            strategy: GroupingStrategy,
            keyList: GroupKeyList,
            groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupBy =
            PartiqlAst.GroupBy(
                strategy = strategy,
                keyList = keyList,
                groupAsAlias = groupAsAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.GroupKeyList].
         */
        fun groupKeyList(
            keys: kotlin.collections.List<GroupKey>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupKeyList =
            PartiqlAst.GroupKeyList(
                keys = keys,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.GroupKeyList].
         */
        fun groupKeyList(
            keys0: GroupKey,
            vararg keys: GroupKey,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupKeyList =
            PartiqlAst.GroupKeyList(
                keys = listOf(keys0) + keys.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.GroupKey].
         */
        fun groupKey(
            expr: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupKey =
            PartiqlAst.GroupKey(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.GroupKey].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun groupKey_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupKey =
            PartiqlAst.GroupKey(
                expr = expr,
                asAlias = asAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.OrderBy].
         */
        fun orderBy(
            sortSpecs: kotlin.collections.List<SortSpec>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.OrderBy =
            PartiqlAst.OrderBy(
                sortSpecs = sortSpecs,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.OrderBy].
         */
        fun orderBy(
            sortSpecs0: SortSpec,
            vararg sortSpecs: SortSpec,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.OrderBy =
            PartiqlAst.OrderBy(
                sortSpecs = listOf(sortSpecs0) + sortSpecs.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.SortSpec].
         */
        fun sortSpec(
            expr: Expr,
            orderingSpec: OrderingSpec? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.SortSpec =
            PartiqlAst.SortSpec(
                expr = expr,
                orderingSpec = orderingSpec,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DmlOpList].
         */
        fun dmlOpList(
            ops: kotlin.collections.List<DmlOp>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOpList =
            PartiqlAst.DmlOpList(
                ops = ops,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.DmlOpList].
         */
        fun dmlOpList(
            ops0: DmlOp,
            vararg ops: DmlOp,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOpList =
            PartiqlAst.DmlOpList(
                ops = listOf(ops0) + ops.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.OnConflict].
         */
        fun onConflict(
            expr: Expr,
            conflictAction: ConflictAction,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.OnConflict =
            PartiqlAst.OnConflict(
                expr = expr,
                conflictAction = conflictAction,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ReturningExpr].
         */
        fun returningExpr(
            elems: kotlin.collections.List<ReturningElem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningExpr =
            PartiqlAst.ReturningExpr(
                elems = elems,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.ReturningExpr].
         */
        fun returningExpr(
            elems0: ReturningElem,
            vararg elems: ReturningElem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningExpr =
            PartiqlAst.ReturningExpr(
                elems = listOf(elems0) + elems.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ReturningElem].
         */
        fun returningElem(
            mapping: ReturningMapping,
            column: ColumnComponent,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningElem =
            PartiqlAst.ReturningElem(
                mapping = mapping,
                column = column,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Identifier].
         */
        fun identifier(
            name: String,
            case: CaseSensitivity,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Identifier =
            PartiqlAst.Identifier(
                name = name.asPrimitive(),
                case = case,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Identifier].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun identifier_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            case: CaseSensitivity,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Identifier =
            PartiqlAst.Identifier(
                name = name,
                case = case,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Assignment].
         */
        fun assignment(
            target: Expr,
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Assignment =
            PartiqlAst.Assignment(
                target = target,
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Statement 
        /**
         * Creates an instance of [PartiqlAst.Statement.Query].
         */
        fun query(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Query =
            PartiqlAst.Statement.Query(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Dml].
         */
        fun dml(
            operations: DmlOpList,
            from: FromSource? = null,
            where: Expr? = null,
            returning: ReturningExpr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Dml =
            PartiqlAst.Statement.Dml(
                operations = operations,
                from = from,
                where = where,
                returning = returning,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Ddl].
         */
        fun ddl(
            op: DdlOp,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Ddl =
            PartiqlAst.Statement.Ddl(
                op = op,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Exec].
         */
        fun exec(
            procedureName: String,
            args: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Exec =
            PartiqlAst.Statement.Exec(
                procedureName = procedureName.asPrimitive(),
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Exec].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun exec_(
            procedureName: org.partiql.pig.runtime.SymbolPrimitive,
            args: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Exec =
            PartiqlAst.Statement.Exec(
                procedureName = procedureName,
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Exec].
         */
        fun exec(
            procedureName: String,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Exec =
            PartiqlAst.Statement.Exec(
                procedureName = procedureName?.asPrimitive(),
                args = args.toList(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Statement.Exec].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun exec_(
            procedureName: org.partiql.pig.runtime.SymbolPrimitive,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Statement.Exec =
            PartiqlAst.Statement.Exec(
                procedureName = procedureName,
                args = args.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Expr 
        /**
         * Creates an instance of [PartiqlAst.Expr.Missing].
         */
        fun missing(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Missing =
            PartiqlAst.Expr.Missing(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Lit].
         */
        fun lit(
            value: com.amazon.ionelement.api.IonElement,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Lit =
            PartiqlAst.Expr.Lit(
                value = value.asAnyElement(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Id].
         */
        fun id(
            name: String,
            case: CaseSensitivity,
            qualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Id =
            PartiqlAst.Expr.Id(
                name = name.asPrimitive(),
                case = case,
                qualifier = qualifier,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Id].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun id_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            case: CaseSensitivity,
            qualifier: ScopeQualifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Id =
            PartiqlAst.Expr.Id(
                name = name,
                case = case,
                qualifier = qualifier,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Parameter].
         */
        fun parameter(
            index: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Parameter =
            PartiqlAst.Expr.Parameter(
                index = index.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Parameter].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun parameter_(
            index: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Parameter =
            PartiqlAst.Expr.Parameter(
                index = index,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Not].
         */
        fun not(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Not =
            PartiqlAst.Expr.Not(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Pos].
         */
        fun pos(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Pos =
            PartiqlAst.Expr.Pos(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Neg].
         */
        fun neg(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Neg =
            PartiqlAst.Expr.Neg(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Plus].
         */
        fun plus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Plus =
            PartiqlAst.Expr.Plus(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Plus].
         */
        fun plus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Plus =
            PartiqlAst.Expr.Plus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Minus].
         */
        fun minus(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Minus =
            PartiqlAst.Expr.Minus(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Minus].
         */
        fun minus(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Minus =
            PartiqlAst.Expr.Minus(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Times].
         */
        fun times(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Times =
            PartiqlAst.Expr.Times(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Times].
         */
        fun times(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Times =
            PartiqlAst.Expr.Times(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Divide].
         */
        fun divide(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Divide =
            PartiqlAst.Expr.Divide(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Divide].
         */
        fun divide(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Divide =
            PartiqlAst.Expr.Divide(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Modulo].
         */
        fun modulo(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Modulo =
            PartiqlAst.Expr.Modulo(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Modulo].
         */
        fun modulo(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Modulo =
            PartiqlAst.Expr.Modulo(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Concat].
         */
        fun concat(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Concat =
            PartiqlAst.Expr.Concat(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Concat].
         */
        fun concat(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Concat =
            PartiqlAst.Expr.Concat(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.And].
         */
        fun and(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.And =
            PartiqlAst.Expr.And(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.And].
         */
        fun and(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.And =
            PartiqlAst.Expr.And(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Or].
         */
        fun or(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Or =
            PartiqlAst.Expr.Or(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Or].
         */
        fun or(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Or =
            PartiqlAst.Expr.Or(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Eq].
         */
        fun eq(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Eq =
            PartiqlAst.Expr.Eq(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Eq].
         */
        fun eq(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Eq =
            PartiqlAst.Expr.Eq(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Ne].
         */
        fun ne(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Ne =
            PartiqlAst.Expr.Ne(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Ne].
         */
        fun ne(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Ne =
            PartiqlAst.Expr.Ne(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Gt].
         */
        fun gt(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Gt =
            PartiqlAst.Expr.Gt(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Gt].
         */
        fun gt(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Gt =
            PartiqlAst.Expr.Gt(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Gte].
         */
        fun gte(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Gte =
            PartiqlAst.Expr.Gte(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Gte].
         */
        fun gte(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Gte =
            PartiqlAst.Expr.Gte(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Lt].
         */
        fun lt(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Lt =
            PartiqlAst.Expr.Lt(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Lt].
         */
        fun lt(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Lt =
            PartiqlAst.Expr.Lt(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Lte].
         */
        fun lte(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Lte =
            PartiqlAst.Expr.Lte(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Lte].
         */
        fun lte(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Lte =
            PartiqlAst.Expr.Lte(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Like].
         */
        fun like(
            value: Expr,
            pattern: Expr,
            escape: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Like =
            PartiqlAst.Expr.Like(
                value = value,
                pattern = pattern,
                escape = escape,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Between].
         */
        fun between(
            value: Expr,
            from: Expr,
            to: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Between =
            PartiqlAst.Expr.Between(
                value = value,
                from = from,
                to = to,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.InCollection].
         */
        fun inCollection(
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.InCollection =
            PartiqlAst.Expr.InCollection(
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.InCollection].
         */
        fun inCollection(
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.InCollection =
            PartiqlAst.Expr.InCollection(
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.IsType].
         */
        fun isType(
            value: Expr,
            type: Type,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.IsType =
            PartiqlAst.Expr.IsType(
                value = value,
                type = type,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.SimpleCase].
         */
        fun simpleCase(
            expr: Expr,
            cases: ExprPairList,
            default: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.SimpleCase =
            PartiqlAst.Expr.SimpleCase(
                expr = expr,
                cases = cases,
                default = default,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.SearchedCase].
         */
        fun searchedCase(
            cases: ExprPairList,
            default: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.SearchedCase =
            PartiqlAst.Expr.SearchedCase(
                cases = cases,
                default = default,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Struct].
         */
        fun struct(
            fields: kotlin.collections.List<ExprPair> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Struct =
            PartiqlAst.Expr.Struct(
                fields = fields,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Struct].
         */
        fun struct(
            vararg fields: ExprPair,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Struct =
            PartiqlAst.Expr.Struct(
                fields = fields.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Bag].
         */
        fun bag(
            values: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Bag =
            PartiqlAst.Expr.Bag(
                values = values,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Bag].
         */
        fun bag(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Bag =
            PartiqlAst.Expr.Bag(
                values = values.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.List].
         */
        fun list(
            values: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.List =
            PartiqlAst.Expr.List(
                values = values,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.List].
         */
        fun list(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.List =
            PartiqlAst.Expr.List(
                values = values.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Sexp].
         */
        fun sexp(
            values: kotlin.collections.List<Expr> = emptyList(),
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Sexp =
            PartiqlAst.Expr.Sexp(
                values = values,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Sexp].
         */
        fun sexp(
            vararg values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Sexp =
            PartiqlAst.Expr.Sexp(
                values = values.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Date].
         */
        fun date(
            year: Long,
            month: Long,
            day: Long,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Date =
            PartiqlAst.Expr.Date(
                year = year.asPrimitive(),
                month = month.asPrimitive(),
                day = day.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Date].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun date_(
            year: org.partiql.pig.runtime.LongPrimitive,
            month: org.partiql.pig.runtime.LongPrimitive,
            day: org.partiql.pig.runtime.LongPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Date =
            PartiqlAst.Expr.Date(
                year = year,
                month = month,
                day = day,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.LitTime].
         */
        fun litTime(
            value: TimeValue,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.LitTime =
            PartiqlAst.Expr.LitTime(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Union].
         */
        fun union(
            setq: SetQuantifier,
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Union =
            PartiqlAst.Expr.Union(
                setq = setq,
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Union].
         */
        fun union(
            setq: SetQuantifier,
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Union =
            PartiqlAst.Expr.Union(
                setq = setq,
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Except].
         */
        fun except(
            setq: SetQuantifier,
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Except =
            PartiqlAst.Expr.Except(
                setq = setq,
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Except].
         */
        fun except(
            setq: SetQuantifier,
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Except =
            PartiqlAst.Expr.Except(
                setq = setq,
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Intersect].
         */
        fun intersect(
            setq: SetQuantifier,
            operands: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Intersect =
            PartiqlAst.Expr.Intersect(
                setq = setq,
                operands = operands,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Intersect].
         */
        fun intersect(
            setq: SetQuantifier,
            operands0: Expr,
            operands1: Expr,
            vararg operands: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Intersect =
            PartiqlAst.Expr.Intersect(
                setq = setq,
                operands = listOf(operands0, operands1) + operands.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Path].
         */
        fun path(
            root: Expr,
            steps: kotlin.collections.List<PathStep>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Path =
            PartiqlAst.Expr.Path(
                root = root,
                steps = steps,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Path].
         */
        fun path(
            root: Expr,
            steps0: PathStep,
            vararg steps: PathStep,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Path =
            PartiqlAst.Expr.Path(
                root = root,
                steps = listOf(steps0) + steps.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Call].
         */
        fun call(
            funcName: String,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Call =
            PartiqlAst.Expr.Call(
                funcName = funcName.asPrimitive(),
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            funcName: org.partiql.pig.runtime.SymbolPrimitive,
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Call =
            PartiqlAst.Expr.Call(
                funcName = funcName,
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Call].
         */
        fun call(
            funcName: String,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Call =
            PartiqlAst.Expr.Call(
                funcName = funcName?.asPrimitive(),
                args = listOf(args0) + args.toList(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Call].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun call_(
            funcName: org.partiql.pig.runtime.SymbolPrimitive,
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Call =
            PartiqlAst.Expr.Call(
                funcName = funcName,
                args = listOf(args0) + args.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.CallAgg].
         */
        fun callAgg(
            setq: SetQuantifier,
            funcName: String,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.CallAgg =
            PartiqlAst.Expr.CallAgg(
                setq = setq,
                funcName = funcName.asPrimitive(),
                arg = arg,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.CallAgg].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun callAgg_(
            setq: SetQuantifier,
            funcName: org.partiql.pig.runtime.SymbolPrimitive,
            arg: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.CallAgg =
            PartiqlAst.Expr.CallAgg(
                setq = setq,
                funcName = funcName,
                arg = arg,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Cast].
         */
        fun cast(
            value: Expr,
            asType: Type,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Cast =
            PartiqlAst.Expr.Cast(
                value = value,
                asType = asType,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.CanCast].
         */
        fun canCast(
            value: Expr,
            asType: Type,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.CanCast =
            PartiqlAst.Expr.CanCast(
                value = value,
                asType = asType,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.CanLosslessCast].
         */
        fun canLosslessCast(
            value: Expr,
            asType: Type,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.CanLosslessCast =
            PartiqlAst.Expr.CanLosslessCast(
                value = value,
                asType = asType,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.NullIf].
         */
        fun nullIf(
            expr1: Expr,
            expr2: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.NullIf =
            PartiqlAst.Expr.NullIf(
                expr1 = expr1,
                expr2 = expr2,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Coalesce].
         */
        fun coalesce(
            args: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Coalesce =
            PartiqlAst.Expr.Coalesce(
                args = args,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Coalesce].
         */
        fun coalesce(
            args0: Expr,
            vararg args: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Coalesce =
            PartiqlAst.Expr.Coalesce(
                args = listOf(args0) + args.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Expr.Select].
         */
        fun select(
            setq: SetQuantifier? = null,
            project: Projection,
            from: FromSource,
            fromLet: Let? = null,
            where: Expr? = null,
            group: GroupBy? = null,
            having: Expr? = null,
            order: OrderBy? = null,
            limit: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Expr.Select =
            PartiqlAst.Expr.Select(
                setq = setq,
                project = project,
                from = from,
                fromLet = fromLet,
                where = where,
                group = group,
                having = having,
                order = order,
                limit = limit,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: PathStep 
        /**
         * Creates an instance of [PartiqlAst.PathStep.PathExpr].
         */
        fun pathExpr(
            index: Expr,
            case: CaseSensitivity,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.PathStep.PathExpr =
            PartiqlAst.PathStep.PathExpr(
                index = index,
                case = case,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.PathStep.PathWildcard].
         */
        fun pathWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.PathStep.PathWildcard =
            PartiqlAst.PathStep.PathWildcard(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.PathStep.PathUnpivot].
         */
        fun pathUnpivot(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.PathStep.PathUnpivot =
            PartiqlAst.PathStep.PathUnpivot(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Projection 
        /**
         * Creates an instance of [PartiqlAst.Projection.ProjectStar].
         */
        fun projectStar(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Projection.ProjectStar =
            PartiqlAst.Projection.ProjectStar(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Projection.ProjectList].
         */
        fun projectList(
            projectItems: kotlin.collections.List<ProjectItem>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Projection.ProjectList =
            PartiqlAst.Projection.ProjectList(
                projectItems = projectItems,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Projection.ProjectList].
         */
        fun projectList(
            projectItems0: ProjectItem,
            vararg projectItems: ProjectItem,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Projection.ProjectList =
            PartiqlAst.Projection.ProjectList(
                projectItems = listOf(projectItems0) + projectItems.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Projection.ProjectPivot].
         */
        fun projectPivot(
            value: Expr,
            key: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Projection.ProjectPivot =
            PartiqlAst.Projection.ProjectPivot(
                value = value,
                key = key,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Projection.ProjectValue].
         */
        fun projectValue(
            value: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Projection.ProjectValue =
            PartiqlAst.Projection.ProjectValue(
                value = value,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ProjectItem 
        /**
         * Creates an instance of [PartiqlAst.ProjectItem.ProjectAll].
         */
        fun projectAll(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ProjectItem.ProjectAll =
            PartiqlAst.ProjectItem.ProjectAll(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ProjectItem.ProjectExpr].
         */
        fun projectExpr(
            expr: Expr,
            asAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ProjectItem.ProjectExpr =
            PartiqlAst.ProjectItem.ProjectExpr(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.ProjectItem.ProjectExpr].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun projectExpr_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ProjectItem.ProjectExpr =
            PartiqlAst.ProjectItem.ProjectExpr(
                expr = expr,
                asAlias = asAlias,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: FromSource 
        /**
         * Creates an instance of [PartiqlAst.FromSource.Scan].
         */
        fun scan(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.FromSource.Scan =
            PartiqlAst.FromSource.Scan(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.FromSource.Scan].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun scan_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            atAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            byAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.FromSource.Scan =
            PartiqlAst.FromSource.Scan(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.FromSource.Unpivot].
         */
        fun unpivot(
            expr: Expr,
            asAlias: String? = null,
            atAlias: String? = null,
            byAlias: String? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.FromSource.Unpivot =
            PartiqlAst.FromSource.Unpivot(
                expr = expr,
                asAlias = asAlias?.asPrimitive(),
                atAlias = atAlias?.asPrimitive(),
                byAlias = byAlias?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.FromSource.Unpivot].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun unpivot_(
            expr: Expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            atAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            byAlias: org.partiql.pig.runtime.SymbolPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.FromSource.Unpivot =
            PartiqlAst.FromSource.Unpivot(
                expr = expr,
                asAlias = asAlias,
                atAlias = atAlias,
                byAlias = byAlias,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.FromSource.Join].
         */
        fun join(
            type: JoinType,
            left: FromSource,
            right: FromSource,
            predicate: Expr? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.FromSource.Join =
            PartiqlAst.FromSource.Join(
                type = type,
                left = left,
                right = right,
                predicate = predicate,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: JoinType 
        /**
         * Creates an instance of [PartiqlAst.JoinType.Inner].
         */
        fun inner(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.JoinType.Inner =
            PartiqlAst.JoinType.Inner(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.JoinType.Left].
         */
        fun left(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.JoinType.Left =
            PartiqlAst.JoinType.Left(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.JoinType.Right].
         */
        fun right(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.JoinType.Right =
            PartiqlAst.JoinType.Right(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.JoinType.Full].
         */
        fun full(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.JoinType.Full =
            PartiqlAst.JoinType.Full(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: GroupingStrategy 
        /**
         * Creates an instance of [PartiqlAst.GroupingStrategy.GroupFull].
         */
        fun groupFull(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupingStrategy.GroupFull =
            PartiqlAst.GroupingStrategy.GroupFull(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.GroupingStrategy.GroupPartial].
         */
        fun groupPartial(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.GroupingStrategy.GroupPartial =
            PartiqlAst.GroupingStrategy.GroupPartial(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: OrderingSpec 
        /**
         * Creates an instance of [PartiqlAst.OrderingSpec.Asc].
         */
        fun asc(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.OrderingSpec.Asc =
            PartiqlAst.OrderingSpec.Asc(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.OrderingSpec.Desc].
         */
        fun desc(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.OrderingSpec.Desc =
            PartiqlAst.OrderingSpec.Desc(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: CaseSensitivity 
        /**
         * Creates an instance of [PartiqlAst.CaseSensitivity.CaseSensitive].
         */
        fun caseSensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.CaseSensitivity.CaseSensitive =
            PartiqlAst.CaseSensitivity.CaseSensitive(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.CaseSensitivity.CaseInsensitive].
         */
        fun caseInsensitive(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.CaseSensitivity.CaseInsensitive =
            PartiqlAst.CaseSensitivity.CaseInsensitive(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ScopeQualifier 
        /**
         * Creates an instance of [PartiqlAst.ScopeQualifier.Unqualified].
         */
        fun unqualified(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ScopeQualifier.Unqualified =
            PartiqlAst.ScopeQualifier.Unqualified(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ScopeQualifier.LocalsFirst].
         */
        fun localsFirst(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ScopeQualifier.LocalsFirst =
            PartiqlAst.ScopeQualifier.LocalsFirst(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: SetQuantifier 
        /**
         * Creates an instance of [PartiqlAst.SetQuantifier.All].
         */
        fun all(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.SetQuantifier.All =
            PartiqlAst.SetQuantifier.All(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.SetQuantifier.Distinct].
         */
        fun distinct(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.SetQuantifier.Distinct =
            PartiqlAst.SetQuantifier.Distinct(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: DmlOp 
        /**
         * Creates an instance of [PartiqlAst.DmlOp.Insert].
         */
        fun insert(
            target: Expr,
            values: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOp.Insert =
            PartiqlAst.DmlOp.Insert(
                target = target,
                values = values,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DmlOp.InsertValue].
         */
        fun insertValue(
            target: Expr,
            value: Expr,
            index: Expr? = null,
            onConflict: OnConflict? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOp.InsertValue =
            PartiqlAst.DmlOp.InsertValue(
                target = target,
                value = value,
                index = index,
                onConflict = onConflict,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DmlOp.Set].
         */
        fun set(
            assignment: Assignment,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOp.Set =
            PartiqlAst.DmlOp.Set(
                assignment = assignment,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DmlOp.Remove].
         */
        fun remove(
            target: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOp.Remove =
            PartiqlAst.DmlOp.Remove(
                target = target,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DmlOp.Delete].
         */
        fun delete(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DmlOp.Delete =
            PartiqlAst.DmlOp.Delete(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ConflictAction 
        /**
         * Creates an instance of [PartiqlAst.ConflictAction.DoNothing].
         */
        fun doNothing(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ConflictAction.DoNothing =
            PartiqlAst.ConflictAction.DoNothing(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: DdlOp 
        /**
         * Creates an instance of [PartiqlAst.DdlOp.CreateTable].
         */
        fun createTable(
            tableName: String,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.CreateTable =
            PartiqlAst.DdlOp.CreateTable(
                tableName = tableName.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.CreateTable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun createTable_(
            tableName: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.CreateTable =
            PartiqlAst.DdlOp.CreateTable(
                tableName = tableName,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.DropTable].
         */
        fun dropTable(
            tableName: Identifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.DropTable =
            PartiqlAst.DdlOp.DropTable(
                tableName = tableName,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.UndropTable].
         */
        fun undropTable(
            tableName: String,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.UndropTable =
            PartiqlAst.DdlOp.UndropTable(
                tableName = tableName.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.UndropTable].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun undropTable_(
            tableName: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.UndropTable =
            PartiqlAst.DdlOp.UndropTable(
                tableName = tableName,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.CreateIndex].
         */
        fun createIndex(
            indexName: Identifier,
            fields: kotlin.collections.List<Expr>,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.CreateIndex =
            PartiqlAst.DdlOp.CreateIndex(
                indexName = indexName,
                fields = fields,
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.CreateIndex].
         */
        fun createIndex(
            indexName: Identifier,
            fields0: Expr,
            vararg fields: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.CreateIndex =
            PartiqlAst.DdlOp.CreateIndex(
                indexName = indexName,
                fields = listOf(fields0) + fields.toList(),
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.DdlOp.DropIndex].
         */
        fun dropIndex(
            table: Identifier,
            keys: Identifier,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.DdlOp.DropIndex =
            PartiqlAst.DdlOp.DropIndex(
                table = table,
                keys = keys,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ColumnComponent 
        /**
         * Creates an instance of [PartiqlAst.ColumnComponent.ReturningWildcard].
         */
        fun returningWildcard(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ColumnComponent.ReturningWildcard =
            PartiqlAst.ColumnComponent.ReturningWildcard(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ColumnComponent.ReturningColumn].
         */
        fun returningColumn(
            expr: Expr,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ColumnComponent.ReturningColumn =
            PartiqlAst.ColumnComponent.ReturningColumn(
                expr = expr,
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: ReturningMapping 
        /**
         * Creates an instance of [PartiqlAst.ReturningMapping.ModifiedNew].
         */
        fun modifiedNew(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningMapping.ModifiedNew =
            PartiqlAst.ReturningMapping.ModifiedNew(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ReturningMapping.ModifiedOld].
         */
        fun modifiedOld(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningMapping.ModifiedOld =
            PartiqlAst.ReturningMapping.ModifiedOld(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ReturningMapping.AllNew].
         */
        fun allNew(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningMapping.AllNew =
            PartiqlAst.ReturningMapping.AllNew(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.ReturningMapping.AllOld].
         */
        fun allOld(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.ReturningMapping.AllOld =
            PartiqlAst.ReturningMapping.AllOld(
                metas = newMetaContainer() + metas
            )
        
        
        // Variants for Sum: Type 
        /**
         * Creates an instance of [PartiqlAst.Type.NullType].
         */
        fun nullType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.NullType =
            PartiqlAst.Type.NullType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.BooleanType].
         */
        fun booleanType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.BooleanType =
            PartiqlAst.Type.BooleanType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SmallintType].
         */
        fun smallintType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SmallintType =
            PartiqlAst.Type.SmallintType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.Integer4Type].
         */
        fun integer4Type(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.Integer4Type =
            PartiqlAst.Type.Integer4Type(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.Integer8Type].
         */
        fun integer8Type(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.Integer8Type =
            PartiqlAst.Type.Integer8Type(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.IntegerType].
         */
        fun integerType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.IntegerType =
            PartiqlAst.Type.IntegerType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.FloatType].
         */
        fun floatType(
            precision: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.FloatType =
            PartiqlAst.Type.FloatType(
                precision = precision?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.FloatType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun floatType_(
            precision: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.FloatType =
            PartiqlAst.Type.FloatType(
                precision = precision,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RealType].
         */
        fun realType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RealType =
            PartiqlAst.Type.RealType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.DoublePrecisionType].
         */
        fun doublePrecisionType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.DoublePrecisionType =
            PartiqlAst.Type.DoublePrecisionType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.DecimalType].
         */
        fun decimalType(
            precision: Long? = null,
            scale: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.DecimalType =
            PartiqlAst.Type.DecimalType(
                precision = precision?.asPrimitive(),
                scale = scale?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.DecimalType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun decimalType_(
            precision: org.partiql.pig.runtime.LongPrimitive? = null,
            scale: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.DecimalType =
            PartiqlAst.Type.DecimalType(
                precision = precision,
                scale = scale,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.NumericType].
         */
        fun numericType(
            precision: Long? = null,
            scale: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.NumericType =
            PartiqlAst.Type.NumericType(
                precision = precision?.asPrimitive(),
                scale = scale?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.NumericType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun numericType_(
            precision: org.partiql.pig.runtime.LongPrimitive? = null,
            scale: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.NumericType =
            PartiqlAst.Type.NumericType(
                precision = precision,
                scale = scale,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.TimestampType].
         */
        fun timestampType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TimestampType =
            PartiqlAst.Type.TimestampType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.CharacterType].
         */
        fun characterType(
            length: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CharacterType =
            PartiqlAst.Type.CharacterType(
                length = length?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.CharacterType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun characterType_(
            length: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CharacterType =
            PartiqlAst.Type.CharacterType(
                length = length,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.CharacterVaryingType].
         */
        fun characterVaryingType(
            length: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CharacterVaryingType =
            PartiqlAst.Type.CharacterVaryingType(
                length = length?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.CharacterVaryingType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun characterVaryingType_(
            length: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CharacterVaryingType =
            PartiqlAst.Type.CharacterVaryingType(
                length = length,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.MissingType].
         */
        fun missingType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.MissingType =
            PartiqlAst.Type.MissingType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.StringType].
         */
        fun stringType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.StringType =
            PartiqlAst.Type.StringType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SymbolType].
         */
        fun symbolType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SymbolType =
            PartiqlAst.Type.SymbolType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.BlobType].
         */
        fun blobType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.BlobType =
            PartiqlAst.Type.BlobType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.ClobType].
         */
        fun clobType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.ClobType =
            PartiqlAst.Type.ClobType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.DateType].
         */
        fun dateType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.DateType =
            PartiqlAst.Type.DateType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.TimeType].
         */
        fun timeType(
            precision: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TimeType =
            PartiqlAst.Type.TimeType(
                precision = precision?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.TimeType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun timeType_(
            precision: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TimeType =
            PartiqlAst.Type.TimeType(
                precision = precision,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.TimeWithTimeZoneType].
         */
        fun timeWithTimeZoneType(
            precision: Long? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TimeWithTimeZoneType =
            PartiqlAst.Type.TimeWithTimeZoneType(
                precision = precision?.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.TimeWithTimeZoneType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun timeWithTimeZoneType_(
            precision: org.partiql.pig.runtime.LongPrimitive? = null,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TimeWithTimeZoneType =
            PartiqlAst.Type.TimeWithTimeZoneType(
                precision = precision,
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.StructType].
         */
        fun structType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.StructType =
            PartiqlAst.Type.StructType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.TupleType].
         */
        fun tupleType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.TupleType =
            PartiqlAst.Type.TupleType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.ListType].
         */
        fun listType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.ListType =
            PartiqlAst.Type.ListType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SexpType].
         */
        fun sexpType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SexpType =
            PartiqlAst.Type.SexpType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.BagType].
         */
        fun bagType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.BagType =
            PartiqlAst.Type.BagType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.AnyType].
         */
        fun anyType(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.AnyType =
            PartiqlAst.Type.AnyType(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.EsBoolean].
         */
        fun esBoolean(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.EsBoolean =
            PartiqlAst.Type.EsBoolean(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.EsInteger].
         */
        fun esInteger(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.EsInteger =
            PartiqlAst.Type.EsInteger(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.EsFloat].
         */
        fun esFloat(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.EsFloat =
            PartiqlAst.Type.EsFloat(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.EsText].
         */
        fun esText(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.EsText =
            PartiqlAst.Type.EsText(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.EsAny].
         */
        fun esAny(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.EsAny =
            PartiqlAst.Type.EsAny(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkShort].
         */
        fun sparkShort(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkShort =
            PartiqlAst.Type.SparkShort(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkInteger].
         */
        fun sparkInteger(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkInteger =
            PartiqlAst.Type.SparkInteger(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkLong].
         */
        fun sparkLong(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkLong =
            PartiqlAst.Type.SparkLong(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkDouble].
         */
        fun sparkDouble(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkDouble =
            PartiqlAst.Type.SparkDouble(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkBoolean].
         */
        fun sparkBoolean(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkBoolean =
            PartiqlAst.Type.SparkBoolean(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.SparkFloat].
         */
        fun sparkFloat(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.SparkFloat =
            PartiqlAst.Type.SparkFloat(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsVarcharMax].
         */
        fun rsVarcharMax(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsVarcharMax =
            PartiqlAst.Type.RsVarcharMax(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsInteger].
         */
        fun rsInteger(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsInteger =
            PartiqlAst.Type.RsInteger(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsBigint].
         */
        fun rsBigint(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsBigint =
            PartiqlAst.Type.RsBigint(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsBoolean].
         */
        fun rsBoolean(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsBoolean =
            PartiqlAst.Type.RsBoolean(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsReal].
         */
        fun rsReal(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsReal =
            PartiqlAst.Type.RsReal(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.RsDoublePrecision].
         */
        fun rsDoublePrecision(
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.RsDoublePrecision =
            PartiqlAst.Type.RsDoublePrecision(
                metas = newMetaContainer() + metas
            )
        
        
        /**
         * Creates an instance of [PartiqlAst.Type.CustomType].
         */
        fun customType(
            name: String,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CustomType =
            PartiqlAst.Type.CustomType(
                name = name.asPrimitive(),
                metas = newMetaContainer() + metas
            )
        
        /**
         * Creates an instance of [PartiqlAst.Type.CustomType].
         *
         * Use this variant when metas must be passed to primitive child elements.
         *
         * (The "_" suffix is needed to work-around conflicts due to type erasure and ambiguities with null arguments.)
         */
        fun customType_(
            name: org.partiql.pig.runtime.SymbolPrimitive,
            metas: MetaContainer = emptyMetaContainer()
        ): PartiqlAst.Type.CustomType =
            PartiqlAst.Type.CustomType(
                name = name,
                metas = newMetaContainer() + metas
            )
    }
    
    /** Default implementation of [Builder] that uses all default method implementations. */
    private object PartiqlAstBuilder : Builder
    
    /** Base class for all PartiqlAst types. */
    abstract class PartiqlAstNode : DomainNode {
        abstract override fun copy(metas: MetaContainer): PartiqlAstNode
        override fun toString() = toIonElement().toString()
        abstract override fun withMeta(metaKey: String, metaValue: Any): PartiqlAstNode
        abstract override fun toIonElement(): SexpElement
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Tuple Types
    /////////////////////////////////////////////////////////////////////////////
    class TimeValue(
        val hour: org.partiql.pig.runtime.LongPrimitive,
        val minute: org.partiql.pig.runtime.LongPrimitive,
        val second: org.partiql.pig.runtime.LongPrimitive,
        val nano: org.partiql.pig.runtime.LongPrimitive,
        val precision: org.partiql.pig.runtime.LongPrimitive,
        val tzMinutes: org.partiql.pig.runtime.LongPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): TimeValue =
            TimeValue(
                hour = hour,
                minute = minute,
                second = second,
                nano = nano,
                precision = precision,
                tzMinutes = tzMinutes,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): TimeValue =
            TimeValue(
                hour = hour,
                minute = minute,
                second = second,
                nano = nano,
                precision = precision,
                tzMinutes = tzMinutes,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("time_value"),
                hour.toIonElement(),
                minute.toIonElement(),
                second.toIonElement(),
                nano.toIonElement(),
                precision.toIonElement(),
                tzMinutes?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            hour: org.partiql.pig.runtime.LongPrimitive = this.hour,
            minute: org.partiql.pig.runtime.LongPrimitive = this.minute,
            second: org.partiql.pig.runtime.LongPrimitive = this.second,
            nano: org.partiql.pig.runtime.LongPrimitive = this.nano,
            precision: org.partiql.pig.runtime.LongPrimitive = this.precision,
            tzMinutes: org.partiql.pig.runtime.LongPrimitive? = this.tzMinutes,
            metas: MetaContainer = this.metas
        ) =
            TimeValue(
                hour,
                minute,
                second,
                nano,
                precision,
                tzMinutes,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != TimeValue::class.java) return false
    
            other as TimeValue
            if (hour != other.hour) return false
            if (minute != other.minute) return false
            if (second != other.second) return false
            if (nano != other.nano) return false
            if (precision != other.precision) return false
            if (tzMinutes != other.tzMinutes) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = hour.hashCode()
            hc = 31 * hc + minute.hashCode()
            hc = 31 * hc + second.hashCode()
            hc = 31 * hc + nano.hashCode()
            hc = 31 * hc + precision.hashCode()
            hc = 31 * hc + tzMinutes.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Let(
        val letBindings: kotlin.collections.List<LetBinding>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): Let =
            Let(
                letBindings = letBindings,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Let =
            Let(
                letBindings = letBindings,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("let"),
                *letBindings.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            letBindings: kotlin.collections.List<LetBinding> = this.letBindings,
            metas: MetaContainer = this.metas
        ) =
            Let(
                letBindings,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Let::class.java) return false
    
            other as Let
            if (letBindings != other.letBindings) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = letBindings.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class LetBinding(
        val expr: Expr,
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): LetBinding =
            LetBinding(
                expr = expr,
                name = name,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): LetBinding =
            LetBinding(
                expr = expr,
                name = name,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("let_binding"),
                expr.toIonElement(),
                name.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            expr: Expr = this.expr,
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            metas: MetaContainer = this.metas
        ) =
            LetBinding(
                expr,
                name,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != LetBinding::class.java) return false
    
            other as LetBinding
            if (expr != other.expr) return false
            if (name != other.name) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = expr.hashCode()
            hc = 31 * hc + name.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ExprPair(
        val first: Expr,
        val second: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ExprPair =
            ExprPair(
                first = first,
                second = second,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair"),
                first.toIonElement(),
                second.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            first: Expr = this.first,
            second: Expr = this.second,
            metas: MetaContainer = this.metas
        ) =
            ExprPair(
                first,
                second,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPair::class.java) return false
    
            other as ExprPair
            if (first != other.first) return false
            if (second != other.second) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = first.hashCode()
            hc = 31 * hc + second.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ExprPairList(
        val pairs: kotlin.collections.List<ExprPair>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): ExprPairList =
            ExprPairList(
                pairs = pairs,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ExprPairList =
            ExprPairList(
                pairs = pairs,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("expr_pair_list"),
                *pairs.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            pairs: kotlin.collections.List<ExprPair> = this.pairs,
            metas: MetaContainer = this.metas
        ) =
            ExprPairList(
                pairs,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ExprPairList::class.java) return false
    
            other as ExprPairList
            if (pairs != other.pairs) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = pairs.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupBy(
        val strategy: GroupingStrategy,
        val keyList: GroupKeyList,
        val groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): GroupBy =
            GroupBy(
                strategy = strategy,
                keyList = keyList,
                groupAsAlias = groupAsAlias,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupBy =
            GroupBy(
                strategy = strategy,
                keyList = keyList,
                groupAsAlias = groupAsAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_by"),
                strategy.toIonElement(),
                keyList.toIonElement(),
                groupAsAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            strategy: GroupingStrategy = this.strategy,
            keyList: GroupKeyList = this.keyList,
            groupAsAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.groupAsAlias,
            metas: MetaContainer = this.metas
        ) =
            GroupBy(
                strategy,
                keyList,
                groupAsAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupBy::class.java) return false
    
            other as GroupBy
            if (strategy != other.strategy) return false
            if (keyList != other.keyList) return false
            if (groupAsAlias != other.groupAsAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = strategy.hashCode()
            hc = 31 * hc + keyList.hashCode()
            hc = 31 * hc + groupAsAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupKeyList(
        val keys: kotlin.collections.List<GroupKey>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): GroupKeyList =
            GroupKeyList(
                keys = keys,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupKeyList =
            GroupKeyList(
                keys = keys,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_key_list"),
                *keys.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            keys: kotlin.collections.List<GroupKey> = this.keys,
            metas: MetaContainer = this.metas
        ) =
            GroupKeyList(
                keys,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupKeyList::class.java) return false
    
            other as GroupKeyList
            if (keys != other.keys) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = keys.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class GroupKey(
        val expr: Expr,
        val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): GroupKey =
            GroupKey(
                expr = expr,
                asAlias = asAlias,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): GroupKey =
            GroupKey(
                expr = expr,
                asAlias = asAlias,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("group_key"),
                expr.toIonElement(),
                asAlias?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            expr: Expr = this.expr,
            asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
            metas: MetaContainer = this.metas
        ) =
            GroupKey(
                expr,
                asAlias,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != GroupKey::class.java) return false
    
            other as GroupKey
            if (expr != other.expr) return false
            if (asAlias != other.asAlias) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = expr.hashCode()
            hc = 31 * hc + asAlias.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class OrderBy(
        val sortSpecs: kotlin.collections.List<SortSpec>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): OrderBy =
            OrderBy(
                sortSpecs = sortSpecs,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): OrderBy =
            OrderBy(
                sortSpecs = sortSpecs,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("order_by"),
                *sortSpecs.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            sortSpecs: kotlin.collections.List<SortSpec> = this.sortSpecs,
            metas: MetaContainer = this.metas
        ) =
            OrderBy(
                sortSpecs,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != OrderBy::class.java) return false
    
            other as OrderBy
            if (sortSpecs != other.sortSpecs) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = sortSpecs.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class SortSpec(
        val expr: Expr,
        val orderingSpec: OrderingSpec?,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): SortSpec =
            SortSpec(
                expr = expr,
                orderingSpec = orderingSpec,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): SortSpec =
            SortSpec(
                expr = expr,
                orderingSpec = orderingSpec,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("sort_spec"),
                expr.toIonElement(),
                orderingSpec?.toIonElement() ?: ionNull(),
                metas = metas)
            return elements
        }
    
        fun copy(
            expr: Expr = this.expr,
            orderingSpec: OrderingSpec? = this.orderingSpec,
            metas: MetaContainer = this.metas
        ) =
            SortSpec(
                expr,
                orderingSpec,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != SortSpec::class.java) return false
    
            other as SortSpec
            if (expr != other.expr) return false
            if (orderingSpec != other.orderingSpec) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = expr.hashCode()
            hc = 31 * hc + orderingSpec.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class DmlOpList(
        val ops: kotlin.collections.List<DmlOp>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): DmlOpList =
            DmlOpList(
                ops = ops,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): DmlOpList =
            DmlOpList(
                ops = ops,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("dml_op_list"),
                *ops.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            ops: kotlin.collections.List<DmlOp> = this.ops,
            metas: MetaContainer = this.metas
        ) =
            DmlOpList(
                ops,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != DmlOpList::class.java) return false
    
            other as DmlOpList
            if (ops != other.ops) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = ops.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class OnConflict(
        val expr: Expr,
        val conflictAction: ConflictAction,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): OnConflict =
            OnConflict(
                expr = expr,
                conflictAction = conflictAction,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): OnConflict =
            OnConflict(
                expr = expr,
                conflictAction = conflictAction,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("on_conflict"),
                expr.toIonElement(),
                conflictAction.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            expr: Expr = this.expr,
            conflictAction: ConflictAction = this.conflictAction,
            metas: MetaContainer = this.metas
        ) =
            OnConflict(
                expr,
                conflictAction,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != OnConflict::class.java) return false
    
            other as OnConflict
            if (expr != other.expr) return false
            if (conflictAction != other.conflictAction) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = expr.hashCode()
            hc = 31 * hc + conflictAction.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ReturningExpr(
        val elems: kotlin.collections.List<ReturningElem>,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): ReturningExpr =
            ReturningExpr(
                elems = elems,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ReturningExpr =
            ReturningExpr(
                elems = elems,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("returning_expr"),
                *elems.map { it.toIonElement() }.toTypedArray(),
                metas = metas)
            return elements
        }
    
        fun copy(
            elems: kotlin.collections.List<ReturningElem> = this.elems,
            metas: MetaContainer = this.metas
        ) =
            ReturningExpr(
                elems,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ReturningExpr::class.java) return false
    
            other as ReturningExpr
            if (elems != other.elems) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = elems.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class ReturningElem(
        val mapping: ReturningMapping,
        val column: ColumnComponent,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): ReturningElem =
            ReturningElem(
                mapping = mapping,
                column = column,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): ReturningElem =
            ReturningElem(
                mapping = mapping,
                column = column,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("returning_elem"),
                mapping.toIonElement(),
                column.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            mapping: ReturningMapping = this.mapping,
            column: ColumnComponent = this.column,
            metas: MetaContainer = this.metas
        ) =
            ReturningElem(
                mapping,
                column,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != ReturningElem::class.java) return false
    
            other as ReturningElem
            if (mapping != other.mapping) return false
            if (column != other.column) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = mapping.hashCode()
            hc = 31 * hc + column.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Identifier(
        val name: org.partiql.pig.runtime.SymbolPrimitive,
        val case: CaseSensitivity,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): Identifier =
            Identifier(
                name = name,
                case = case,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Identifier =
            Identifier(
                name = name,
                case = case,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("identifier"),
                name.toIonElement(),
                case.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
            case: CaseSensitivity = this.case,
            metas: MetaContainer = this.metas
        ) =
            Identifier(
                name,
                case,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Identifier::class.java) return false
    
            other as Identifier
            if (name != other.name) return false
            if (case != other.case) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = name.hashCode()
            hc = 31 * hc + case.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    class Assignment(
        val target: Expr,
        val value: Expr,
        override val metas: MetaContainer = emptyMetaContainer()
    ): PartiqlAstNode() {
    
        override fun copy(metas: MetaContainer): Assignment =
            Assignment(
                target = target,
                value = value,
                metas = metas)
    
        override fun withMeta(metaKey: String, metaValue: Any): Assignment =
            Assignment(
                target = target,
                value = value,
                metas = metas + metaContainerOf(metaKey to metaValue))
    
        override fun toIonElement(): SexpElement {
            val elements = ionSexpOf(
                ionSymbol("assignment"),
                target.toIonElement(),
                value.toIonElement(),
                metas = metas)
            return elements
        }
    
        fun copy(
            target: Expr = this.target,
            value: Expr = this.value,
            metas: MetaContainer = this.metas
        ) =
            Assignment(
                target,
                value,
                metas)
    
        override fun equals(other: Any?): Boolean {
            if (other == null) return false
            if (this === other) return true
            if (other.javaClass != Assignment::class.java) return false
    
            other as Assignment
            if (target != other.target) return false
            if (value != other.value) return false
            return true
        }
    
        private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
            var hc = target.hashCode()
            hc = 31 * hc + value.hashCode()
            hc
        }
    
        override fun hashCode(): Int = myHashCode
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Sum Types
    /////////////////////////////////////////////////////////////////////////////
    
    sealed class Statement(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): Statement =
            when (this) {
                is Query -> copy(metas = metas)
                is Dml -> copy(metas = metas)
                is Ddl -> copy(metas = metas)
                is Exec -> copy(metas = metas)
            }
    
        class Query(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Statement() {
        
            override fun copy(metas: MetaContainer): Query =
                Query(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Query =
                Query(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("query"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Query(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Query::class.java) return false
        
                other as Query
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Dml(
            val operations: DmlOpList,
            val from: FromSource?,
            val where: Expr?,
            val returning: ReturningExpr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Statement() {
        
            override fun copy(metas: MetaContainer): Dml =
                Dml(
                    operations = operations,
                    from = from,
                    where = where,
                    returning = returning,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Dml =
                Dml(
                    operations = operations,
                    from = from,
                    where = where,
                    returning = returning,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("dml"),
                    operations?.let { ionSexpOf(ionSymbol("operations"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    returning?.let { ionSexpOf(ionSymbol("returning"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                operations: DmlOpList = this.operations,
                from: FromSource? = this.from,
                where: Expr? = this.where,
                returning: ReturningExpr? = this.returning,
                metas: MetaContainer = this.metas
            ) =
                Dml(
                    operations,
                    from,
                    where,
                    returning,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Dml::class.java) return false
        
                other as Dml
                if (operations != other.operations) return false
                if (from != other.from) return false
                if (where != other.where) return false
                if (returning != other.returning) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operations.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + returning.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Ddl(
            val op: DdlOp,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Statement() {
        
            override fun copy(metas: MetaContainer): Ddl =
                Ddl(
                    op = op,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Ddl =
                Ddl(
                    op = op,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("ddl"),
                    op.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                op: DdlOp = this.op,
                metas: MetaContainer = this.metas
            ) =
                Ddl(
                    op,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Ddl::class.java) return false
        
                other as Ddl
                if (op != other.op) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = op.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Exec(
            val procedureName: org.partiql.pig.runtime.SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Statement() {
        
            override fun copy(metas: MetaContainer): Exec =
                Exec(
                    procedureName = procedureName,
                    args = args,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Exec =
                Exec(
                    procedureName = procedureName,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("exec"),
                    procedureName.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                procedureName: org.partiql.pig.runtime.SymbolPrimitive = this.procedureName,
                args: kotlin.collections.List<Expr> = this.args,
                metas: MetaContainer = this.metas
            ) =
                Exec(
                    procedureName,
                    args,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Exec::class.java) return false
        
                other as Exec
                if (procedureName != other.procedureName) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = procedureName.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.Statement] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.Statement): T = when(node) {
                is PartiqlAst.Statement.Query -> convertQuery(node)
                is PartiqlAst.Statement.Dml -> convertDml(node)
                is PartiqlAst.Statement.Ddl -> convertDdl(node)
                is PartiqlAst.Statement.Exec -> convertExec(node)
            }
    
            fun convertQuery(node: PartiqlAst.Statement.Query): T
            fun convertDml(node: PartiqlAst.Statement.Dml): T
            fun convertDdl(node: PartiqlAst.Statement.Ddl): T
            fun convertExec(node: PartiqlAst.Statement.Exec): T
        }
    }
    
    sealed class Expr(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): Expr =
            when (this) {
                is Missing -> copy(metas = metas)
                is Lit -> copy(metas = metas)
                is Id -> copy(metas = metas)
                is Parameter -> copy(metas = metas)
                is Not -> copy(metas = metas)
                is Pos -> copy(metas = metas)
                is Neg -> copy(metas = metas)
                is Plus -> copy(metas = metas)
                is Minus -> copy(metas = metas)
                is Times -> copy(metas = metas)
                is Divide -> copy(metas = metas)
                is Modulo -> copy(metas = metas)
                is Concat -> copy(metas = metas)
                is And -> copy(metas = metas)
                is Or -> copy(metas = metas)
                is Eq -> copy(metas = metas)
                is Ne -> copy(metas = metas)
                is Gt -> copy(metas = metas)
                is Gte -> copy(metas = metas)
                is Lt -> copy(metas = metas)
                is Lte -> copy(metas = metas)
                is Like -> copy(metas = metas)
                is Between -> copy(metas = metas)
                is InCollection -> copy(metas = metas)
                is IsType -> copy(metas = metas)
                is SimpleCase -> copy(metas = metas)
                is SearchedCase -> copy(metas = metas)
                is Struct -> copy(metas = metas)
                is Bag -> copy(metas = metas)
                is List -> copy(metas = metas)
                is Sexp -> copy(metas = metas)
                is Date -> copy(metas = metas)
                is LitTime -> copy(metas = metas)
                is Union -> copy(metas = metas)
                is Except -> copy(metas = metas)
                is Intersect -> copy(metas = metas)
                is Path -> copy(metas = metas)
                is Call -> copy(metas = metas)
                is CallAgg -> copy(metas = metas)
                is Cast -> copy(metas = metas)
                is CanCast -> copy(metas = metas)
                is CanLosslessCast -> copy(metas = metas)
                is NullIf -> copy(metas = metas)
                is Coalesce -> copy(metas = metas)
                is Select -> copy(metas = metas)
            }
    
        class Missing(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Missing =
                Missing(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Missing =
                Missing(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("missing"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Missing::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 2000
        }
    
        class Lit(
            val value: com.amazon.ionelement.api.AnyElement,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lit =
                Lit(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lit =
                Lit(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: com.amazon.ionelement.api.AnyElement = this.value,
                metas: MetaContainer = this.metas
            ) =
                Lit(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lit::class.java) return false
        
                other as Lit
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Id(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            val case: CaseSensitivity,
            val qualifier: ScopeQualifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Id =
                Id(
                    name = name,
                    case = case,
                    qualifier = qualifier,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Id =
                Id(
                    name = name,
                    case = case,
                    qualifier = qualifier,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("id"),
                    name.toIonElement(),
                    case.toIonElement(),
                    qualifier.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                case: CaseSensitivity = this.case,
                qualifier: ScopeQualifier = this.qualifier,
                metas: MetaContainer = this.metas
            ) =
                Id(
                    name,
                    case,
                    qualifier,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Id::class.java) return false
        
                other as Id
                if (name != other.name) return false
                if (case != other.case) return false
                if (qualifier != other.qualifier) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc = 31 * hc + case.hashCode()
                hc = 31 * hc + qualifier.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Parameter(
            val index: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Parameter =
                Parameter(
                    index = index,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Parameter =
                Parameter(
                    index = index,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("parameter"),
                    index.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: org.partiql.pig.runtime.LongPrimitive = this.index,
                metas: MetaContainer = this.metas
            ) =
                Parameter(
                    index,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Parameter::class.java) return false
        
                other as Parameter
                if (index != other.index) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = index.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Not(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Not =
                Not(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Not =
                Not(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("not"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Not(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Not::class.java) return false
        
                other as Not
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Pos(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Pos =
                Pos(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Pos =
                Pos(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("pos"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Pos(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Pos::class.java) return false
        
                other as Pos
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Neg(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Neg =
                Neg(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Neg =
                Neg(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("neg"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                Neg(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Neg::class.java) return false
        
                other as Neg
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Plus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Plus =
                Plus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Plus =
                Plus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("plus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Plus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Plus::class.java) return false
        
                other as Plus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Minus(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Minus =
                Minus(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Minus =
                Minus(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("minus"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Minus(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Minus::class.java) return false
        
                other as Minus
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Times(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Times =
                Times(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Times =
                Times(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("times"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Times(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Times::class.java) return false
        
                other as Times
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Divide(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Divide =
                Divide(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Divide =
                Divide(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("divide"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Divide(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Divide::class.java) return false
        
                other as Divide
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Modulo(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Modulo =
                Modulo(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modulo"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Modulo(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Modulo::class.java) return false
        
                other as Modulo
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Concat(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Concat =
                Concat(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Concat =
                Concat(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("concat"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Concat(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Concat::class.java) return false
        
                other as Concat
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class And(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): And =
                And(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): And =
                And(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("and"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                And(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != And::class.java) return false
        
                other as And
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Or(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Or =
                Or(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Or =
                Or(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("or"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Or(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Or::class.java) return false
        
                other as Or
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Eq(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Eq =
                Eq(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Eq =
                Eq(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("eq"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Eq(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Eq::class.java) return false
        
                other as Eq
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Ne(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Ne =
                Ne(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Ne =
                Ne(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("ne"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Ne(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Ne::class.java) return false
        
                other as Ne
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Gt(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Gt =
                Gt(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Gt =
                Gt(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("gt"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Gt(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Gt::class.java) return false
        
                other as Gt
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Gte(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Gte =
                Gte(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Gte =
                Gte(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("gte"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Gte(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Gte::class.java) return false
        
                other as Gte
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Lt(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lt =
                Lt(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lt =
                Lt(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lt"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Lt(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lt::class.java) return false
        
                other as Lt
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Lte(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Lte =
                Lte(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Lte =
                Lte(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lte"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Lte(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Lte::class.java) return false
        
                other as Lte
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Like(
            val value: Expr,
            val pattern: Expr,
            val escape: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Like =
                Like(
                    value = value,
                    pattern = pattern,
                    escape = escape,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Like =
                Like(
                    value = value,
                    pattern = pattern,
                    escape = escape,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("like"),
                    value.toIonElement(),
                    pattern.toIonElement(),
                    escape?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                pattern: Expr = this.pattern,
                escape: Expr? = this.escape,
                metas: MetaContainer = this.metas
            ) =
                Like(
                    value,
                    pattern,
                    escape,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Like::class.java) return false
        
                other as Like
                if (value != other.value) return false
                if (pattern != other.pattern) return false
                if (escape != other.escape) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + pattern.hashCode()
                hc = 31 * hc + escape.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Between(
            val value: Expr,
            val from: Expr,
            val to: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Between =
                Between(
                    value = value,
                    from = from,
                    to = to,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("between"),
                    value.toIonElement(),
                    from.toIonElement(),
                    to.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                from: Expr = this.from,
                to: Expr = this.to,
                metas: MetaContainer = this.metas
            ) =
                Between(
                    value,
                    from,
                    to,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Between::class.java) return false
        
                other as Between
                if (value != other.value) return false
                if (from != other.from) return false
                if (to != other.to) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + to.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class InCollection(
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): InCollection =
                InCollection(
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): InCollection =
                InCollection(
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("in_collection"),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                InCollection(
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != InCollection::class.java) return false
        
                other as InCollection
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class IsType(
            val value: Expr,
            val type: Type,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): IsType =
                IsType(
                    value = value,
                    type = type,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): IsType =
                IsType(
                    value = value,
                    type = type,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("is_type"),
                    value.toIonElement(),
                    type.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                type: Type = this.type,
                metas: MetaContainer = this.metas
            ) =
                IsType(
                    value,
                    type,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != IsType::class.java) return false
        
                other as IsType
                if (value != other.value) return false
                if (type != other.type) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + type.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SimpleCase(
            val expr: Expr,
            val cases: ExprPairList,
            val default: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): SimpleCase =
                SimpleCase(
                    expr = expr,
                    cases = cases,
                    default = default,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SimpleCase =
                SimpleCase(
                    expr = expr,
                    cases = cases,
                    default = default,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("simple_case"),
                    expr.toIonElement(),
                    cases.toIonElement(),
                    default?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                cases: ExprPairList = this.cases,
                default: Expr? = this.default,
                metas: MetaContainer = this.metas
            ) =
                SimpleCase(
                    expr,
                    cases,
                    default,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SimpleCase::class.java) return false
        
                other as SimpleCase
                if (expr != other.expr) return false
                if (cases != other.cases) return false
                if (default != other.default) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc = 31 * hc + cases.hashCode()
                hc = 31 * hc + default.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class SearchedCase(
            val cases: ExprPairList,
            val default: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): SearchedCase =
                SearchedCase(
                    cases = cases,
                    default = default,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SearchedCase =
                SearchedCase(
                    cases = cases,
                    default = default,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("searched_case"),
                    cases.toIonElement(),
                    default?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                cases: ExprPairList = this.cases,
                default: Expr? = this.default,
                metas: MetaContainer = this.metas
            ) =
                SearchedCase(
                    cases,
                    default,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SearchedCase::class.java) return false
        
                other as SearchedCase
                if (cases != other.cases) return false
                if (default != other.default) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = cases.hashCode()
                hc = 31 * hc + default.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Struct(
            val fields: kotlin.collections.List<ExprPair>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Struct =
                Struct(
                    fields = fields,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Struct =
                Struct(
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct"),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                fields: kotlin.collections.List<ExprPair> = this.fields,
                metas: MetaContainer = this.metas
            ) =
                Struct(
                    fields,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Struct::class.java) return false
        
                other as Struct
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Bag(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Bag =
                Bag(
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Bag =
                Bag(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas
            ) =
                Bag(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Bag::class.java) return false
        
                other as Bag
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class List(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): List =
                List(
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): List =
                List(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas
            ) =
                List(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != List::class.java) return false
        
                other as List
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Sexp(
            val values: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Sexp =
                Sexp(
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Sexp =
                Sexp(
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("sexp"),
                    *values.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                values: kotlin.collections.List<Expr> = this.values,
                metas: MetaContainer = this.metas
            ) =
                Sexp(
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Sexp::class.java) return false
        
                other as Sexp
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Date(
            val year: org.partiql.pig.runtime.LongPrimitive,
            val month: org.partiql.pig.runtime.LongPrimitive,
            val day: org.partiql.pig.runtime.LongPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Date =
                Date(
                    year = year,
                    month = month,
                    day = day,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Date =
                Date(
                    year = year,
                    month = month,
                    day = day,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("date"),
                    year.toIonElement(),
                    month.toIonElement(),
                    day.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                year: org.partiql.pig.runtime.LongPrimitive = this.year,
                month: org.partiql.pig.runtime.LongPrimitive = this.month,
                day: org.partiql.pig.runtime.LongPrimitive = this.day,
                metas: MetaContainer = this.metas
            ) =
                Date(
                    year,
                    month,
                    day,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Date::class.java) return false
        
                other as Date
                if (year != other.year) return false
                if (month != other.month) return false
                if (day != other.day) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = year.hashCode()
                hc = 31 * hc + month.hashCode()
                hc = 31 * hc + day.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class LitTime(
            val value: TimeValue,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): LitTime =
                LitTime(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): LitTime =
                LitTime(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("lit_time"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: TimeValue = this.value,
                metas: MetaContainer = this.metas
            ) =
                LitTime(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != LitTime::class.java) return false
        
                other as LitTime
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Union(
            val setq: SetQuantifier,
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Union =
                Union(
                    setq = setq,
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Union =
                Union(
                    setq = setq,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("union"),
                    setq.toIonElement(),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                setq: SetQuantifier = this.setq,
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Union(
                    setq,
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Union::class.java) return false
        
                other as Union
                if (setq != other.setq) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Except(
            val setq: SetQuantifier,
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Except =
                Except(
                    setq = setq,
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Except =
                Except(
                    setq = setq,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("except"),
                    setq.toIonElement(),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                setq: SetQuantifier = this.setq,
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Except(
                    setq,
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Except::class.java) return false
        
                other as Except
                if (setq != other.setq) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Intersect(
            val setq: SetQuantifier,
            val operands: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Intersect =
                Intersect(
                    setq = setq,
                    operands = operands,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Intersect =
                Intersect(
                    setq = setq,
                    operands = operands,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("intersect"),
                    setq.toIonElement(),
                    *operands.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                setq: SetQuantifier = this.setq,
                operands: kotlin.collections.List<Expr> = this.operands,
                metas: MetaContainer = this.metas
            ) =
                Intersect(
                    setq,
                    operands,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Intersect::class.java) return false
        
                other as Intersect
                if (setq != other.setq) return false
                if (operands != other.operands) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + operands.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Path(
            val root: Expr,
            val steps: kotlin.collections.List<PathStep>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Path =
                Path(
                    root = root,
                    steps = steps,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Path =
                Path(
                    root = root,
                    steps = steps,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path"),
                    root.toIonElement(),
                    *steps.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                root: Expr = this.root,
                steps: kotlin.collections.List<PathStep> = this.steps,
                metas: MetaContainer = this.metas
            ) =
                Path(
                    root,
                    steps,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Path::class.java) return false
        
                other as Path
                if (root != other.root) return false
                if (steps != other.steps) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = root.hashCode()
                hc = 31 * hc + steps.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Call(
            val funcName: org.partiql.pig.runtime.SymbolPrimitive,
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Call =
                Call(
                    funcName = funcName,
                    args = args,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Call =
                Call(
                    funcName = funcName,
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call"),
                    funcName.toIonElement(),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                funcName: org.partiql.pig.runtime.SymbolPrimitive = this.funcName,
                args: kotlin.collections.List<Expr> = this.args,
                metas: MetaContainer = this.metas
            ) =
                Call(
                    funcName,
                    args,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Call::class.java) return false
        
                other as Call
                if (funcName != other.funcName) return false
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = funcName.hashCode()
                hc = 31 * hc + args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CallAgg(
            val setq: SetQuantifier,
            val funcName: org.partiql.pig.runtime.SymbolPrimitive,
            val arg: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): CallAgg =
                CallAgg(
                    setq = setq,
                    funcName = funcName,
                    arg = arg,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CallAgg =
                CallAgg(
                    setq = setq,
                    funcName = funcName,
                    arg = arg,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("call_agg"),
                    setq.toIonElement(),
                    funcName.toIonElement(),
                    arg.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                setq: SetQuantifier = this.setq,
                funcName: org.partiql.pig.runtime.SymbolPrimitive = this.funcName,
                arg: Expr = this.arg,
                metas: MetaContainer = this.metas
            ) =
                CallAgg(
                    setq,
                    funcName,
                    arg,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CallAgg::class.java) return false
        
                other as CallAgg
                if (setq != other.setq) return false
                if (funcName != other.funcName) return false
                if (arg != other.arg) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + funcName.hashCode()
                hc = 31 * hc + arg.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Cast(
            val value: Expr,
            val asType: Type,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Cast =
                Cast(
                    value = value,
                    asType = asType,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Cast =
                Cast(
                    value = value,
                    asType = asType,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("cast"),
                    value.toIonElement(),
                    asType.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                asType: Type = this.asType,
                metas: MetaContainer = this.metas
            ) =
                Cast(
                    value,
                    asType,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Cast::class.java) return false
        
                other as Cast
                if (value != other.value) return false
                if (asType != other.asType) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + asType.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CanCast(
            val value: Expr,
            val asType: Type,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): CanCast =
                CanCast(
                    value = value,
                    asType = asType,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CanCast =
                CanCast(
                    value = value,
                    asType = asType,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("can_cast"),
                    value.toIonElement(),
                    asType.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                asType: Type = this.asType,
                metas: MetaContainer = this.metas
            ) =
                CanCast(
                    value,
                    asType,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CanCast::class.java) return false
        
                other as CanCast
                if (value != other.value) return false
                if (asType != other.asType) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + asType.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CanLosslessCast(
            val value: Expr,
            val asType: Type,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): CanLosslessCast =
                CanLosslessCast(
                    value = value,
                    asType = asType,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CanLosslessCast =
                CanLosslessCast(
                    value = value,
                    asType = asType,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("can_lossless_cast"),
                    value.toIonElement(),
                    asType.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                asType: Type = this.asType,
                metas: MetaContainer = this.metas
            ) =
                CanLosslessCast(
                    value,
                    asType,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CanLosslessCast::class.java) return false
        
                other as CanLosslessCast
                if (value != other.value) return false
                if (asType != other.asType) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + asType.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class NullIf(
            val expr1: Expr,
            val expr2: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): NullIf =
                NullIf(
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): NullIf =
                NullIf(
                    expr1 = expr1,
                    expr2 = expr2,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("null_if"),
                    expr1.toIonElement(),
                    expr2.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr1: Expr = this.expr1,
                expr2: Expr = this.expr2,
                metas: MetaContainer = this.metas
            ) =
                NullIf(
                    expr1,
                    expr2,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != NullIf::class.java) return false
        
                other as NullIf
                if (expr1 != other.expr1) return false
                if (expr2 != other.expr2) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr1.hashCode()
                hc = 31 * hc + expr2.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Coalesce(
            val args: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Coalesce =
                Coalesce(
                    args = args,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Coalesce =
                Coalesce(
                    args = args,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("coalesce"),
                    *args.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                args: kotlin.collections.List<Expr> = this.args,
                metas: MetaContainer = this.metas
            ) =
                Coalesce(
                    args,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Coalesce::class.java) return false
        
                other as Coalesce
                if (args != other.args) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = args.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Select(
            val setq: SetQuantifier?,
            val project: Projection,
            val from: FromSource,
            val fromLet: Let?,
            val where: Expr?,
            val group: GroupBy?,
            val having: Expr?,
            val order: OrderBy?,
            val limit: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Expr() {
        
            override fun copy(metas: MetaContainer): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    fromLet = fromLet,
                    where = where,
                    group = group,
                    having = having,
                    order = order,
                    limit = limit,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Select =
                Select(
                    setq = setq,
                    project = project,
                    from = from,
                    fromLet = fromLet,
                    where = where,
                    group = group,
                    having = having,
                    order = order,
                    limit = limit,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("select"),
                    setq?.let { ionSexpOf(ionSymbol("setq"), it.toIonElement()) },
                    project?.let { ionSexpOf(ionSymbol("project"), it.toIonElement()) },
                    from?.let { ionSexpOf(ionSymbol("from"), it.toIonElement()) },
                    fromLet?.let { ionSexpOf(ionSymbol("from_let"), it.toIonElement()) },
                    where?.let { ionSexpOf(ionSymbol("where"), it.toIonElement()) },
                    group?.let { ionSexpOf(ionSymbol("group"), it.toIonElement()) },
                    having?.let { ionSexpOf(ionSymbol("having"), it.toIonElement()) },
                    order?.let { ionSexpOf(ionSymbol("order"), it.toIonElement()) },
                    limit?.let { ionSexpOf(ionSymbol("limit"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                setq: SetQuantifier? = this.setq,
                project: Projection = this.project,
                from: FromSource = this.from,
                fromLet: Let? = this.fromLet,
                where: Expr? = this.where,
                group: GroupBy? = this.group,
                having: Expr? = this.having,
                order: OrderBy? = this.order,
                limit: Expr? = this.limit,
                metas: MetaContainer = this.metas
            ) =
                Select(
                    setq,
                    project,
                    from,
                    fromLet,
                    where,
                    group,
                    having,
                    order,
                    limit,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Select::class.java) return false
        
                other as Select
                if (setq != other.setq) return false
                if (project != other.project) return false
                if (from != other.from) return false
                if (fromLet != other.fromLet) return false
                if (where != other.where) return false
                if (group != other.group) return false
                if (having != other.having) return false
                if (order != other.order) return false
                if (limit != other.limit) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = setq.hashCode()
                hc = 31 * hc + project.hashCode()
                hc = 31 * hc + from.hashCode()
                hc = 31 * hc + fromLet.hashCode()
                hc = 31 * hc + where.hashCode()
                hc = 31 * hc + group.hashCode()
                hc = 31 * hc + having.hashCode()
                hc = 31 * hc + order.hashCode()
                hc = 31 * hc + limit.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.Expr] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.Expr): T = when(node) {
                is PartiqlAst.Expr.Missing -> convertMissing(node)
                is PartiqlAst.Expr.Lit -> convertLit(node)
                is PartiqlAst.Expr.Id -> convertId(node)
                is PartiqlAst.Expr.Parameter -> convertParameter(node)
                is PartiqlAst.Expr.Not -> convertNot(node)
                is PartiqlAst.Expr.Pos -> convertPos(node)
                is PartiqlAst.Expr.Neg -> convertNeg(node)
                is PartiqlAst.Expr.Plus -> convertPlus(node)
                is PartiqlAst.Expr.Minus -> convertMinus(node)
                is PartiqlAst.Expr.Times -> convertTimes(node)
                is PartiqlAst.Expr.Divide -> convertDivide(node)
                is PartiqlAst.Expr.Modulo -> convertModulo(node)
                is PartiqlAst.Expr.Concat -> convertConcat(node)
                is PartiqlAst.Expr.And -> convertAnd(node)
                is PartiqlAst.Expr.Or -> convertOr(node)
                is PartiqlAst.Expr.Eq -> convertEq(node)
                is PartiqlAst.Expr.Ne -> convertNe(node)
                is PartiqlAst.Expr.Gt -> convertGt(node)
                is PartiqlAst.Expr.Gte -> convertGte(node)
                is PartiqlAst.Expr.Lt -> convertLt(node)
                is PartiqlAst.Expr.Lte -> convertLte(node)
                is PartiqlAst.Expr.Like -> convertLike(node)
                is PartiqlAst.Expr.Between -> convertBetween(node)
                is PartiqlAst.Expr.InCollection -> convertInCollection(node)
                is PartiqlAst.Expr.IsType -> convertIsType(node)
                is PartiqlAst.Expr.SimpleCase -> convertSimpleCase(node)
                is PartiqlAst.Expr.SearchedCase -> convertSearchedCase(node)
                is PartiqlAst.Expr.Struct -> convertStruct(node)
                is PartiqlAst.Expr.Bag -> convertBag(node)
                is PartiqlAst.Expr.List -> convertList(node)
                is PartiqlAst.Expr.Sexp -> convertSexp(node)
                is PartiqlAst.Expr.Date -> convertDate(node)
                is PartiqlAst.Expr.LitTime -> convertLitTime(node)
                is PartiqlAst.Expr.Union -> convertUnion(node)
                is PartiqlAst.Expr.Except -> convertExcept(node)
                is PartiqlAst.Expr.Intersect -> convertIntersect(node)
                is PartiqlAst.Expr.Path -> convertPath(node)
                is PartiqlAst.Expr.Call -> convertCall(node)
                is PartiqlAst.Expr.CallAgg -> convertCallAgg(node)
                is PartiqlAst.Expr.Cast -> convertCast(node)
                is PartiqlAst.Expr.CanCast -> convertCanCast(node)
                is PartiqlAst.Expr.CanLosslessCast -> convertCanLosslessCast(node)
                is PartiqlAst.Expr.NullIf -> convertNullIf(node)
                is PartiqlAst.Expr.Coalesce -> convertCoalesce(node)
                is PartiqlAst.Expr.Select -> convertSelect(node)
            }
    
            fun convertMissing(node: PartiqlAst.Expr.Missing): T
            fun convertLit(node: PartiqlAst.Expr.Lit): T
            fun convertId(node: PartiqlAst.Expr.Id): T
            fun convertParameter(node: PartiqlAst.Expr.Parameter): T
            fun convertNot(node: PartiqlAst.Expr.Not): T
            fun convertPos(node: PartiqlAst.Expr.Pos): T
            fun convertNeg(node: PartiqlAst.Expr.Neg): T
            fun convertPlus(node: PartiqlAst.Expr.Plus): T
            fun convertMinus(node: PartiqlAst.Expr.Minus): T
            fun convertTimes(node: PartiqlAst.Expr.Times): T
            fun convertDivide(node: PartiqlAst.Expr.Divide): T
            fun convertModulo(node: PartiqlAst.Expr.Modulo): T
            fun convertConcat(node: PartiqlAst.Expr.Concat): T
            fun convertAnd(node: PartiqlAst.Expr.And): T
            fun convertOr(node: PartiqlAst.Expr.Or): T
            fun convertEq(node: PartiqlAst.Expr.Eq): T
            fun convertNe(node: PartiqlAst.Expr.Ne): T
            fun convertGt(node: PartiqlAst.Expr.Gt): T
            fun convertGte(node: PartiqlAst.Expr.Gte): T
            fun convertLt(node: PartiqlAst.Expr.Lt): T
            fun convertLte(node: PartiqlAst.Expr.Lte): T
            fun convertLike(node: PartiqlAst.Expr.Like): T
            fun convertBetween(node: PartiqlAst.Expr.Between): T
            fun convertInCollection(node: PartiqlAst.Expr.InCollection): T
            fun convertIsType(node: PartiqlAst.Expr.IsType): T
            fun convertSimpleCase(node: PartiqlAst.Expr.SimpleCase): T
            fun convertSearchedCase(node: PartiqlAst.Expr.SearchedCase): T
            fun convertStruct(node: PartiqlAst.Expr.Struct): T
            fun convertBag(node: PartiqlAst.Expr.Bag): T
            fun convertList(node: PartiqlAst.Expr.List): T
            fun convertSexp(node: PartiqlAst.Expr.Sexp): T
            fun convertDate(node: PartiqlAst.Expr.Date): T
            fun convertLitTime(node: PartiqlAst.Expr.LitTime): T
            fun convertUnion(node: PartiqlAst.Expr.Union): T
            fun convertExcept(node: PartiqlAst.Expr.Except): T
            fun convertIntersect(node: PartiqlAst.Expr.Intersect): T
            fun convertPath(node: PartiqlAst.Expr.Path): T
            fun convertCall(node: PartiqlAst.Expr.Call): T
            fun convertCallAgg(node: PartiqlAst.Expr.CallAgg): T
            fun convertCast(node: PartiqlAst.Expr.Cast): T
            fun convertCanCast(node: PartiqlAst.Expr.CanCast): T
            fun convertCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast): T
            fun convertNullIf(node: PartiqlAst.Expr.NullIf): T
            fun convertCoalesce(node: PartiqlAst.Expr.Coalesce): T
            fun convertSelect(node: PartiqlAst.Expr.Select): T
        }
    }
    
    sealed class PathStep(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): PathStep =
            when (this) {
                is PathExpr -> copy(metas = metas)
                is PathWildcard -> copy(metas = metas)
                is PathUnpivot -> copy(metas = metas)
            }
    
        class PathExpr(
            val index: Expr,
            val case: CaseSensitivity,
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathStep() {
        
            override fun copy(metas: MetaContainer): PathExpr =
                PathExpr(
                    index = index,
                    case = case,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathExpr =
                PathExpr(
                    index = index,
                    case = case,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_expr"),
                    index.toIonElement(),
                    case.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                index: Expr = this.index,
                case: CaseSensitivity = this.case,
                metas: MetaContainer = this.metas
            ) =
                PathExpr(
                    index,
                    case,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathExpr::class.java) return false
        
                other as PathExpr
                if (index != other.index) return false
                if (case != other.case) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = index.hashCode()
                hc = 31 * hc + case.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class PathWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathStep() {
        
            override fun copy(metas: MetaContainer): PathWildcard =
                PathWildcard(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathWildcard =
                PathWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_wildcard"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3001
        }
    
        class PathUnpivot(
            override val metas: MetaContainer = emptyMetaContainer()
        ): PathStep() {
        
            override fun copy(metas: MetaContainer): PathUnpivot =
                PathUnpivot(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): PathUnpivot =
                PathUnpivot(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("path_unpivot"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != PathUnpivot::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 3002
        }
    
        /** Converts instances of [PartiqlAst.PathStep] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.PathStep): T = when(node) {
                is PartiqlAst.PathStep.PathExpr -> convertPathExpr(node)
                is PartiqlAst.PathStep.PathWildcard -> convertPathWildcard(node)
                is PartiqlAst.PathStep.PathUnpivot -> convertPathUnpivot(node)
            }
    
            fun convertPathExpr(node: PartiqlAst.PathStep.PathExpr): T
            fun convertPathWildcard(node: PartiqlAst.PathStep.PathWildcard): T
            fun convertPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot): T
        }
    }
    
    sealed class Projection(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): Projection =
            when (this) {
                is ProjectStar -> copy(metas = metas)
                is ProjectList -> copy(metas = metas)
                is ProjectPivot -> copy(metas = metas)
                is ProjectValue -> copy(metas = metas)
            }
    
        class ProjectStar(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectStar =
                ProjectStar(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectStar =
                ProjectStar(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_star"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectStar::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 4000
        }
    
        class ProjectList(
            val projectItems: kotlin.collections.List<ProjectItem>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectList =
                ProjectList(
                    projectItems = projectItems,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectList =
                ProjectList(
                    projectItems = projectItems,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_list"),
                    *projectItems.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                projectItems: kotlin.collections.List<ProjectItem> = this.projectItems,
                metas: MetaContainer = this.metas
            ) =
                ProjectList(
                    projectItems,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectList::class.java) return false
        
                other as ProjectList
                if (projectItems != other.projectItems) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = projectItems.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectPivot(
            val value: Expr,
            val key: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectPivot =
                ProjectPivot(
                    value = value,
                    key = key,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectPivot =
                ProjectPivot(
                    value = value,
                    key = key,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_pivot"),
                    value.toIonElement(),
                    key.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                key: Expr = this.key,
                metas: MetaContainer = this.metas
            ) =
                ProjectPivot(
                    value,
                    key,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectPivot::class.java) return false
        
                other as ProjectPivot
                if (value != other.value) return false
                if (key != other.key) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc = 31 * hc + key.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectValue(
            val value: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Projection() {
        
            override fun copy(metas: MetaContainer): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectValue =
                ProjectValue(
                    value = value,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_value"),
                    value.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                value: Expr = this.value,
                metas: MetaContainer = this.metas
            ) =
                ProjectValue(
                    value,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectValue::class.java) return false
        
                other as ProjectValue
                if (value != other.value) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = value.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.Projection] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.Projection): T = when(node) {
                is PartiqlAst.Projection.ProjectStar -> convertProjectStar(node)
                is PartiqlAst.Projection.ProjectList -> convertProjectList(node)
                is PartiqlAst.Projection.ProjectPivot -> convertProjectPivot(node)
                is PartiqlAst.Projection.ProjectValue -> convertProjectValue(node)
            }
    
            fun convertProjectStar(node: PartiqlAst.Projection.ProjectStar): T
            fun convertProjectList(node: PartiqlAst.Projection.ProjectList): T
            fun convertProjectPivot(node: PartiqlAst.Projection.ProjectPivot): T
            fun convertProjectValue(node: PartiqlAst.Projection.ProjectValue): T
        }
    }
    
    sealed class ProjectItem(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): ProjectItem =
            when (this) {
                is ProjectAll -> copy(metas = metas)
                is ProjectExpr -> copy(metas = metas)
            }
    
        class ProjectAll(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun copy(metas: MetaContainer): ProjectAll =
                ProjectAll(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectAll =
                ProjectAll(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_all"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                ProjectAll(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectAll::class.java) return false
        
                other as ProjectAll
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class ProjectExpr(
            val expr: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ProjectItem() {
        
            override fun copy(metas: MetaContainer): ProjectExpr =
                ProjectExpr(
                    expr = expr,
                    asAlias = asAlias,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ProjectExpr =
                ProjectExpr(
                    expr = expr,
                    asAlias = asAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("project_expr"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
                metas: MetaContainer = this.metas
            ) =
                ProjectExpr(
                    expr,
                    asAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ProjectExpr::class.java) return false
        
                other as ProjectExpr
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.ProjectItem] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.ProjectItem): T = when(node) {
                is PartiqlAst.ProjectItem.ProjectAll -> convertProjectAll(node)
                is PartiqlAst.ProjectItem.ProjectExpr -> convertProjectExpr(node)
            }
    
            fun convertProjectAll(node: PartiqlAst.ProjectItem.ProjectAll): T
            fun convertProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr): T
        }
    }
    
    sealed class FromSource(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): FromSource =
            when (this) {
                is Scan -> copy(metas = metas)
                is Unpivot -> copy(metas = metas)
                is Join -> copy(metas = metas)
            }
    
        class Scan(
            val expr: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val atAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val byAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun copy(metas: MetaContainer): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Scan =
                Scan(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("scan"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
                atAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.atAlias,
                byAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.byAlias,
                metas: MetaContainer = this.metas
            ) =
                Scan(
                    expr,
                    asAlias,
                    atAlias,
                    byAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Scan::class.java) return false
        
                other as Scan
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Unpivot(
            val expr: Expr,
            val asAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val atAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            val byAlias: org.partiql.pig.runtime.SymbolPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun copy(metas: MetaContainer): Unpivot =
                Unpivot(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Unpivot =
                Unpivot(
                    expr = expr,
                    asAlias = asAlias,
                    atAlias = atAlias,
                    byAlias = byAlias,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unpivot"),
                    expr.toIonElement(),
                    asAlias?.toIonElement() ?: ionNull(),
                    atAlias?.toIonElement() ?: ionNull(),
                    byAlias?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                asAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.asAlias,
                atAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.atAlias,
                byAlias: org.partiql.pig.runtime.SymbolPrimitive? = this.byAlias,
                metas: MetaContainer = this.metas
            ) =
                Unpivot(
                    expr,
                    asAlias,
                    atAlias,
                    byAlias,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unpivot::class.java) return false
        
                other as Unpivot
                if (expr != other.expr) return false
                if (asAlias != other.asAlias) return false
                if (atAlias != other.atAlias) return false
                if (byAlias != other.byAlias) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc = 31 * hc + asAlias.hashCode()
                hc = 31 * hc + atAlias.hashCode()
                hc = 31 * hc + byAlias.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Join(
            val type: JoinType,
            val left: FromSource,
            val right: FromSource,
            val predicate: Expr?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): FromSource() {
        
            override fun copy(metas: MetaContainer): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Join =
                Join(
                    type = type,
                    left = left,
                    right = right,
                    predicate = predicate,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("join"),
                    type.toIonElement(),
                    left.toIonElement(),
                    right.toIonElement(),
                    predicate?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                type: JoinType = this.type,
                left: FromSource = this.left,
                right: FromSource = this.right,
                predicate: Expr? = this.predicate,
                metas: MetaContainer = this.metas
            ) =
                Join(
                    type,
                    left,
                    right,
                    predicate,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Join::class.java) return false
        
                other as Join
                if (type != other.type) return false
                if (left != other.left) return false
                if (right != other.right) return false
                if (predicate != other.predicate) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = type.hashCode()
                hc = 31 * hc + left.hashCode()
                hc = 31 * hc + right.hashCode()
                hc = 31 * hc + predicate.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.FromSource] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.FromSource): T = when(node) {
                is PartiqlAst.FromSource.Scan -> convertScan(node)
                is PartiqlAst.FromSource.Unpivot -> convertUnpivot(node)
                is PartiqlAst.FromSource.Join -> convertJoin(node)
            }
    
            fun convertScan(node: PartiqlAst.FromSource.Scan): T
            fun convertUnpivot(node: PartiqlAst.FromSource.Unpivot): T
            fun convertJoin(node: PartiqlAst.FromSource.Join): T
        }
    }
    
    sealed class JoinType(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): JoinType =
            when (this) {
                is Inner -> copy(metas = metas)
                is Left -> copy(metas = metas)
                is Right -> copy(metas = metas)
                is Full -> copy(metas = metas)
            }
    
        class Inner(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Inner =
                Inner(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Inner =
                Inner(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("inner"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Inner::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7000
        }
    
        class Left(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Left =
                Left(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Left =
                Left(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("left"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Left::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7001
        }
    
        class Right(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Right =
                Right(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Right =
                Right(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("right"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Right::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7002
        }
    
        class Full(
            override val metas: MetaContainer = emptyMetaContainer()
        ): JoinType() {
        
            override fun copy(metas: MetaContainer): Full =
                Full(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Full =
                Full(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("full"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Full::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 7003
        }
    
        /** Converts instances of [PartiqlAst.JoinType] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.JoinType): T = when(node) {
                is PartiqlAst.JoinType.Inner -> convertInner(node)
                is PartiqlAst.JoinType.Left -> convertLeft(node)
                is PartiqlAst.JoinType.Right -> convertRight(node)
                is PartiqlAst.JoinType.Full -> convertFull(node)
            }
    
            fun convertInner(node: PartiqlAst.JoinType.Inner): T
            fun convertLeft(node: PartiqlAst.JoinType.Left): T
            fun convertRight(node: PartiqlAst.JoinType.Right): T
            fun convertFull(node: PartiqlAst.JoinType.Full): T
        }
    }
    
    sealed class GroupingStrategy(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): GroupingStrategy =
            when (this) {
                is GroupFull -> copy(metas = metas)
                is GroupPartial -> copy(metas = metas)
            }
    
        class GroupFull(
            override val metas: MetaContainer = emptyMetaContainer()
        ): GroupingStrategy() {
        
            override fun copy(metas: MetaContainer): GroupFull =
                GroupFull(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): GroupFull =
                GroupFull(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("group_full"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != GroupFull::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8000
        }
    
        class GroupPartial(
            override val metas: MetaContainer = emptyMetaContainer()
        ): GroupingStrategy() {
        
            override fun copy(metas: MetaContainer): GroupPartial =
                GroupPartial(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): GroupPartial =
                GroupPartial(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("group_partial"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != GroupPartial::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 8001
        }
    
        /** Converts instances of [PartiqlAst.GroupingStrategy] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.GroupingStrategy): T = when(node) {
                is PartiqlAst.GroupingStrategy.GroupFull -> convertGroupFull(node)
                is PartiqlAst.GroupingStrategy.GroupPartial -> convertGroupPartial(node)
            }
    
            fun convertGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull): T
            fun convertGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial): T
        }
    }
    
    sealed class OrderingSpec(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): OrderingSpec =
            when (this) {
                is Asc -> copy(metas = metas)
                is Desc -> copy(metas = metas)
            }
    
        class Asc(
            override val metas: MetaContainer = emptyMetaContainer()
        ): OrderingSpec() {
        
            override fun copy(metas: MetaContainer): Asc =
                Asc(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Asc =
                Asc(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("asc"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Asc::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 9000
        }
    
        class Desc(
            override val metas: MetaContainer = emptyMetaContainer()
        ): OrderingSpec() {
        
            override fun copy(metas: MetaContainer): Desc =
                Desc(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Desc =
                Desc(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("desc"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Desc::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 9001
        }
    
        /** Converts instances of [PartiqlAst.OrderingSpec] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.OrderingSpec): T = when(node) {
                is PartiqlAst.OrderingSpec.Asc -> convertAsc(node)
                is PartiqlAst.OrderingSpec.Desc -> convertDesc(node)
            }
    
            fun convertAsc(node: PartiqlAst.OrderingSpec.Asc): T
            fun convertDesc(node: PartiqlAst.OrderingSpec.Desc): T
        }
    }
    
    sealed class CaseSensitivity(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): CaseSensitivity =
            when (this) {
                is CaseSensitive -> copy(metas = metas)
                is CaseInsensitive -> copy(metas = metas)
            }
    
        class CaseSensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun copy(metas: MetaContainer): CaseSensitive =
                CaseSensitive(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseSensitive =
                CaseSensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_sensitive"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseSensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 10000
        }
    
        class CaseInsensitive(
            override val metas: MetaContainer = emptyMetaContainer()
        ): CaseSensitivity() {
        
            override fun copy(metas: MetaContainer): CaseInsensitive =
                CaseInsensitive(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CaseInsensitive =
                CaseInsensitive(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("case_insensitive"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CaseInsensitive::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 10001
        }
    
        /** Converts instances of [PartiqlAst.CaseSensitivity] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.CaseSensitivity): T = when(node) {
                is PartiqlAst.CaseSensitivity.CaseSensitive -> convertCaseSensitive(node)
                is PartiqlAst.CaseSensitivity.CaseInsensitive -> convertCaseInsensitive(node)
            }
    
            fun convertCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive): T
            fun convertCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive): T
        }
    }
    
    sealed class ScopeQualifier(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): ScopeQualifier =
            when (this) {
                is Unqualified -> copy(metas = metas)
                is LocalsFirst -> copy(metas = metas)
            }
    
        class Unqualified(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun copy(metas: MetaContainer): Unqualified =
                Unqualified(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Unqualified =
                Unqualified(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("unqualified"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Unqualified::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 11000
        }
    
        class LocalsFirst(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ScopeQualifier() {
        
            override fun copy(metas: MetaContainer): LocalsFirst =
                LocalsFirst(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): LocalsFirst =
                LocalsFirst(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("locals_first"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != LocalsFirst::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 11001
        }
    
        /** Converts instances of [PartiqlAst.ScopeQualifier] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.ScopeQualifier): T = when(node) {
                is PartiqlAst.ScopeQualifier.Unqualified -> convertUnqualified(node)
                is PartiqlAst.ScopeQualifier.LocalsFirst -> convertLocalsFirst(node)
            }
    
            fun convertUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified): T
            fun convertLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst): T
        }
    }
    
    sealed class SetQuantifier(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): SetQuantifier =
            when (this) {
                is All -> copy(metas = metas)
                is Distinct -> copy(metas = metas)
            }
    
        class All(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun copy(metas: MetaContainer): All =
                All(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): All =
                All(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != All::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 12000
        }
    
        class Distinct(
            override val metas: MetaContainer = emptyMetaContainer()
        ): SetQuantifier() {
        
            override fun copy(metas: MetaContainer): Distinct =
                Distinct(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Distinct =
                Distinct(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("distinct"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Distinct::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 12001
        }
    
        /** Converts instances of [PartiqlAst.SetQuantifier] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.SetQuantifier): T = when(node) {
                is PartiqlAst.SetQuantifier.All -> convertAll(node)
                is PartiqlAst.SetQuantifier.Distinct -> convertDistinct(node)
            }
    
            fun convertAll(node: PartiqlAst.SetQuantifier.All): T
            fun convertDistinct(node: PartiqlAst.SetQuantifier.Distinct): T
        }
    }
    
    sealed class DmlOp(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): DmlOp =
            when (this) {
                is Insert -> copy(metas = metas)
                is InsertValue -> copy(metas = metas)
                is Set -> copy(metas = metas)
                is Remove -> copy(metas = metas)
                is Delete -> copy(metas = metas)
            }
    
        class Insert(
            val target: Expr,
            val values: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DmlOp() {
        
            override fun copy(metas: MetaContainer): Insert =
                Insert(
                    target = target,
                    values = values,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Insert =
                Insert(
                    target = target,
                    values = values,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("insert"),
                    target.toIonElement(),
                    values.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                target: Expr = this.target,
                values: Expr = this.values,
                metas: MetaContainer = this.metas
            ) =
                Insert(
                    target,
                    values,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Insert::class.java) return false
        
                other as Insert
                if (target != other.target) return false
                if (values != other.values) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = target.hashCode()
                hc = 31 * hc + values.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class InsertValue(
            val target: Expr,
            val value: Expr,
            val index: Expr?,
            val onConflict: OnConflict?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DmlOp() {
        
            override fun copy(metas: MetaContainer): InsertValue =
                InsertValue(
                    target = target,
                    value = value,
                    index = index,
                    onConflict = onConflict,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): InsertValue =
                InsertValue(
                    target = target,
                    value = value,
                    index = index,
                    onConflict = onConflict,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("insert_value"),
                    target.toIonElement(),
                    value.toIonElement(),
                    index?.toIonElement() ?: ionNull(),
                    onConflict?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                target: Expr = this.target,
                value: Expr = this.value,
                index: Expr? = this.index,
                onConflict: OnConflict? = this.onConflict,
                metas: MetaContainer = this.metas
            ) =
                InsertValue(
                    target,
                    value,
                    index,
                    onConflict,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != InsertValue::class.java) return false
        
                other as InsertValue
                if (target != other.target) return false
                if (value != other.value) return false
                if (index != other.index) return false
                if (onConflict != other.onConflict) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = target.hashCode()
                hc = 31 * hc + value.hashCode()
                hc = 31 * hc + index.hashCode()
                hc = 31 * hc + onConflict.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Set(
            val assignment: Assignment,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DmlOp() {
        
            override fun copy(metas: MetaContainer): Set =
                Set(
                    assignment = assignment,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Set =
                Set(
                    assignment = assignment,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("set"),
                    assignment.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                assignment: Assignment = this.assignment,
                metas: MetaContainer = this.metas
            ) =
                Set(
                    assignment,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Set::class.java) return false
        
                other as Set
                if (assignment != other.assignment) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = assignment.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Remove(
            val target: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DmlOp() {
        
            override fun copy(metas: MetaContainer): Remove =
                Remove(
                    target = target,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Remove =
                Remove(
                    target = target,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("remove"),
                    target.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                target: Expr = this.target,
                metas: MetaContainer = this.metas
            ) =
                Remove(
                    target,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Remove::class.java) return false
        
                other as Remove
                if (target != other.target) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = target.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class Delete(
            override val metas: MetaContainer = emptyMetaContainer()
        ): DmlOp() {
        
            override fun copy(metas: MetaContainer): Delete =
                Delete(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Delete =
                Delete(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("delete"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Delete::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 13004
        }
    
        /** Converts instances of [PartiqlAst.DmlOp] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.DmlOp): T = when(node) {
                is PartiqlAst.DmlOp.Insert -> convertInsert(node)
                is PartiqlAst.DmlOp.InsertValue -> convertInsertValue(node)
                is PartiqlAst.DmlOp.Set -> convertSet(node)
                is PartiqlAst.DmlOp.Remove -> convertRemove(node)
                is PartiqlAst.DmlOp.Delete -> convertDelete(node)
            }
    
            fun convertInsert(node: PartiqlAst.DmlOp.Insert): T
            fun convertInsertValue(node: PartiqlAst.DmlOp.InsertValue): T
            fun convertSet(node: PartiqlAst.DmlOp.Set): T
            fun convertRemove(node: PartiqlAst.DmlOp.Remove): T
            fun convertDelete(node: PartiqlAst.DmlOp.Delete): T
        }
    }
    
    sealed class ConflictAction(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): ConflictAction =
            when (this) {
                is DoNothing -> copy(metas = metas)
            }
    
        class DoNothing(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ConflictAction() {
        
            override fun copy(metas: MetaContainer): DoNothing =
                DoNothing(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DoNothing =
                DoNothing(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("do_nothing"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DoNothing::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 14000
        }
    
        /** Converts instances of [PartiqlAst.ConflictAction] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.ConflictAction): T = when(node) {
                is PartiqlAst.ConflictAction.DoNothing -> convertDoNothing(node)
            }
    
            fun convertDoNothing(node: PartiqlAst.ConflictAction.DoNothing): T
        }
    }
    
    sealed class DdlOp(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): DdlOp =
            when (this) {
                is CreateTable -> copy(metas = metas)
                is DropTable -> copy(metas = metas)
                is UndropTable -> copy(metas = metas)
                is CreateIndex -> copy(metas = metas)
                is DropIndex -> copy(metas = metas)
            }
    
        class CreateTable(
            val tableName: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DdlOp() {
        
            override fun copy(metas: MetaContainer): CreateTable =
                CreateTable(
                    tableName = tableName,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CreateTable =
                CreateTable(
                    tableName = tableName,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("create_table"),
                    tableName.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                tableName: org.partiql.pig.runtime.SymbolPrimitive = this.tableName,
                metas: MetaContainer = this.metas
            ) =
                CreateTable(
                    tableName,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CreateTable::class.java) return false
        
                other as CreateTable
                if (tableName != other.tableName) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = tableName.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class DropTable(
            val tableName: Identifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DdlOp() {
        
            override fun copy(metas: MetaContainer): DropTable =
                DropTable(
                    tableName = tableName,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DropTable =
                DropTable(
                    tableName = tableName,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("drop_table"),
                    tableName.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                tableName: Identifier = this.tableName,
                metas: MetaContainer = this.metas
            ) =
                DropTable(
                    tableName,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DropTable::class.java) return false
        
                other as DropTable
                if (tableName != other.tableName) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = tableName.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class UndropTable(
            val tableName: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DdlOp() {
        
            override fun copy(metas: MetaContainer): UndropTable =
                UndropTable(
                    tableName = tableName,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): UndropTable =
                UndropTable(
                    tableName = tableName,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("undrop_table"),
                    tableName.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                tableName: org.partiql.pig.runtime.SymbolPrimitive = this.tableName,
                metas: MetaContainer = this.metas
            ) =
                UndropTable(
                    tableName,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != UndropTable::class.java) return false
        
                other as UndropTable
                if (tableName != other.tableName) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = tableName.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CreateIndex(
            val indexName: Identifier,
            val fields: kotlin.collections.List<Expr>,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DdlOp() {
        
            override fun copy(metas: MetaContainer): CreateIndex =
                CreateIndex(
                    indexName = indexName,
                    fields = fields,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CreateIndex =
                CreateIndex(
                    indexName = indexName,
                    fields = fields,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("create_index"),
                    indexName.toIonElement(),
                    *fields.map { it.toIonElement() }.toTypedArray(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                indexName: Identifier = this.indexName,
                fields: kotlin.collections.List<Expr> = this.fields,
                metas: MetaContainer = this.metas
            ) =
                CreateIndex(
                    indexName,
                    fields,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CreateIndex::class.java) return false
        
                other as CreateIndex
                if (indexName != other.indexName) return false
                if (fields != other.fields) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = indexName.hashCode()
                hc = 31 * hc + fields.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class DropIndex(
            val table: Identifier,
            val keys: Identifier,
            override val metas: MetaContainer = emptyMetaContainer()
        ): DdlOp() {
        
            override fun copy(metas: MetaContainer): DropIndex =
                DropIndex(
                    table = table,
                    keys = keys,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DropIndex =
                DropIndex(
                    table = table,
                    keys = keys,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = listOfNotNull(
                    ionSymbol("drop_index"),
                    table?.let { ionSexpOf(ionSymbol("table"), it.toIonElement()) },
                    keys?.let { ionSexpOf(ionSymbol("keys"), it.toIonElement()) }
                )
        
                return ionSexpOf(elements, metas = metas)
            }
        
            fun copy(
                table: Identifier = this.table,
                keys: Identifier = this.keys,
                metas: MetaContainer = this.metas
            ) =
                DropIndex(
                    table,
                    keys,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DropIndex::class.java) return false
        
                other as DropIndex
                if (table != other.table) return false
                if (keys != other.keys) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = table.hashCode()
                hc = 31 * hc + keys.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.DdlOp] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.DdlOp): T = when(node) {
                is PartiqlAst.DdlOp.CreateTable -> convertCreateTable(node)
                is PartiqlAst.DdlOp.DropTable -> convertDropTable(node)
                is PartiqlAst.DdlOp.UndropTable -> convertUndropTable(node)
                is PartiqlAst.DdlOp.CreateIndex -> convertCreateIndex(node)
                is PartiqlAst.DdlOp.DropIndex -> convertDropIndex(node)
            }
    
            fun convertCreateTable(node: PartiqlAst.DdlOp.CreateTable): T
            fun convertDropTable(node: PartiqlAst.DdlOp.DropTable): T
            fun convertUndropTable(node: PartiqlAst.DdlOp.UndropTable): T
            fun convertCreateIndex(node: PartiqlAst.DdlOp.CreateIndex): T
            fun convertDropIndex(node: PartiqlAst.DdlOp.DropIndex): T
        }
    }
    
    sealed class ColumnComponent(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): ColumnComponent =
            when (this) {
                is ReturningWildcard -> copy(metas = metas)
                is ReturningColumn -> copy(metas = metas)
            }
    
        class ReturningWildcard(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ColumnComponent() {
        
            override fun copy(metas: MetaContainer): ReturningWildcard =
                ReturningWildcard(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ReturningWildcard =
                ReturningWildcard(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("returning_wildcard"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ReturningWildcard::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 16000
        }
    
        class ReturningColumn(
            val expr: Expr,
            override val metas: MetaContainer = emptyMetaContainer()
        ): ColumnComponent() {
        
            override fun copy(metas: MetaContainer): ReturningColumn =
                ReturningColumn(
                    expr = expr,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ReturningColumn =
                ReturningColumn(
                    expr = expr,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("returning_column"),
                    expr.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                expr: Expr = this.expr,
                metas: MetaContainer = this.metas
            ) =
                ReturningColumn(
                    expr,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ReturningColumn::class.java) return false
        
                other as ReturningColumn
                if (expr != other.expr) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = expr.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.ColumnComponent] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.ColumnComponent): T = when(node) {
                is PartiqlAst.ColumnComponent.ReturningWildcard -> convertReturningWildcard(node)
                is PartiqlAst.ColumnComponent.ReturningColumn -> convertReturningColumn(node)
            }
    
            fun convertReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard): T
            fun convertReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn): T
        }
    }
    
    sealed class ReturningMapping(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): ReturningMapping =
            when (this) {
                is ModifiedNew -> copy(metas = metas)
                is ModifiedOld -> copy(metas = metas)
                is AllNew -> copy(metas = metas)
                is AllOld -> copy(metas = metas)
            }
    
        class ModifiedNew(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ReturningMapping() {
        
            override fun copy(metas: MetaContainer): ModifiedNew =
                ModifiedNew(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ModifiedNew =
                ModifiedNew(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modified_new"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ModifiedNew::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 17000
        }
    
        class ModifiedOld(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ReturningMapping() {
        
            override fun copy(metas: MetaContainer): ModifiedOld =
                ModifiedOld(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ModifiedOld =
                ModifiedOld(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("modified_old"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ModifiedOld::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 17001
        }
    
        class AllNew(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ReturningMapping() {
        
            override fun copy(metas: MetaContainer): AllNew =
                AllNew(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): AllNew =
                AllNew(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all_new"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != AllNew::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 17002
        }
    
        class AllOld(
            override val metas: MetaContainer = emptyMetaContainer()
        ): ReturningMapping() {
        
            override fun copy(metas: MetaContainer): AllOld =
                AllOld(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): AllOld =
                AllOld(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("all_old"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != AllOld::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 17003
        }
    
        /** Converts instances of [PartiqlAst.ReturningMapping] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.ReturningMapping): T = when(node) {
                is PartiqlAst.ReturningMapping.ModifiedNew -> convertModifiedNew(node)
                is PartiqlAst.ReturningMapping.ModifiedOld -> convertModifiedOld(node)
                is PartiqlAst.ReturningMapping.AllNew -> convertAllNew(node)
                is PartiqlAst.ReturningMapping.AllOld -> convertAllOld(node)
            }
    
            fun convertModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew): T
            fun convertModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld): T
            fun convertAllNew(node: PartiqlAst.ReturningMapping.AllNew): T
            fun convertAllOld(node: PartiqlAst.ReturningMapping.AllOld): T
        }
    }
    
    sealed class Type(override val metas: MetaContainer = emptyMetaContainer()) : PartiqlAstNode() {
        override fun copy(metas: MetaContainer): Type =
            when (this) {
                is NullType -> copy(metas = metas)
                is BooleanType -> copy(metas = metas)
                is SmallintType -> copy(metas = metas)
                is Integer4Type -> copy(metas = metas)
                is Integer8Type -> copy(metas = metas)
                is IntegerType -> copy(metas = metas)
                is FloatType -> copy(metas = metas)
                is RealType -> copy(metas = metas)
                is DoublePrecisionType -> copy(metas = metas)
                is DecimalType -> copy(metas = metas)
                is NumericType -> copy(metas = metas)
                is TimestampType -> copy(metas = metas)
                is CharacterType -> copy(metas = metas)
                is CharacterVaryingType -> copy(metas = metas)
                is MissingType -> copy(metas = metas)
                is StringType -> copy(metas = metas)
                is SymbolType -> copy(metas = metas)
                is BlobType -> copy(metas = metas)
                is ClobType -> copy(metas = metas)
                is DateType -> copy(metas = metas)
                is TimeType -> copy(metas = metas)
                is TimeWithTimeZoneType -> copy(metas = metas)
                is StructType -> copy(metas = metas)
                is TupleType -> copy(metas = metas)
                is ListType -> copy(metas = metas)
                is SexpType -> copy(metas = metas)
                is BagType -> copy(metas = metas)
                is AnyType -> copy(metas = metas)
                is EsBoolean -> copy(metas = metas)
                is EsInteger -> copy(metas = metas)
                is EsFloat -> copy(metas = metas)
                is EsText -> copy(metas = metas)
                is EsAny -> copy(metas = metas)
                is SparkShort -> copy(metas = metas)
                is SparkInteger -> copy(metas = metas)
                is SparkLong -> copy(metas = metas)
                is SparkDouble -> copy(metas = metas)
                is SparkBoolean -> copy(metas = metas)
                is SparkFloat -> copy(metas = metas)
                is RsVarcharMax -> copy(metas = metas)
                is RsInteger -> copy(metas = metas)
                is RsBigint -> copy(metas = metas)
                is RsBoolean -> copy(metas = metas)
                is RsReal -> copy(metas = metas)
                is RsDoublePrecision -> copy(metas = metas)
                is CustomType -> copy(metas = metas)
            }
    
        class NullType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): NullType =
                NullType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): NullType =
                NullType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("null_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != NullType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18000
        }
    
        class BooleanType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): BooleanType =
                BooleanType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): BooleanType =
                BooleanType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("boolean_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != BooleanType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18001
        }
    
        class SmallintType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SmallintType =
                SmallintType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SmallintType =
                SmallintType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("smallint_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SmallintType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18002
        }
    
        class Integer4Type(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): Integer4Type =
                Integer4Type(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Integer4Type =
                Integer4Type(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("integer4_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Integer4Type::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18003
        }
    
        class Integer8Type(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): Integer8Type =
                Integer8Type(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): Integer8Type =
                Integer8Type(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("integer8_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != Integer8Type::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18004
        }
    
        class IntegerType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): IntegerType =
                IntegerType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): IntegerType =
                IntegerType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("integer_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != IntegerType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18005
        }
    
        class FloatType(
            val precision: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): FloatType =
                FloatType(
                    precision = precision,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): FloatType =
                FloatType(
                    precision = precision,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("float_type"),
                    precision?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                precision: org.partiql.pig.runtime.LongPrimitive? = this.precision,
                metas: MetaContainer = this.metas
            ) =
                FloatType(
                    precision,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != FloatType::class.java) return false
        
                other as FloatType
                if (precision != other.precision) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = precision.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class RealType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RealType =
                RealType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RealType =
                RealType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("real_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RealType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18007
        }
    
        class DoublePrecisionType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): DoublePrecisionType =
                DoublePrecisionType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DoublePrecisionType =
                DoublePrecisionType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("double_precision_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DoublePrecisionType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18008
        }
    
        class DecimalType(
            val precision: org.partiql.pig.runtime.LongPrimitive?,
            val scale: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): DecimalType =
                DecimalType(
                    precision = precision,
                    scale = scale,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DecimalType =
                DecimalType(
                    precision = precision,
                    scale = scale,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("decimal_type"),
                    precision?.toIonElement() ?: ionNull(),
                    scale?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                precision: org.partiql.pig.runtime.LongPrimitive? = this.precision,
                scale: org.partiql.pig.runtime.LongPrimitive? = this.scale,
                metas: MetaContainer = this.metas
            ) =
                DecimalType(
                    precision,
                    scale,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DecimalType::class.java) return false
        
                other as DecimalType
                if (precision != other.precision) return false
                if (scale != other.scale) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = precision.hashCode()
                hc = 31 * hc + scale.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class NumericType(
            val precision: org.partiql.pig.runtime.LongPrimitive?,
            val scale: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): NumericType =
                NumericType(
                    precision = precision,
                    scale = scale,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): NumericType =
                NumericType(
                    precision = precision,
                    scale = scale,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("numeric_type"),
                    precision?.toIonElement() ?: ionNull(),
                    scale?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                precision: org.partiql.pig.runtime.LongPrimitive? = this.precision,
                scale: org.partiql.pig.runtime.LongPrimitive? = this.scale,
                metas: MetaContainer = this.metas
            ) =
                NumericType(
                    precision,
                    scale,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != NumericType::class.java) return false
        
                other as NumericType
                if (precision != other.precision) return false
                if (scale != other.scale) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = precision.hashCode()
                hc = 31 * hc + scale.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class TimestampType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): TimestampType =
                TimestampType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): TimestampType =
                TimestampType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("timestamp_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != TimestampType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18011
        }
    
        class CharacterType(
            val length: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): CharacterType =
                CharacterType(
                    length = length,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CharacterType =
                CharacterType(
                    length = length,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("character_type"),
                    length?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                length: org.partiql.pig.runtime.LongPrimitive? = this.length,
                metas: MetaContainer = this.metas
            ) =
                CharacterType(
                    length,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CharacterType::class.java) return false
        
                other as CharacterType
                if (length != other.length) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = length.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class CharacterVaryingType(
            val length: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): CharacterVaryingType =
                CharacterVaryingType(
                    length = length,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CharacterVaryingType =
                CharacterVaryingType(
                    length = length,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("character_varying_type"),
                    length?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                length: org.partiql.pig.runtime.LongPrimitive? = this.length,
                metas: MetaContainer = this.metas
            ) =
                CharacterVaryingType(
                    length,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CharacterVaryingType::class.java) return false
        
                other as CharacterVaryingType
                if (length != other.length) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = length.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class MissingType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): MissingType =
                MissingType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): MissingType =
                MissingType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("missing_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != MissingType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18014
        }
    
        class StringType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): StringType =
                StringType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): StringType =
                StringType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("string_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != StringType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18015
        }
    
        class SymbolType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SymbolType =
                SymbolType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SymbolType =
                SymbolType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("symbol_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SymbolType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18016
        }
    
        class BlobType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): BlobType =
                BlobType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): BlobType =
                BlobType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("blob_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != BlobType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18017
        }
    
        class ClobType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): ClobType =
                ClobType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ClobType =
                ClobType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("clob_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ClobType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18018
        }
    
        class DateType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): DateType =
                DateType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): DateType =
                DateType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("date_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != DateType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18019
        }
    
        class TimeType(
            val precision: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): TimeType =
                TimeType(
                    precision = precision,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): TimeType =
                TimeType(
                    precision = precision,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("time_type"),
                    precision?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                precision: org.partiql.pig.runtime.LongPrimitive? = this.precision,
                metas: MetaContainer = this.metas
            ) =
                TimeType(
                    precision,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != TimeType::class.java) return false
        
                other as TimeType
                if (precision != other.precision) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = precision.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class TimeWithTimeZoneType(
            val precision: org.partiql.pig.runtime.LongPrimitive?,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): TimeWithTimeZoneType =
                TimeWithTimeZoneType(
                    precision = precision,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): TimeWithTimeZoneType =
                TimeWithTimeZoneType(
                    precision = precision,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("time_with_time_zone_type"),
                    precision?.toIonElement() ?: ionNull(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                precision: org.partiql.pig.runtime.LongPrimitive? = this.precision,
                metas: MetaContainer = this.metas
            ) =
                TimeWithTimeZoneType(
                    precision,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != TimeWithTimeZoneType::class.java) return false
        
                other as TimeWithTimeZoneType
                if (precision != other.precision) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = precision.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        class StructType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): StructType =
                StructType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): StructType =
                StructType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("struct_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != StructType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18022
        }
    
        class TupleType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): TupleType =
                TupleType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): TupleType =
                TupleType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("tuple_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != TupleType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18023
        }
    
        class ListType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): ListType =
                ListType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): ListType =
                ListType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("list_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != ListType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18024
        }
    
        class SexpType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SexpType =
                SexpType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SexpType =
                SexpType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("sexp_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SexpType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18025
        }
    
        class BagType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): BagType =
                BagType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): BagType =
                BagType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("bag_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != BagType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18026
        }
    
        class AnyType(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): AnyType =
                AnyType(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): AnyType =
                AnyType(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("any_type"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != AnyType::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18027
        }
    
        class EsBoolean(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): EsBoolean =
                EsBoolean(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): EsBoolean =
                EsBoolean(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("es_boolean"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != EsBoolean::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18028
        }
    
        class EsInteger(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): EsInteger =
                EsInteger(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): EsInteger =
                EsInteger(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("es_integer"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != EsInteger::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18029
        }
    
        class EsFloat(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): EsFloat =
                EsFloat(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): EsFloat =
                EsFloat(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("es_float"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != EsFloat::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18030
        }
    
        class EsText(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): EsText =
                EsText(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): EsText =
                EsText(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("es_text"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != EsText::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18031
        }
    
        class EsAny(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): EsAny =
                EsAny(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): EsAny =
                EsAny(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("es_any"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != EsAny::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18032
        }
    
        class SparkShort(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkShort =
                SparkShort(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkShort =
                SparkShort(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_short"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkShort::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18033
        }
    
        class SparkInteger(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkInteger =
                SparkInteger(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkInteger =
                SparkInteger(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_integer"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkInteger::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18034
        }
    
        class SparkLong(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkLong =
                SparkLong(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkLong =
                SparkLong(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_long"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkLong::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18035
        }
    
        class SparkDouble(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkDouble =
                SparkDouble(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkDouble =
                SparkDouble(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_double"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkDouble::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18036
        }
    
        class SparkBoolean(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkBoolean =
                SparkBoolean(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkBoolean =
                SparkBoolean(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_boolean"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkBoolean::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18037
        }
    
        class SparkFloat(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): SparkFloat =
                SparkFloat(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): SparkFloat =
                SparkFloat(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("spark_float"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != SparkFloat::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18038
        }
    
        class RsVarcharMax(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsVarcharMax =
                RsVarcharMax(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsVarcharMax =
                RsVarcharMax(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_varchar_max"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsVarcharMax::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18039
        }
    
        class RsInteger(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsInteger =
                RsInteger(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsInteger =
                RsInteger(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_integer"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsInteger::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18040
        }
    
        class RsBigint(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsBigint =
                RsBigint(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsBigint =
                RsBigint(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_bigint"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsBigint::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18041
        }
    
        class RsBoolean(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsBoolean =
                RsBoolean(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsBoolean =
                RsBoolean(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_boolean"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsBoolean::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18042
        }
    
        class RsReal(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsReal =
                RsReal(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsReal =
                RsReal(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_real"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsReal::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18043
        }
    
        class RsDoublePrecision(
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): RsDoublePrecision =
                RsDoublePrecision(
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): RsDoublePrecision =
                RsDoublePrecision(
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("rs_double_precision"),
                    metas = metas)
                return elements
            }
        
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != RsDoublePrecision::class.java) return false
        
                return true
            }
        
            override fun hashCode(): Int = 18044
        }
    
        class CustomType(
            val name: org.partiql.pig.runtime.SymbolPrimitive,
            override val metas: MetaContainer = emptyMetaContainer()
        ): Type() {
        
            override fun copy(metas: MetaContainer): CustomType =
                CustomType(
                    name = name,
                    metas = metas)
        
            override fun withMeta(metaKey: String, metaValue: Any): CustomType =
                CustomType(
                    name = name,
                    metas = metas + metaContainerOf(metaKey to metaValue))
        
            override fun toIonElement(): SexpElement {
                val elements = ionSexpOf(
                    ionSymbol("custom_type"),
                    name.toIonElement(),
                    metas = metas)
                return elements
            }
        
            fun copy(
                name: org.partiql.pig.runtime.SymbolPrimitive = this.name,
                metas: MetaContainer = this.metas
            ) =
                CustomType(
                    name,
                    metas)
        
            override fun equals(other: Any?): Boolean {
                if (other == null) return false
                if (this === other) return true
                if (other.javaClass != CustomType::class.java) return false
        
                other as CustomType
                if (name != other.name) return false
                return true
            }
        
            private val myHashCode by lazy(LazyThreadSafetyMode.PUBLICATION) {
                var hc = name.hashCode()
                hc
            }
        
            override fun hashCode(): Int = myHashCode
        }
    
        /** Converts instances of [PartiqlAst.Type] to any [T]. */
        interface Converter<T> {
            fun convert(node: PartiqlAst.Type): T = when(node) {
                is PartiqlAst.Type.NullType -> convertNullType(node)
                is PartiqlAst.Type.BooleanType -> convertBooleanType(node)
                is PartiqlAst.Type.SmallintType -> convertSmallintType(node)
                is PartiqlAst.Type.Integer4Type -> convertInteger4Type(node)
                is PartiqlAst.Type.Integer8Type -> convertInteger8Type(node)
                is PartiqlAst.Type.IntegerType -> convertIntegerType(node)
                is PartiqlAst.Type.FloatType -> convertFloatType(node)
                is PartiqlAst.Type.RealType -> convertRealType(node)
                is PartiqlAst.Type.DoublePrecisionType -> convertDoublePrecisionType(node)
                is PartiqlAst.Type.DecimalType -> convertDecimalType(node)
                is PartiqlAst.Type.NumericType -> convertNumericType(node)
                is PartiqlAst.Type.TimestampType -> convertTimestampType(node)
                is PartiqlAst.Type.CharacterType -> convertCharacterType(node)
                is PartiqlAst.Type.CharacterVaryingType -> convertCharacterVaryingType(node)
                is PartiqlAst.Type.MissingType -> convertMissingType(node)
                is PartiqlAst.Type.StringType -> convertStringType(node)
                is PartiqlAst.Type.SymbolType -> convertSymbolType(node)
                is PartiqlAst.Type.BlobType -> convertBlobType(node)
                is PartiqlAst.Type.ClobType -> convertClobType(node)
                is PartiqlAst.Type.DateType -> convertDateType(node)
                is PartiqlAst.Type.TimeType -> convertTimeType(node)
                is PartiqlAst.Type.TimeWithTimeZoneType -> convertTimeWithTimeZoneType(node)
                is PartiqlAst.Type.StructType -> convertStructType(node)
                is PartiqlAst.Type.TupleType -> convertTupleType(node)
                is PartiqlAst.Type.ListType -> convertListType(node)
                is PartiqlAst.Type.SexpType -> convertSexpType(node)
                is PartiqlAst.Type.BagType -> convertBagType(node)
                is PartiqlAst.Type.AnyType -> convertAnyType(node)
                is PartiqlAst.Type.EsBoolean -> convertEsBoolean(node)
                is PartiqlAst.Type.EsInteger -> convertEsInteger(node)
                is PartiqlAst.Type.EsFloat -> convertEsFloat(node)
                is PartiqlAst.Type.EsText -> convertEsText(node)
                is PartiqlAst.Type.EsAny -> convertEsAny(node)
                is PartiqlAst.Type.SparkShort -> convertSparkShort(node)
                is PartiqlAst.Type.SparkInteger -> convertSparkInteger(node)
                is PartiqlAst.Type.SparkLong -> convertSparkLong(node)
                is PartiqlAst.Type.SparkDouble -> convertSparkDouble(node)
                is PartiqlAst.Type.SparkBoolean -> convertSparkBoolean(node)
                is PartiqlAst.Type.SparkFloat -> convertSparkFloat(node)
                is PartiqlAst.Type.RsVarcharMax -> convertRsVarcharMax(node)
                is PartiqlAst.Type.RsInteger -> convertRsInteger(node)
                is PartiqlAst.Type.RsBigint -> convertRsBigint(node)
                is PartiqlAst.Type.RsBoolean -> convertRsBoolean(node)
                is PartiqlAst.Type.RsReal -> convertRsReal(node)
                is PartiqlAst.Type.RsDoublePrecision -> convertRsDoublePrecision(node)
                is PartiqlAst.Type.CustomType -> convertCustomType(node)
            }
    
            fun convertNullType(node: PartiqlAst.Type.NullType): T
            fun convertBooleanType(node: PartiqlAst.Type.BooleanType): T
            fun convertSmallintType(node: PartiqlAst.Type.SmallintType): T
            fun convertInteger4Type(node: PartiqlAst.Type.Integer4Type): T
            fun convertInteger8Type(node: PartiqlAst.Type.Integer8Type): T
            fun convertIntegerType(node: PartiqlAst.Type.IntegerType): T
            fun convertFloatType(node: PartiqlAst.Type.FloatType): T
            fun convertRealType(node: PartiqlAst.Type.RealType): T
            fun convertDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType): T
            fun convertDecimalType(node: PartiqlAst.Type.DecimalType): T
            fun convertNumericType(node: PartiqlAst.Type.NumericType): T
            fun convertTimestampType(node: PartiqlAst.Type.TimestampType): T
            fun convertCharacterType(node: PartiqlAst.Type.CharacterType): T
            fun convertCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType): T
            fun convertMissingType(node: PartiqlAst.Type.MissingType): T
            fun convertStringType(node: PartiqlAst.Type.StringType): T
            fun convertSymbolType(node: PartiqlAst.Type.SymbolType): T
            fun convertBlobType(node: PartiqlAst.Type.BlobType): T
            fun convertClobType(node: PartiqlAst.Type.ClobType): T
            fun convertDateType(node: PartiqlAst.Type.DateType): T
            fun convertTimeType(node: PartiqlAst.Type.TimeType): T
            fun convertTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType): T
            fun convertStructType(node: PartiqlAst.Type.StructType): T
            fun convertTupleType(node: PartiqlAst.Type.TupleType): T
            fun convertListType(node: PartiqlAst.Type.ListType): T
            fun convertSexpType(node: PartiqlAst.Type.SexpType): T
            fun convertBagType(node: PartiqlAst.Type.BagType): T
            fun convertAnyType(node: PartiqlAst.Type.AnyType): T
            fun convertEsBoolean(node: PartiqlAst.Type.EsBoolean): T
            fun convertEsInteger(node: PartiqlAst.Type.EsInteger): T
            fun convertEsFloat(node: PartiqlAst.Type.EsFloat): T
            fun convertEsText(node: PartiqlAst.Type.EsText): T
            fun convertEsAny(node: PartiqlAst.Type.EsAny): T
            fun convertSparkShort(node: PartiqlAst.Type.SparkShort): T
            fun convertSparkInteger(node: PartiqlAst.Type.SparkInteger): T
            fun convertSparkLong(node: PartiqlAst.Type.SparkLong): T
            fun convertSparkDouble(node: PartiqlAst.Type.SparkDouble): T
            fun convertSparkBoolean(node: PartiqlAst.Type.SparkBoolean): T
            fun convertSparkFloat(node: PartiqlAst.Type.SparkFloat): T
            fun convertRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax): T
            fun convertRsInteger(node: PartiqlAst.Type.RsInteger): T
            fun convertRsBigint(node: PartiqlAst.Type.RsBigint): T
            fun convertRsBoolean(node: PartiqlAst.Type.RsBoolean): T
            fun convertRsReal(node: PartiqlAst.Type.RsReal): T
            fun convertRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision): T
            fun convertCustomType(node: PartiqlAst.Type.CustomType): T
        }
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IonElementTransformer
    /////////////////////////////////////////////////////////////////////////////
    
    
    private class IonElementTransformer : IonElementTransformerBase<PartiqlAstNode>() {
    
        override fun innerTransform(sexp: SexpElement): PartiqlAstNode {
            return when(sexp.tag) {
                //////////////////////////////////////
                // Tuple Types
                //////////////////////////////////////
                "time_value" -> {
                    sexp.requireArityOrMalformed(IntRange(5, 6))
                    val hour = sexp.getRequired(0).toLongPrimitive()
                    val minute = sexp.getRequired(1).toLongPrimitive()
                    val second = sexp.getRequired(2).toLongPrimitive()
                    val nano = sexp.getRequired(3).toLongPrimitive()
                    val precision = sexp.getRequired(4).toLongPrimitive()
                    val tzMinutes = sexp.getOptional(5)?.toLongPrimitive()
                    PartiqlAst.TimeValue(
                        hour,
                        minute,
                        second,
                        nano,
                        precision,
                        tzMinutes,
                        metas = sexp.metas)
                }
                "let" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val letBindings = sexp.values.drop(1).map { it.transformExpect<LetBinding>() }
                    PartiqlAst.Let(
                        letBindings,
                        metas = sexp.metas)
                }
                "let_binding" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val name = sexp.getRequired(1).toSymbolPrimitive()
                    PartiqlAst.LetBinding(
                        expr,
                        name,
                        metas = sexp.metas)
                }
                "expr_pair" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val first = sexp.getRequired(0).transformExpect<Expr>()
                    val second = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlAst.ExprPair(
                        first,
                        second,
                        metas = sexp.metas)
                }
                "expr_pair_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val pairs = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlAst.ExprPairList(
                        pairs,
                        metas = sexp.metas)
                }
                "group_by" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val strategy = sexp.getRequired(0).transformExpect<GroupingStrategy>()
                    val keyList = sexp.getRequired(1).transformExpect<GroupKeyList>()
                    val groupAsAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    PartiqlAst.GroupBy(
                        strategy,
                        keyList,
                        groupAsAlias,
                        metas = sexp.metas)
                }
                "group_key_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val keys = sexp.values.drop(1).map { it.transformExpect<GroupKey>() }
                    PartiqlAst.GroupKeyList(
                        keys,
                        metas = sexp.metas)
                }
                "group_key" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlAst.GroupKey(
                        expr,
                        asAlias,
                        metas = sexp.metas)
                }
                "order_by" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val sortSpecs = sexp.values.drop(1).map { it.transformExpect<SortSpec>() }
                    PartiqlAst.OrderBy(
                        sortSpecs,
                        metas = sexp.metas)
                }
                "sort_spec" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val orderingSpec = sexp.getOptional(1)?.transformExpect<OrderingSpec>()
                    PartiqlAst.SortSpec(
                        expr,
                        orderingSpec,
                        metas = sexp.metas)
                }
                "dml_op_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val ops = sexp.values.drop(1).map { it.transformExpect<DmlOp>() }
                    PartiqlAst.DmlOpList(
                        ops,
                        metas = sexp.metas)
                }
                "on_conflict" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val conflictAction = sexp.getRequired(1).transformExpect<ConflictAction>()
                    PartiqlAst.OnConflict(
                        expr,
                        conflictAction,
                        metas = sexp.metas)
                }
                "returning_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val elems = sexp.values.drop(1).map { it.transformExpect<ReturningElem>() }
                    PartiqlAst.ReturningExpr(
                        elems,
                        metas = sexp.metas)
                }
                "returning_elem" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val mapping = sexp.getRequired(0).transformExpect<ReturningMapping>()
                    val column = sexp.getRequired(1).transformExpect<ColumnComponent>()
                    PartiqlAst.ReturningElem(
                        mapping,
                        column,
                        metas = sexp.metas)
                }
                "identifier" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    PartiqlAst.Identifier(
                        name,
                        case,
                        metas = sexp.metas)
                }
                "assignment" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val target = sexp.getRequired(0).transformExpect<Expr>()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlAst.Assignment(
                        target,
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Statement'
                //////////////////////////////////////
                "query" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.Statement.Query(
                        expr,
                        metas = sexp.metas)
                }
                "dml" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val operations = ir.processRequiredField("operations") { it.transformExpect<DmlOpList>() }
                    val from = ir.processOptionalField("from") { it.transformExpect<FromSource>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val returning = ir.processOptionalField("returning") { it.transformExpect<ReturningExpr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Statement.Dml(operations, from, where, returning, metas = sexp.metas)
                }
                "ddl" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val op = sexp.getRequired(0).transformExpect<DdlOp>()
                    PartiqlAst.Statement.Ddl(
                        op,
                        metas = sexp.metas)
                }
                "exec" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val procedureName = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.Statement.Exec(
                        procedureName,
                        args,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Expr'
                //////////////////////////////////////
                "missing" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Expr.Missing(
                        metas = sexp.metas)
                }
                "lit" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequiredIon(0)
                    PartiqlAst.Expr.Lit(
                        value,
                        metas = sexp.metas)
                }
                "id" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    val qualifier = sexp.getRequired(2).transformExpect<ScopeQualifier>()
                    PartiqlAst.Expr.Id(
                        name,
                        case,
                        qualifier,
                        metas = sexp.metas)
                }
                "parameter" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val index = sexp.getRequired(0).toLongPrimitive()
                    PartiqlAst.Expr.Parameter(
                        index,
                        metas = sexp.metas)
                }
                "not" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.Expr.Not(
                        expr,
                        metas = sexp.metas)
                }
                "pos" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.Expr.Pos(
                        expr,
                        metas = sexp.metas)
                }
                "neg" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.Expr.Neg(
                        expr,
                        metas = sexp.metas)
                }
                "plus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Plus(
                        operands,
                        metas = sexp.metas)
                }
                "minus" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Minus(
                        operands,
                        metas = sexp.metas)
                }
                "times" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Times(
                        operands,
                        metas = sexp.metas)
                }
                "divide" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Divide(
                        operands,
                        metas = sexp.metas)
                }
                "modulo" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Modulo(
                        operands,
                        metas = sexp.metas)
                }
                "concat" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Concat(
                        operands,
                        metas = sexp.metas)
                }
                "and" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.And(
                        operands,
                        metas = sexp.metas)
                }
                "or" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Or(
                        operands,
                        metas = sexp.metas)
                }
                "eq" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Eq(
                        operands,
                        metas = sexp.metas)
                }
                "ne" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Ne(
                        operands,
                        metas = sexp.metas)
                }
                "gt" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Gt(
                        operands,
                        metas = sexp.metas)
                }
                "gte" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Gte(
                        operands,
                        metas = sexp.metas)
                }
                "lt" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Lt(
                        operands,
                        metas = sexp.metas)
                }
                "lte" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Lte(
                        operands,
                        metas = sexp.metas)
                }
                "like" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val pattern = sexp.getRequired(1).transformExpect<Expr>()
                    val escape = sexp.getOptional(2)?.transformExpect<Expr>()
                    PartiqlAst.Expr.Like(
                        value,
                        pattern,
                        escape,
                        metas = sexp.metas)
                }
                "between" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val from = sexp.getRequired(1).transformExpect<Expr>()
                    val to = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlAst.Expr.Between(
                        value,
                        from,
                        to,
                        metas = sexp.metas)
                }
                "in_collection" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val operands = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.InCollection(
                        operands,
                        metas = sexp.metas)
                }
                "is_type" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val type = sexp.getRequired(1).transformExpect<Type>()
                    PartiqlAst.Expr.IsType(
                        value,
                        type,
                        metas = sexp.metas)
                }
                "simple_case" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 3))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val cases = sexp.getRequired(1).transformExpect<ExprPairList>()
                    val default = sexp.getOptional(2)?.transformExpect<Expr>()
                    PartiqlAst.Expr.SimpleCase(
                        expr,
                        cases,
                        default,
                        metas = sexp.metas)
                }
                "searched_case" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val cases = sexp.getRequired(0).transformExpect<ExprPairList>()
                    val default = sexp.getOptional(1)?.transformExpect<Expr>()
                    PartiqlAst.Expr.SearchedCase(
                        cases,
                        default,
                        metas = sexp.metas)
                }
                "struct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val fields = sexp.values.drop(1).map { it.transformExpect<ExprPair>() }
                    PartiqlAst.Expr.Struct(
                        fields,
                        metas = sexp.metas)
                }
                "bag" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Bag(
                        values,
                        metas = sexp.metas)
                }
                "list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.List(
                        values,
                        metas = sexp.metas)
                }
                "sexp" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val values = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Sexp(
                        values,
                        metas = sexp.metas)
                }
                "date" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val year = sexp.getRequired(0).toLongPrimitive()
                    val month = sexp.getRequired(1).toLongPrimitive()
                    val day = sexp.getRequired(2).toLongPrimitive()
                    PartiqlAst.Expr.Date(
                        year,
                        month,
                        day,
                        metas = sexp.metas)
                }
                "lit_time" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<TimeValue>()
                    PartiqlAst.Expr.LitTime(
                        value,
                        metas = sexp.metas)
                }
                "union" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val setq = sexp.getRequired(0).transformExpect<SetQuantifier>()
                    val operands = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Union(
                        setq,
                        operands,
                        metas = sexp.metas)
                }
                "except" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val setq = sexp.getRequired(0).transformExpect<SetQuantifier>()
                    val operands = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Except(
                        setq,
                        operands,
                        metas = sexp.metas)
                }
                "intersect" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val setq = sexp.getRequired(0).transformExpect<SetQuantifier>()
                    val operands = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Intersect(
                        setq,
                        operands,
                        metas = sexp.metas)
                }
                "path" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val root = sexp.getRequired(0).transformExpect<Expr>()
                    val steps = sexp.values.drop(2).map { it.transformExpect<PathStep>() }
                    PartiqlAst.Expr.Path(
                        root,
                        steps,
                        metas = sexp.metas)
                }
                "call" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val funcName = sexp.getRequired(0).toSymbolPrimitive()
                    val args = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Call(
                        funcName,
                        args,
                        metas = sexp.metas)
                }
                "call_agg" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 3))
                    val setq = sexp.getRequired(0).transformExpect<SetQuantifier>()
                    val funcName = sexp.getRequired(1).toSymbolPrimitive()
                    val arg = sexp.getRequired(2).transformExpect<Expr>()
                    PartiqlAst.Expr.CallAgg(
                        setq,
                        funcName,
                        arg,
                        metas = sexp.metas)
                }
                "cast" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asType = sexp.getRequired(1).transformExpect<Type>()
                    PartiqlAst.Expr.Cast(
                        value,
                        asType,
                        metas = sexp.metas)
                }
                "can_cast" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asType = sexp.getRequired(1).transformExpect<Type>()
                    PartiqlAst.Expr.CanCast(
                        value,
                        asType,
                        metas = sexp.metas)
                }
                "can_lossless_cast" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val asType = sexp.getRequired(1).transformExpect<Type>()
                    PartiqlAst.Expr.CanLosslessCast(
                        value,
                        asType,
                        metas = sexp.metas)
                }
                "null_if" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val expr1 = sexp.getRequired(0).transformExpect<Expr>()
                    val expr2 = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlAst.Expr.NullIf(
                        expr1,
                        expr2,
                        metas = sexp.metas)
                }
                "coalesce" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val args = sexp.values.drop(1).map { it.transformExpect<Expr>() }
                    PartiqlAst.Expr.Coalesce(
                        args,
                        metas = sexp.metas)
                }
                "select" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val setq = ir.processOptionalField("setq") { it.transformExpect<SetQuantifier>() }
                    val project = ir.processRequiredField("project") { it.transformExpect<Projection>() }
                    val from = ir.processRequiredField("from") { it.transformExpect<FromSource>() }
                    val fromLet = ir.processOptionalField("from_let") { it.transformExpect<Let>() }
                    val where = ir.processOptionalField("where") { it.transformExpect<Expr>() }
                    val group = ir.processOptionalField("group") { it.transformExpect<GroupBy>() }
                    val having = ir.processOptionalField("having") { it.transformExpect<Expr>() }
                    val order = ir.processOptionalField("order") { it.transformExpect<OrderBy>() }
                    val limit = ir.processOptionalField("limit") { it.transformExpect<Expr>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    Expr.Select(setq, project, from, fromLet, where, group, having, order, limit, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'PathStep'
                //////////////////////////////////////
                "path_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val index = sexp.getRequired(0).transformExpect<Expr>()
                    val case = sexp.getRequired(1).transformExpect<CaseSensitivity>()
                    PartiqlAst.PathStep.PathExpr(
                        index,
                        case,
                        metas = sexp.metas)
                }
                "path_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.PathStep.PathWildcard(
                        metas = sexp.metas)
                }
                "path_unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.PathStep.PathUnpivot(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Projection'
                //////////////////////////////////////
                "project_star" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Projection.ProjectStar(
                        metas = sexp.metas)
                }
                "project_list" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2147483647))
                    val projectItems = sexp.values.drop(1).map { it.transformExpect<ProjectItem>() }
                    PartiqlAst.Projection.ProjectList(
                        projectItems,
                        metas = sexp.metas)
                }
                "project_pivot" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    val key = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlAst.Projection.ProjectPivot(
                        value,
                        key,
                        metas = sexp.metas)
                }
                "project_value" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val value = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.Projection.ProjectValue(
                        value,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ProjectItem'
                //////////////////////////////////////
                "project_all" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.ProjectItem.ProjectAll(
                        expr,
                        metas = sexp.metas)
                }
                "project_expr" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    PartiqlAst.ProjectItem.ProjectExpr(
                        expr,
                        asAlias,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'FromSource'
                //////////////////////////////////////
                "scan" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlAst.FromSource.Scan(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "unpivot" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 4))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    val asAlias = sexp.getOptional(1)?.toSymbolPrimitive()
                    val atAlias = sexp.getOptional(2)?.toSymbolPrimitive()
                    val byAlias = sexp.getOptional(3)?.toSymbolPrimitive()
                    PartiqlAst.FromSource.Unpivot(
                        expr,
                        asAlias,
                        atAlias,
                        byAlias,
                        metas = sexp.metas)
                }
                "join" -> {
                    sexp.requireArityOrMalformed(IntRange(3, 4))
                    val type = sexp.getRequired(0).transformExpect<JoinType>()
                    val left = sexp.getRequired(1).transformExpect<FromSource>()
                    val right = sexp.getRequired(2).transformExpect<FromSource>()
                    val predicate = sexp.getOptional(3)?.transformExpect<Expr>()
                    PartiqlAst.FromSource.Join(
                        type,
                        left,
                        right,
                        predicate,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'JoinType'
                //////////////////////////////////////
                "inner" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.JoinType.Inner(
                        metas = sexp.metas)
                }
                "left" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.JoinType.Left(
                        metas = sexp.metas)
                }
                "right" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.JoinType.Right(
                        metas = sexp.metas)
                }
                "full" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.JoinType.Full(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'GroupingStrategy'
                //////////////////////////////////////
                "group_full" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.GroupingStrategy.GroupFull(
                        metas = sexp.metas)
                }
                "group_partial" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.GroupingStrategy.GroupPartial(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'OrderingSpec'
                //////////////////////////////////////
                "asc" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.OrderingSpec.Asc(
                        metas = sexp.metas)
                }
                "desc" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.OrderingSpec.Desc(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'CaseSensitivity'
                //////////////////////////////////////
                "case_sensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.CaseSensitivity.CaseSensitive(
                        metas = sexp.metas)
                }
                "case_insensitive" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.CaseSensitivity.CaseInsensitive(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ScopeQualifier'
                //////////////////////////////////////
                "unqualified" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ScopeQualifier.Unqualified(
                        metas = sexp.metas)
                }
                "locals_first" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ScopeQualifier.LocalsFirst(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'SetQuantifier'
                //////////////////////////////////////
                "all" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.SetQuantifier.All(
                        metas = sexp.metas)
                }
                "distinct" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.SetQuantifier.Distinct(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'DmlOp'
                //////////////////////////////////////
                "insert" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 2))
                    val target = sexp.getRequired(0).transformExpect<Expr>()
                    val values = sexp.getRequired(1).transformExpect<Expr>()
                    PartiqlAst.DmlOp.Insert(
                        target,
                        values,
                        metas = sexp.metas)
                }
                "insert_value" -> {
                    sexp.requireArityOrMalformed(IntRange(2, 4))
                    val target = sexp.getRequired(0).transformExpect<Expr>()
                    val value = sexp.getRequired(1).transformExpect<Expr>()
                    val index = sexp.getOptional(2)?.transformExpect<Expr>()
                    val onConflict = sexp.getOptional(3)?.transformExpect<OnConflict>()
                    PartiqlAst.DmlOp.InsertValue(
                        target,
                        value,
                        index,
                        onConflict,
                        metas = sexp.metas)
                }
                "set" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val assignment = sexp.getRequired(0).transformExpect<Assignment>()
                    PartiqlAst.DmlOp.Set(
                        assignment,
                        metas = sexp.metas)
                }
                "remove" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val target = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.DmlOp.Remove(
                        target,
                        metas = sexp.metas)
                }
                "delete" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.DmlOp.Delete(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ConflictAction'
                //////////////////////////////////////
                "do_nothing" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ConflictAction.DoNothing(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'DdlOp'
                //////////////////////////////////////
                "create_table" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val tableName = sexp.getRequired(0).toSymbolPrimitive()
                    PartiqlAst.DdlOp.CreateTable(
                        tableName,
                        metas = sexp.metas)
                }
                "drop_table" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val tableName = sexp.getRequired(0).transformExpect<Identifier>()
                    PartiqlAst.DdlOp.DropTable(
                        tableName,
                        metas = sexp.metas)
                }
                "undrop_table" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val tableName = sexp.getRequired(0).toSymbolPrimitive()
                    PartiqlAst.DdlOp.UndropTable(
                        tableName,
                        metas = sexp.metas)
                }
                "create_index" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 2147483647))
                    val indexName = sexp.getRequired(0).transformExpect<Identifier>()
                    val fields = sexp.values.drop(2).map { it.transformExpect<Expr>() }
                    PartiqlAst.DdlOp.CreateIndex(
                        indexName,
                        fields,
                        metas = sexp.metas)
                }
                "drop_index" -> {
                    val ir = sexp.transformToIntermediateRecord()
            
                    val table = ir.processRequiredField("table") { it.transformExpect<Identifier>() }
                    val keys = ir.processRequiredField("keys") { it.transformExpect<Identifier>() }
            
                    ir.malformedIfAnyUnprocessedFieldsRemain()
            
                    DdlOp.DropIndex(table, keys, metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ColumnComponent'
                //////////////////////////////////////
                "returning_wildcard" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ColumnComponent.ReturningWildcard(
                        metas = sexp.metas)
                }
                "returning_column" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val expr = sexp.getRequired(0).transformExpect<Expr>()
                    PartiqlAst.ColumnComponent.ReturningColumn(
                        expr,
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'ReturningMapping'
                //////////////////////////////////////
                "modified_new" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ReturningMapping.ModifiedNew(
                        metas = sexp.metas)
                }
                "modified_old" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ReturningMapping.ModifiedOld(
                        metas = sexp.metas)
                }
                "all_new" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ReturningMapping.AllNew(
                        metas = sexp.metas)
                }
                "all_old" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.ReturningMapping.AllOld(
                        metas = sexp.metas)
                }
                //////////////////////////////////////
                // Variants for Sum Type 'Type'
                //////////////////////////////////////
                "null_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.NullType(
                        metas = sexp.metas)
                }
                "boolean_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.BooleanType(
                        metas = sexp.metas)
                }
                "smallint_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SmallintType(
                        metas = sexp.metas)
                }
                "integer4_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.Integer4Type(
                        metas = sexp.metas)
                }
                "integer8_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.Integer8Type(
                        metas = sexp.metas)
                }
                "integer_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.IntegerType(
                        metas = sexp.metas)
                }
                "float_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val precision = sexp.getOptional(0)?.toLongPrimitive()
                    PartiqlAst.Type.FloatType(
                        precision,
                        metas = sexp.metas)
                }
                "real_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RealType(
                        metas = sexp.metas)
                }
                "double_precision_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.DoublePrecisionType(
                        metas = sexp.metas)
                }
                "decimal_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val precision = sexp.getOptional(0)?.toLongPrimitive()
                    val scale = sexp.getOptional(1)?.toLongPrimitive()
                    PartiqlAst.Type.DecimalType(
                        precision,
                        scale,
                        metas = sexp.metas)
                }
                "numeric_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 2))
                    val precision = sexp.getOptional(0)?.toLongPrimitive()
                    val scale = sexp.getOptional(1)?.toLongPrimitive()
                    PartiqlAst.Type.NumericType(
                        precision,
                        scale,
                        metas = sexp.metas)
                }
                "timestamp_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.TimestampType(
                        metas = sexp.metas)
                }
                "character_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val length = sexp.getOptional(0)?.toLongPrimitive()
                    PartiqlAst.Type.CharacterType(
                        length,
                        metas = sexp.metas)
                }
                "character_varying_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val length = sexp.getOptional(0)?.toLongPrimitive()
                    PartiqlAst.Type.CharacterVaryingType(
                        length,
                        metas = sexp.metas)
                }
                "missing_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.MissingType(
                        metas = sexp.metas)
                }
                "string_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.StringType(
                        metas = sexp.metas)
                }
                "symbol_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SymbolType(
                        metas = sexp.metas)
                }
                "blob_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.BlobType(
                        metas = sexp.metas)
                }
                "clob_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.ClobType(
                        metas = sexp.metas)
                }
                "date_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.DateType(
                        metas = sexp.metas)
                }
                "time_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val precision = sexp.getOptional(0)?.toLongPrimitive()
                    PartiqlAst.Type.TimeType(
                        precision,
                        metas = sexp.metas)
                }
                "time_with_time_zone_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 1))
                    val precision = sexp.getOptional(0)?.toLongPrimitive()
                    PartiqlAst.Type.TimeWithTimeZoneType(
                        precision,
                        metas = sexp.metas)
                }
                "struct_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.StructType(
                        metas = sexp.metas)
                }
                "tuple_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.TupleType(
                        metas = sexp.metas)
                }
                "list_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.ListType(
                        metas = sexp.metas)
                }
                "sexp_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SexpType(
                        metas = sexp.metas)
                }
                "bag_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.BagType(
                        metas = sexp.metas)
                }
                "any_type" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.AnyType(
                        metas = sexp.metas)
                }
                "es_boolean" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.EsBoolean(
                        metas = sexp.metas)
                }
                "es_integer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.EsInteger(
                        metas = sexp.metas)
                }
                "es_float" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.EsFloat(
                        metas = sexp.metas)
                }
                "es_text" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.EsText(
                        metas = sexp.metas)
                }
                "es_any" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.EsAny(
                        metas = sexp.metas)
                }
                "spark_short" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkShort(
                        metas = sexp.metas)
                }
                "spark_integer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkInteger(
                        metas = sexp.metas)
                }
                "spark_long" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkLong(
                        metas = sexp.metas)
                }
                "spark_double" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkDouble(
                        metas = sexp.metas)
                }
                "spark_boolean" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkBoolean(
                        metas = sexp.metas)
                }
                "spark_float" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.SparkFloat(
                        metas = sexp.metas)
                }
                "rs_varchar_max" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsVarcharMax(
                        metas = sexp.metas)
                }
                "rs_integer" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsInteger(
                        metas = sexp.metas)
                }
                "rs_bigint" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsBigint(
                        metas = sexp.metas)
                }
                "rs_boolean" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsBoolean(
                        metas = sexp.metas)
                }
                "rs_real" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsReal(
                        metas = sexp.metas)
                }
                "rs_double_precision" -> {
                    sexp.requireArityOrMalformed(IntRange(0, 0))
                    PartiqlAst.Type.RsDoublePrecision(
                        metas = sexp.metas)
                }
                "custom_type" -> {
                    sexp.requireArityOrMalformed(IntRange(1, 1))
                    val name = sexp.getRequired(0).toSymbolPrimitive()
                    PartiqlAst.Type.CustomType(
                        name,
                        metas = sexp.metas)
                }
                else -> errMalformed(sexp.head.metas.location, "Unknown tag '${sexp.tag}' for domain 'partiql_ast'")
            }
        }
    }
    
    
    open class Visitor : DomainVisitorBase() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun visitTimeValue(node: PartiqlAst.TimeValue) { }
        open fun visitLet(node: PartiqlAst.Let) { }
        open fun visitLetBinding(node: PartiqlAst.LetBinding) { }
        open fun visitExprPair(node: PartiqlAst.ExprPair) { }
        open fun visitExprPairList(node: PartiqlAst.ExprPairList) { }
        open fun visitGroupBy(node: PartiqlAst.GroupBy) { }
        open fun visitGroupKeyList(node: PartiqlAst.GroupKeyList) { }
        open fun visitGroupKey(node: PartiqlAst.GroupKey) { }
        open fun visitOrderBy(node: PartiqlAst.OrderBy) { }
        open fun visitSortSpec(node: PartiqlAst.SortSpec) { }
        open fun visitDmlOpList(node: PartiqlAst.DmlOpList) { }
        open fun visitOnConflict(node: PartiqlAst.OnConflict) { }
        open fun visitReturningExpr(node: PartiqlAst.ReturningExpr) { }
        open fun visitReturningElem(node: PartiqlAst.ReturningElem) { }
        open fun visitIdentifier(node: PartiqlAst.Identifier) { }
        open fun visitAssignment(node: PartiqlAst.Assignment) { }
        //////////////////////////////////////
        // Sum Type: Statement
        //////////////////////////////////////
        protected open fun visitStatement(node: PartiqlAst.Statement) { }
        protected open fun visitStatementQuery(node: PartiqlAst.Statement.Query) { }
        protected open fun visitStatementDml(node: PartiqlAst.Statement.Dml) { }
        protected open fun visitStatementDdl(node: PartiqlAst.Statement.Ddl) { }
        protected open fun visitStatementExec(node: PartiqlAst.Statement.Exec) { }
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        protected open fun visitExpr(node: PartiqlAst.Expr) { }
        protected open fun visitExprMissing(node: PartiqlAst.Expr.Missing) { }
        protected open fun visitExprLit(node: PartiqlAst.Expr.Lit) { }
        protected open fun visitExprId(node: PartiqlAst.Expr.Id) { }
        protected open fun visitExprParameter(node: PartiqlAst.Expr.Parameter) { }
        protected open fun visitExprNot(node: PartiqlAst.Expr.Not) { }
        protected open fun visitExprPos(node: PartiqlAst.Expr.Pos) { }
        protected open fun visitExprNeg(node: PartiqlAst.Expr.Neg) { }
        protected open fun visitExprPlus(node: PartiqlAst.Expr.Plus) { }
        protected open fun visitExprMinus(node: PartiqlAst.Expr.Minus) { }
        protected open fun visitExprTimes(node: PartiqlAst.Expr.Times) { }
        protected open fun visitExprDivide(node: PartiqlAst.Expr.Divide) { }
        protected open fun visitExprModulo(node: PartiqlAst.Expr.Modulo) { }
        protected open fun visitExprConcat(node: PartiqlAst.Expr.Concat) { }
        protected open fun visitExprAnd(node: PartiqlAst.Expr.And) { }
        protected open fun visitExprOr(node: PartiqlAst.Expr.Or) { }
        protected open fun visitExprEq(node: PartiqlAst.Expr.Eq) { }
        protected open fun visitExprNe(node: PartiqlAst.Expr.Ne) { }
        protected open fun visitExprGt(node: PartiqlAst.Expr.Gt) { }
        protected open fun visitExprGte(node: PartiqlAst.Expr.Gte) { }
        protected open fun visitExprLt(node: PartiqlAst.Expr.Lt) { }
        protected open fun visitExprLte(node: PartiqlAst.Expr.Lte) { }
        protected open fun visitExprLike(node: PartiqlAst.Expr.Like) { }
        protected open fun visitExprBetween(node: PartiqlAst.Expr.Between) { }
        protected open fun visitExprInCollection(node: PartiqlAst.Expr.InCollection) { }
        protected open fun visitExprIsType(node: PartiqlAst.Expr.IsType) { }
        protected open fun visitExprSimpleCase(node: PartiqlAst.Expr.SimpleCase) { }
        protected open fun visitExprSearchedCase(node: PartiqlAst.Expr.SearchedCase) { }
        protected open fun visitExprStruct(node: PartiqlAst.Expr.Struct) { }
        protected open fun visitExprBag(node: PartiqlAst.Expr.Bag) { }
        protected open fun visitExprList(node: PartiqlAst.Expr.List) { }
        protected open fun visitExprSexp(node: PartiqlAst.Expr.Sexp) { }
        protected open fun visitExprDate(node: PartiqlAst.Expr.Date) { }
        protected open fun visitExprLitTime(node: PartiqlAst.Expr.LitTime) { }
        protected open fun visitExprUnion(node: PartiqlAst.Expr.Union) { }
        protected open fun visitExprExcept(node: PartiqlAst.Expr.Except) { }
        protected open fun visitExprIntersect(node: PartiqlAst.Expr.Intersect) { }
        protected open fun visitExprPath(node: PartiqlAst.Expr.Path) { }
        protected open fun visitExprCall(node: PartiqlAst.Expr.Call) { }
        protected open fun visitExprCallAgg(node: PartiqlAst.Expr.CallAgg) { }
        protected open fun visitExprCast(node: PartiqlAst.Expr.Cast) { }
        protected open fun visitExprCanCast(node: PartiqlAst.Expr.CanCast) { }
        protected open fun visitExprCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast) { }
        protected open fun visitExprNullIf(node: PartiqlAst.Expr.NullIf) { }
        protected open fun visitExprCoalesce(node: PartiqlAst.Expr.Coalesce) { }
        protected open fun visitExprSelect(node: PartiqlAst.Expr.Select) { }
        //////////////////////////////////////
        // Sum Type: PathStep
        //////////////////////////////////////
        protected open fun visitPathStep(node: PartiqlAst.PathStep) { }
        protected open fun visitPathStepPathExpr(node: PartiqlAst.PathStep.PathExpr) { }
        protected open fun visitPathStepPathWildcard(node: PartiqlAst.PathStep.PathWildcard) { }
        protected open fun visitPathStepPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot) { }
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        protected open fun visitProjection(node: PartiqlAst.Projection) { }
        protected open fun visitProjectionProjectStar(node: PartiqlAst.Projection.ProjectStar) { }
        protected open fun visitProjectionProjectList(node: PartiqlAst.Projection.ProjectList) { }
        protected open fun visitProjectionProjectPivot(node: PartiqlAst.Projection.ProjectPivot) { }
        protected open fun visitProjectionProjectValue(node: PartiqlAst.Projection.ProjectValue) { }
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        protected open fun visitProjectItem(node: PartiqlAst.ProjectItem) { }
        protected open fun visitProjectItemProjectAll(node: PartiqlAst.ProjectItem.ProjectAll) { }
        protected open fun visitProjectItemProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr) { }
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        protected open fun visitFromSource(node: PartiqlAst.FromSource) { }
        protected open fun visitFromSourceScan(node: PartiqlAst.FromSource.Scan) { }
        protected open fun visitFromSourceUnpivot(node: PartiqlAst.FromSource.Unpivot) { }
        protected open fun visitFromSourceJoin(node: PartiqlAst.FromSource.Join) { }
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        protected open fun visitJoinType(node: PartiqlAst.JoinType) { }
        protected open fun visitJoinTypeInner(node: PartiqlAst.JoinType.Inner) { }
        protected open fun visitJoinTypeLeft(node: PartiqlAst.JoinType.Left) { }
        protected open fun visitJoinTypeRight(node: PartiqlAst.JoinType.Right) { }
        protected open fun visitJoinTypeFull(node: PartiqlAst.JoinType.Full) { }
        //////////////////////////////////////
        // Sum Type: GroupingStrategy
        //////////////////////////////////////
        protected open fun visitGroupingStrategy(node: PartiqlAst.GroupingStrategy) { }
        protected open fun visitGroupingStrategyGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull) { }
        protected open fun visitGroupingStrategyGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial) { }
        //////////////////////////////////////
        // Sum Type: OrderingSpec
        //////////////////////////////////////
        protected open fun visitOrderingSpec(node: PartiqlAst.OrderingSpec) { }
        protected open fun visitOrderingSpecAsc(node: PartiqlAst.OrderingSpec.Asc) { }
        protected open fun visitOrderingSpecDesc(node: PartiqlAst.OrderingSpec.Desc) { }
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        protected open fun visitCaseSensitivity(node: PartiqlAst.CaseSensitivity) { }
        protected open fun visitCaseSensitivityCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive) { }
        protected open fun visitCaseSensitivityCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive) { }
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        protected open fun visitScopeQualifier(node: PartiqlAst.ScopeQualifier) { }
        protected open fun visitScopeQualifierUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified) { }
        protected open fun visitScopeQualifierLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst) { }
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        protected open fun visitSetQuantifier(node: PartiqlAst.SetQuantifier) { }
        protected open fun visitSetQuantifierAll(node: PartiqlAst.SetQuantifier.All) { }
        protected open fun visitSetQuantifierDistinct(node: PartiqlAst.SetQuantifier.Distinct) { }
        //////////////////////////////////////
        // Sum Type: DmlOp
        //////////////////////////////////////
        protected open fun visitDmlOp(node: PartiqlAst.DmlOp) { }
        protected open fun visitDmlOpInsert(node: PartiqlAst.DmlOp.Insert) { }
        protected open fun visitDmlOpInsertValue(node: PartiqlAst.DmlOp.InsertValue) { }
        protected open fun visitDmlOpSet(node: PartiqlAst.DmlOp.Set) { }
        protected open fun visitDmlOpRemove(node: PartiqlAst.DmlOp.Remove) { }
        protected open fun visitDmlOpDelete(node: PartiqlAst.DmlOp.Delete) { }
        //////////////////////////////////////
        // Sum Type: ConflictAction
        //////////////////////////////////////
        protected open fun visitConflictAction(node: PartiqlAst.ConflictAction) { }
        protected open fun visitConflictActionDoNothing(node: PartiqlAst.ConflictAction.DoNothing) { }
        //////////////////////////////////////
        // Sum Type: DdlOp
        //////////////////////////////////////
        protected open fun visitDdlOp(node: PartiqlAst.DdlOp) { }
        protected open fun visitDdlOpCreateTable(node: PartiqlAst.DdlOp.CreateTable) { }
        protected open fun visitDdlOpDropTable(node: PartiqlAst.DdlOp.DropTable) { }
        protected open fun visitDdlOpUndropTable(node: PartiqlAst.DdlOp.UndropTable) { }
        protected open fun visitDdlOpCreateIndex(node: PartiqlAst.DdlOp.CreateIndex) { }
        protected open fun visitDdlOpDropIndex(node: PartiqlAst.DdlOp.DropIndex) { }
        //////////////////////////////////////
        // Sum Type: ColumnComponent
        //////////////////////////////////////
        protected open fun visitColumnComponent(node: PartiqlAst.ColumnComponent) { }
        protected open fun visitColumnComponentReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard) { }
        protected open fun visitColumnComponentReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn) { }
        //////////////////////////////////////
        // Sum Type: ReturningMapping
        //////////////////////////////////////
        protected open fun visitReturningMapping(node: PartiqlAst.ReturningMapping) { }
        protected open fun visitReturningMappingModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew) { }
        protected open fun visitReturningMappingModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld) { }
        protected open fun visitReturningMappingAllNew(node: PartiqlAst.ReturningMapping.AllNew) { }
        protected open fun visitReturningMappingAllOld(node: PartiqlAst.ReturningMapping.AllOld) { }
        //////////////////////////////////////
        // Sum Type: Type
        //////////////////////////////////////
        protected open fun visitType(node: PartiqlAst.Type) { }
        protected open fun visitTypeNullType(node: PartiqlAst.Type.NullType) { }
        protected open fun visitTypeBooleanType(node: PartiqlAst.Type.BooleanType) { }
        protected open fun visitTypeSmallintType(node: PartiqlAst.Type.SmallintType) { }
        protected open fun visitTypeInteger4Type(node: PartiqlAst.Type.Integer4Type) { }
        protected open fun visitTypeInteger8Type(node: PartiqlAst.Type.Integer8Type) { }
        protected open fun visitTypeIntegerType(node: PartiqlAst.Type.IntegerType) { }
        protected open fun visitTypeFloatType(node: PartiqlAst.Type.FloatType) { }
        protected open fun visitTypeRealType(node: PartiqlAst.Type.RealType) { }
        protected open fun visitTypeDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType) { }
        protected open fun visitTypeDecimalType(node: PartiqlAst.Type.DecimalType) { }
        protected open fun visitTypeNumericType(node: PartiqlAst.Type.NumericType) { }
        protected open fun visitTypeTimestampType(node: PartiqlAst.Type.TimestampType) { }
        protected open fun visitTypeCharacterType(node: PartiqlAst.Type.CharacterType) { }
        protected open fun visitTypeCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType) { }
        protected open fun visitTypeMissingType(node: PartiqlAst.Type.MissingType) { }
        protected open fun visitTypeStringType(node: PartiqlAst.Type.StringType) { }
        protected open fun visitTypeSymbolType(node: PartiqlAst.Type.SymbolType) { }
        protected open fun visitTypeBlobType(node: PartiqlAst.Type.BlobType) { }
        protected open fun visitTypeClobType(node: PartiqlAst.Type.ClobType) { }
        protected open fun visitTypeDateType(node: PartiqlAst.Type.DateType) { }
        protected open fun visitTypeTimeType(node: PartiqlAst.Type.TimeType) { }
        protected open fun visitTypeTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType) { }
        protected open fun visitTypeStructType(node: PartiqlAst.Type.StructType) { }
        protected open fun visitTypeTupleType(node: PartiqlAst.Type.TupleType) { }
        protected open fun visitTypeListType(node: PartiqlAst.Type.ListType) { }
        protected open fun visitTypeSexpType(node: PartiqlAst.Type.SexpType) { }
        protected open fun visitTypeBagType(node: PartiqlAst.Type.BagType) { }
        protected open fun visitTypeAnyType(node: PartiqlAst.Type.AnyType) { }
        protected open fun visitTypeEsBoolean(node: PartiqlAst.Type.EsBoolean) { }
        protected open fun visitTypeEsInteger(node: PartiqlAst.Type.EsInteger) { }
        protected open fun visitTypeEsFloat(node: PartiqlAst.Type.EsFloat) { }
        protected open fun visitTypeEsText(node: PartiqlAst.Type.EsText) { }
        protected open fun visitTypeEsAny(node: PartiqlAst.Type.EsAny) { }
        protected open fun visitTypeSparkShort(node: PartiqlAst.Type.SparkShort) { }
        protected open fun visitTypeSparkInteger(node: PartiqlAst.Type.SparkInteger) { }
        protected open fun visitTypeSparkLong(node: PartiqlAst.Type.SparkLong) { }
        protected open fun visitTypeSparkDouble(node: PartiqlAst.Type.SparkDouble) { }
        protected open fun visitTypeSparkBoolean(node: PartiqlAst.Type.SparkBoolean) { }
        protected open fun visitTypeSparkFloat(node: PartiqlAst.Type.SparkFloat) { }
        protected open fun visitTypeRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax) { }
        protected open fun visitTypeRsInteger(node: PartiqlAst.Type.RsInteger) { }
        protected open fun visitTypeRsBigint(node: PartiqlAst.Type.RsBigint) { }
        protected open fun visitTypeRsBoolean(node: PartiqlAst.Type.RsBoolean) { }
        protected open fun visitTypeRsReal(node: PartiqlAst.Type.RsReal) { }
        protected open fun visitTypeRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision) { }
        protected open fun visitTypeCustomType(node: PartiqlAst.Type.CustomType) { }
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkTimeValue(node: PartiqlAst.TimeValue) {
            visitTimeValue(node)
            walkLongPrimitive(node.hour)
            walkLongPrimitive(node.minute)
            walkLongPrimitive(node.second)
            walkLongPrimitive(node.nano)
            walkLongPrimitive(node.precision)
            node.tzMinutes?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkLet(node: PartiqlAst.Let) {
            visitLet(node)
            node.letBindings.map { walkLetBinding(it) }
            walkMetas(node.metas)
        }
    
        open fun walkLetBinding(node: PartiqlAst.LetBinding) {
            visitLetBinding(node)
            walkExpr(node.expr)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
    
        open fun walkExprPair(node: PartiqlAst.ExprPair) {
            visitExprPair(node)
            walkExpr(node.first)
            walkExpr(node.second)
            walkMetas(node.metas)
        }
    
        open fun walkExprPairList(node: PartiqlAst.ExprPairList) {
            visitExprPairList(node)
            node.pairs.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupBy(node: PartiqlAst.GroupBy) {
            visitGroupBy(node)
            walkGroupingStrategy(node.strategy)
            walkGroupKeyList(node.keyList)
            node.groupAsAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupKeyList(node: PartiqlAst.GroupKeyList) {
            visitGroupKeyList(node)
            node.keys.map { walkGroupKey(it) }
            walkMetas(node.metas)
        }
    
        open fun walkGroupKey(node: PartiqlAst.GroupKey) {
            visitGroupKey(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOrderBy(node: PartiqlAst.OrderBy) {
            visitOrderBy(node)
            node.sortSpecs.map { walkSortSpec(it) }
            walkMetas(node.metas)
        }
    
        open fun walkSortSpec(node: PartiqlAst.SortSpec) {
            visitSortSpec(node)
            walkExpr(node.expr)
            node.orderingSpec?.let { walkOrderingSpec(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDmlOpList(node: PartiqlAst.DmlOpList) {
            visitDmlOpList(node)
            node.ops.map { walkDmlOp(it) }
            walkMetas(node.metas)
        }
    
        open fun walkOnConflict(node: PartiqlAst.OnConflict) {
            visitOnConflict(node)
            walkExpr(node.expr)
            walkConflictAction(node.conflictAction)
            walkMetas(node.metas)
        }
    
        open fun walkReturningExpr(node: PartiqlAst.ReturningExpr) {
            visitReturningExpr(node)
            node.elems.map { walkReturningElem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkReturningElem(node: PartiqlAst.ReturningElem) {
            visitReturningElem(node)
            walkReturningMapping(node.mapping)
            walkColumnComponent(node.column)
            walkMetas(node.metas)
        }
    
        open fun walkIdentifier(node: PartiqlAst.Identifier) {
            visitIdentifier(node)
            walkSymbolPrimitive(node.name)
            walkCaseSensitivity(node.case)
            walkMetas(node.metas)
        }
    
        open fun walkAssignment(node: PartiqlAst.Assignment) {
            visitAssignment(node)
            walkExpr(node.target)
            walkExpr(node.value)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Statement
        //////////////////////////////////////
        open fun walkStatement(node: PartiqlAst.Statement) {
            visitStatement(node)
            when(node) {
                is PartiqlAst.Statement.Query -> walkStatementQuery(node)
                is PartiqlAst.Statement.Dml -> walkStatementDml(node)
                is PartiqlAst.Statement.Ddl -> walkStatementDdl(node)
                is PartiqlAst.Statement.Exec -> walkStatementExec(node)
            }
        }
    
        open fun walkStatementQuery(node: PartiqlAst.Statement.Query) {
            visitStatementQuery(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkStatementDml(node: PartiqlAst.Statement.Dml) {
            visitStatementDml(node)
            walkDmlOpList(node.operations)
            node.from?.let { walkFromSource(it) }
            node.where?.let { walkExpr(it) }
            node.returning?.let { walkReturningExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkStatementDdl(node: PartiqlAst.Statement.Ddl) {
            visitStatementDdl(node)
            walkDdlOp(node.op)
            walkMetas(node.metas)
        }
    
        open fun walkStatementExec(node: PartiqlAst.Statement.Exec) {
            visitStatementExec(node)
            walkSymbolPrimitive(node.procedureName)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlAst.Expr) {
            visitExpr(node)
            when(node) {
                is PartiqlAst.Expr.Missing -> walkExprMissing(node)
                is PartiqlAst.Expr.Lit -> walkExprLit(node)
                is PartiqlAst.Expr.Id -> walkExprId(node)
                is PartiqlAst.Expr.Parameter -> walkExprParameter(node)
                is PartiqlAst.Expr.Not -> walkExprNot(node)
                is PartiqlAst.Expr.Pos -> walkExprPos(node)
                is PartiqlAst.Expr.Neg -> walkExprNeg(node)
                is PartiqlAst.Expr.Plus -> walkExprPlus(node)
                is PartiqlAst.Expr.Minus -> walkExprMinus(node)
                is PartiqlAst.Expr.Times -> walkExprTimes(node)
                is PartiqlAst.Expr.Divide -> walkExprDivide(node)
                is PartiqlAst.Expr.Modulo -> walkExprModulo(node)
                is PartiqlAst.Expr.Concat -> walkExprConcat(node)
                is PartiqlAst.Expr.And -> walkExprAnd(node)
                is PartiqlAst.Expr.Or -> walkExprOr(node)
                is PartiqlAst.Expr.Eq -> walkExprEq(node)
                is PartiqlAst.Expr.Ne -> walkExprNe(node)
                is PartiqlAst.Expr.Gt -> walkExprGt(node)
                is PartiqlAst.Expr.Gte -> walkExprGte(node)
                is PartiqlAst.Expr.Lt -> walkExprLt(node)
                is PartiqlAst.Expr.Lte -> walkExprLte(node)
                is PartiqlAst.Expr.Like -> walkExprLike(node)
                is PartiqlAst.Expr.Between -> walkExprBetween(node)
                is PartiqlAst.Expr.InCollection -> walkExprInCollection(node)
                is PartiqlAst.Expr.IsType -> walkExprIsType(node)
                is PartiqlAst.Expr.SimpleCase -> walkExprSimpleCase(node)
                is PartiqlAst.Expr.SearchedCase -> walkExprSearchedCase(node)
                is PartiqlAst.Expr.Struct -> walkExprStruct(node)
                is PartiqlAst.Expr.Bag -> walkExprBag(node)
                is PartiqlAst.Expr.List -> walkExprList(node)
                is PartiqlAst.Expr.Sexp -> walkExprSexp(node)
                is PartiqlAst.Expr.Date -> walkExprDate(node)
                is PartiqlAst.Expr.LitTime -> walkExprLitTime(node)
                is PartiqlAst.Expr.Union -> walkExprUnion(node)
                is PartiqlAst.Expr.Except -> walkExprExcept(node)
                is PartiqlAst.Expr.Intersect -> walkExprIntersect(node)
                is PartiqlAst.Expr.Path -> walkExprPath(node)
                is PartiqlAst.Expr.Call -> walkExprCall(node)
                is PartiqlAst.Expr.CallAgg -> walkExprCallAgg(node)
                is PartiqlAst.Expr.Cast -> walkExprCast(node)
                is PartiqlAst.Expr.CanCast -> walkExprCanCast(node)
                is PartiqlAst.Expr.CanLosslessCast -> walkExprCanLosslessCast(node)
                is PartiqlAst.Expr.NullIf -> walkExprNullIf(node)
                is PartiqlAst.Expr.Coalesce -> walkExprCoalesce(node)
                is PartiqlAst.Expr.Select -> walkExprSelect(node)
            }
        }
    
        open fun walkExprMissing(node: PartiqlAst.Expr.Missing) {
            visitExprMissing(node)
            walkMetas(node.metas)
        }
    
        open fun walkExprLit(node: PartiqlAst.Expr.Lit) {
            visitExprLit(node)
            walkAnyElement(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprId(node: PartiqlAst.Expr.Id) {
            visitExprId(node)
            walkSymbolPrimitive(node.name)
            walkCaseSensitivity(node.case)
            walkScopeQualifier(node.qualifier)
            walkMetas(node.metas)
        }
    
        open fun walkExprParameter(node: PartiqlAst.Expr.Parameter) {
            visitExprParameter(node)
            walkLongPrimitive(node.index)
            walkMetas(node.metas)
        }
    
        open fun walkExprNot(node: PartiqlAst.Expr.Not) {
            visitExprNot(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPos(node: PartiqlAst.Expr.Pos) {
            visitExprPos(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprNeg(node: PartiqlAst.Expr.Neg) {
            visitExprNeg(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkExprPlus(node: PartiqlAst.Expr.Plus) {
            visitExprPlus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprMinus(node: PartiqlAst.Expr.Minus) {
            visitExprMinus(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprTimes(node: PartiqlAst.Expr.Times) {
            visitExprTimes(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDivide(node: PartiqlAst.Expr.Divide) {
            visitExprDivide(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprModulo(node: PartiqlAst.Expr.Modulo) {
            visitExprModulo(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprConcat(node: PartiqlAst.Expr.Concat) {
            visitExprConcat(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprAnd(node: PartiqlAst.Expr.And) {
            visitExprAnd(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprOr(node: PartiqlAst.Expr.Or) {
            visitExprOr(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprEq(node: PartiqlAst.Expr.Eq) {
            visitExprEq(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprNe(node: PartiqlAst.Expr.Ne) {
            visitExprNe(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprGt(node: PartiqlAst.Expr.Gt) {
            visitExprGt(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprGte(node: PartiqlAst.Expr.Gte) {
            visitExprGte(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprLt(node: PartiqlAst.Expr.Lt) {
            visitExprLt(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprLte(node: PartiqlAst.Expr.Lte) {
            visitExprLte(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprLike(node: PartiqlAst.Expr.Like) {
            visitExprLike(node)
            walkExpr(node.value)
            walkExpr(node.pattern)
            node.escape?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprBetween(node: PartiqlAst.Expr.Between) {
            visitExprBetween(node)
            walkExpr(node.value)
            walkExpr(node.from)
            walkExpr(node.to)
            walkMetas(node.metas)
        }
    
        open fun walkExprInCollection(node: PartiqlAst.Expr.InCollection) {
            visitExprInCollection(node)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprIsType(node: PartiqlAst.Expr.IsType) {
            visitExprIsType(node)
            walkExpr(node.value)
            walkType(node.type)
            walkMetas(node.metas)
        }
    
        open fun walkExprSimpleCase(node: PartiqlAst.Expr.SimpleCase) {
            visitExprSimpleCase(node)
            walkExpr(node.expr)
            walkExprPairList(node.cases)
            node.default?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSearchedCase(node: PartiqlAst.Expr.SearchedCase) {
            visitExprSearchedCase(node)
            walkExprPairList(node.cases)
            node.default?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprStruct(node: PartiqlAst.Expr.Struct) {
            visitExprStruct(node)
            node.fields.map { walkExprPair(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprBag(node: PartiqlAst.Expr.Bag) {
            visitExprBag(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprList(node: PartiqlAst.Expr.List) {
            visitExprList(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSexp(node: PartiqlAst.Expr.Sexp) {
            visitExprSexp(node)
            node.values.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprDate(node: PartiqlAst.Expr.Date) {
            visitExprDate(node)
            walkLongPrimitive(node.year)
            walkLongPrimitive(node.month)
            walkLongPrimitive(node.day)
            walkMetas(node.metas)
        }
    
        open fun walkExprLitTime(node: PartiqlAst.Expr.LitTime) {
            visitExprLitTime(node)
            walkTimeValue(node.value)
            walkMetas(node.metas)
        }
    
        open fun walkExprUnion(node: PartiqlAst.Expr.Union) {
            visitExprUnion(node)
            walkSetQuantifier(node.setq)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprExcept(node: PartiqlAst.Expr.Except) {
            visitExprExcept(node)
            walkSetQuantifier(node.setq)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprIntersect(node: PartiqlAst.Expr.Intersect) {
            visitExprIntersect(node)
            walkSetQuantifier(node.setq)
            node.operands.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprPath(node: PartiqlAst.Expr.Path) {
            visitExprPath(node)
            walkExpr(node.root)
            node.steps.map { walkPathStep(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCall(node: PartiqlAst.Expr.Call) {
            visitExprCall(node)
            walkSymbolPrimitive(node.funcName)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprCallAgg(node: PartiqlAst.Expr.CallAgg) {
            visitExprCallAgg(node)
            walkSetQuantifier(node.setq)
            walkSymbolPrimitive(node.funcName)
            walkExpr(node.arg)
            walkMetas(node.metas)
        }
    
        open fun walkExprCast(node: PartiqlAst.Expr.Cast) {
            visitExprCast(node)
            walkExpr(node.value)
            walkType(node.asType)
            walkMetas(node.metas)
        }
    
        open fun walkExprCanCast(node: PartiqlAst.Expr.CanCast) {
            visitExprCanCast(node)
            walkExpr(node.value)
            walkType(node.asType)
            walkMetas(node.metas)
        }
    
        open fun walkExprCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast) {
            visitExprCanLosslessCast(node)
            walkExpr(node.value)
            walkType(node.asType)
            walkMetas(node.metas)
        }
    
        open fun walkExprNullIf(node: PartiqlAst.Expr.NullIf) {
            visitExprNullIf(node)
            walkExpr(node.expr1)
            walkExpr(node.expr2)
            walkMetas(node.metas)
        }
    
        open fun walkExprCoalesce(node: PartiqlAst.Expr.Coalesce) {
            visitExprCoalesce(node)
            node.args.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkExprSelect(node: PartiqlAst.Expr.Select) {
            visitExprSelect(node)
            node.setq?.let { walkSetQuantifier(it) }
            walkProjection(node.project)
            walkFromSource(node.from)
            node.fromLet?.let { walkLet(it) }
            node.where?.let { walkExpr(it) }
            node.group?.let { walkGroupBy(it) }
            node.having?.let { walkExpr(it) }
            node.order?.let { walkOrderBy(it) }
            node.limit?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: PathStep
        //////////////////////////////////////
        open fun walkPathStep(node: PartiqlAst.PathStep) {
            visitPathStep(node)
            when(node) {
                is PartiqlAst.PathStep.PathExpr -> walkPathStepPathExpr(node)
                is PartiqlAst.PathStep.PathWildcard -> walkPathStepPathWildcard(node)
                is PartiqlAst.PathStep.PathUnpivot -> walkPathStepPathUnpivot(node)
            }
        }
    
        open fun walkPathStepPathExpr(node: PartiqlAst.PathStep.PathExpr) {
            visitPathStepPathExpr(node)
            walkExpr(node.index)
            walkCaseSensitivity(node.case)
            walkMetas(node.metas)
        }
    
        open fun walkPathStepPathWildcard(node: PartiqlAst.PathStep.PathWildcard) {
            visitPathStepPathWildcard(node)
            walkMetas(node.metas)
        }
    
        open fun walkPathStepPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot) {
            visitPathStepPathUnpivot(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlAst.Projection) {
            visitProjection(node)
            when(node) {
                is PartiqlAst.Projection.ProjectStar -> walkProjectionProjectStar(node)
                is PartiqlAst.Projection.ProjectList -> walkProjectionProjectList(node)
                is PartiqlAst.Projection.ProjectPivot -> walkProjectionProjectPivot(node)
                is PartiqlAst.Projection.ProjectValue -> walkProjectionProjectValue(node)
            }
        }
    
        open fun walkProjectionProjectStar(node: PartiqlAst.Projection.ProjectStar) {
            visitProjectionProjectStar(node)
            walkMetas(node.metas)
        }
    
        open fun walkProjectionProjectList(node: PartiqlAst.Projection.ProjectList) {
            visitProjectionProjectList(node)
            node.projectItems.map { walkProjectItem(it) }
            walkMetas(node.metas)
        }
    
        open fun walkProjectionProjectPivot(node: PartiqlAst.Projection.ProjectPivot) {
            visitProjectionProjectPivot(node)
            walkExpr(node.value)
            walkExpr(node.key)
            walkMetas(node.metas)
        }
    
        open fun walkProjectionProjectValue(node: PartiqlAst.Projection.ProjectValue) {
            visitProjectionProjectValue(node)
            walkExpr(node.value)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlAst.ProjectItem) {
            visitProjectItem(node)
            when(node) {
                is PartiqlAst.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node)
                is PartiqlAst.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlAst.ProjectItem.ProjectAll) {
            visitProjectItemProjectAll(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr) {
            visitProjectItemProjectExpr(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlAst.FromSource) {
            visitFromSource(node)
            when(node) {
                is PartiqlAst.FromSource.Scan -> walkFromSourceScan(node)
                is PartiqlAst.FromSource.Unpivot -> walkFromSourceUnpivot(node)
                is PartiqlAst.FromSource.Join -> walkFromSourceJoin(node)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlAst.FromSource.Scan) {
            visitFromSourceScan(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            node.atAlias?.let { walkSymbolPrimitive(it) }
            node.byAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkFromSourceUnpivot(node: PartiqlAst.FromSource.Unpivot) {
            visitFromSourceUnpivot(node)
            walkExpr(node.expr)
            node.asAlias?.let { walkSymbolPrimitive(it) }
            node.atAlias?.let { walkSymbolPrimitive(it) }
            node.byAlias?.let { walkSymbolPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkFromSourceJoin(node: PartiqlAst.FromSource.Join) {
            visitFromSourceJoin(node)
            walkJoinType(node.type)
            walkFromSource(node.left)
            walkFromSource(node.right)
            node.predicate?.let { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlAst.JoinType) {
            visitJoinType(node)
            when(node) {
                is PartiqlAst.JoinType.Inner -> walkJoinTypeInner(node)
                is PartiqlAst.JoinType.Left -> walkJoinTypeLeft(node)
                is PartiqlAst.JoinType.Right -> walkJoinTypeRight(node)
                is PartiqlAst.JoinType.Full -> walkJoinTypeFull(node)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlAst.JoinType.Inner) {
            visitJoinTypeInner(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeLeft(node: PartiqlAst.JoinType.Left) {
            visitJoinTypeLeft(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeRight(node: PartiqlAst.JoinType.Right) {
            visitJoinTypeRight(node)
            walkMetas(node.metas)
        }
    
        open fun walkJoinTypeFull(node: PartiqlAst.JoinType.Full) {
            visitJoinTypeFull(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: GroupingStrategy
        //////////////////////////////////////
        open fun walkGroupingStrategy(node: PartiqlAst.GroupingStrategy) {
            visitGroupingStrategy(node)
            when(node) {
                is PartiqlAst.GroupingStrategy.GroupFull -> walkGroupingStrategyGroupFull(node)
                is PartiqlAst.GroupingStrategy.GroupPartial -> walkGroupingStrategyGroupPartial(node)
            }
        }
    
        open fun walkGroupingStrategyGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull) {
            visitGroupingStrategyGroupFull(node)
            walkMetas(node.metas)
        }
    
        open fun walkGroupingStrategyGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial) {
            visitGroupingStrategyGroupPartial(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: OrderingSpec
        //////////////////////////////////////
        open fun walkOrderingSpec(node: PartiqlAst.OrderingSpec) {
            visitOrderingSpec(node)
            when(node) {
                is PartiqlAst.OrderingSpec.Asc -> walkOrderingSpecAsc(node)
                is PartiqlAst.OrderingSpec.Desc -> walkOrderingSpecDesc(node)
            }
        }
    
        open fun walkOrderingSpecAsc(node: PartiqlAst.OrderingSpec.Asc) {
            visitOrderingSpecAsc(node)
            walkMetas(node.metas)
        }
    
        open fun walkOrderingSpecDesc(node: PartiqlAst.OrderingSpec.Desc) {
            visitOrderingSpecDesc(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlAst.CaseSensitivity) {
            visitCaseSensitivity(node)
            when(node) {
                is PartiqlAst.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node)
                is PartiqlAst.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive) {
            visitCaseSensitivityCaseSensitive(node)
            walkMetas(node.metas)
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive) {
            visitCaseSensitivityCaseInsensitive(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlAst.ScopeQualifier) {
            visitScopeQualifier(node)
            when(node) {
                is PartiqlAst.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node)
                is PartiqlAst.ScopeQualifier.LocalsFirst -> walkScopeQualifierLocalsFirst(node)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified) {
            visitScopeQualifierUnqualified(node)
            walkMetas(node.metas)
        }
    
        open fun walkScopeQualifierLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst) {
            visitScopeQualifierLocalsFirst(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlAst.SetQuantifier) {
            visitSetQuantifier(node)
            when(node) {
                is PartiqlAst.SetQuantifier.All -> walkSetQuantifierAll(node)
                is PartiqlAst.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlAst.SetQuantifier.All) {
            visitSetQuantifierAll(node)
            walkMetas(node.metas)
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlAst.SetQuantifier.Distinct) {
            visitSetQuantifierDistinct(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: DmlOp
        //////////////////////////////////////
        open fun walkDmlOp(node: PartiqlAst.DmlOp) {
            visitDmlOp(node)
            when(node) {
                is PartiqlAst.DmlOp.Insert -> walkDmlOpInsert(node)
                is PartiqlAst.DmlOp.InsertValue -> walkDmlOpInsertValue(node)
                is PartiqlAst.DmlOp.Set -> walkDmlOpSet(node)
                is PartiqlAst.DmlOp.Remove -> walkDmlOpRemove(node)
                is PartiqlAst.DmlOp.Delete -> walkDmlOpDelete(node)
            }
        }
    
        open fun walkDmlOpInsert(node: PartiqlAst.DmlOp.Insert) {
            visitDmlOpInsert(node)
            walkExpr(node.target)
            walkExpr(node.values)
            walkMetas(node.metas)
        }
    
        open fun walkDmlOpInsertValue(node: PartiqlAst.DmlOp.InsertValue) {
            visitDmlOpInsertValue(node)
            walkExpr(node.target)
            walkExpr(node.value)
            node.index?.let { walkExpr(it) }
            node.onConflict?.let { walkOnConflict(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDmlOpSet(node: PartiqlAst.DmlOp.Set) {
            visitDmlOpSet(node)
            walkAssignment(node.assignment)
            walkMetas(node.metas)
        }
    
        open fun walkDmlOpRemove(node: PartiqlAst.DmlOp.Remove) {
            visitDmlOpRemove(node)
            walkExpr(node.target)
            walkMetas(node.metas)
        }
    
        open fun walkDmlOpDelete(node: PartiqlAst.DmlOp.Delete) {
            visitDmlOpDelete(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ConflictAction
        //////////////////////////////////////
        open fun walkConflictAction(node: PartiqlAst.ConflictAction) {
            visitConflictAction(node)
            when(node) {
                is PartiqlAst.ConflictAction.DoNothing -> walkConflictActionDoNothing(node)
            }
        }
    
        open fun walkConflictActionDoNothing(node: PartiqlAst.ConflictAction.DoNothing) {
            visitConflictActionDoNothing(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: DdlOp
        //////////////////////////////////////
        open fun walkDdlOp(node: PartiqlAst.DdlOp) {
            visitDdlOp(node)
            when(node) {
                is PartiqlAst.DdlOp.CreateTable -> walkDdlOpCreateTable(node)
                is PartiqlAst.DdlOp.DropTable -> walkDdlOpDropTable(node)
                is PartiqlAst.DdlOp.UndropTable -> walkDdlOpUndropTable(node)
                is PartiqlAst.DdlOp.CreateIndex -> walkDdlOpCreateIndex(node)
                is PartiqlAst.DdlOp.DropIndex -> walkDdlOpDropIndex(node)
            }
        }
    
        open fun walkDdlOpCreateTable(node: PartiqlAst.DdlOp.CreateTable) {
            visitDdlOpCreateTable(node)
            walkSymbolPrimitive(node.tableName)
            walkMetas(node.metas)
        }
    
        open fun walkDdlOpDropTable(node: PartiqlAst.DdlOp.DropTable) {
            visitDdlOpDropTable(node)
            walkIdentifier(node.tableName)
            walkMetas(node.metas)
        }
    
        open fun walkDdlOpUndropTable(node: PartiqlAst.DdlOp.UndropTable) {
            visitDdlOpUndropTable(node)
            walkSymbolPrimitive(node.tableName)
            walkMetas(node.metas)
        }
    
        open fun walkDdlOpCreateIndex(node: PartiqlAst.DdlOp.CreateIndex) {
            visitDdlOpCreateIndex(node)
            walkIdentifier(node.indexName)
            node.fields.map { walkExpr(it) }
            walkMetas(node.metas)
        }
    
        open fun walkDdlOpDropIndex(node: PartiqlAst.DdlOp.DropIndex) {
            visitDdlOpDropIndex(node)
            walkIdentifier(node.table)
            walkIdentifier(node.keys)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ColumnComponent
        //////////////////////////////////////
        open fun walkColumnComponent(node: PartiqlAst.ColumnComponent) {
            visitColumnComponent(node)
            when(node) {
                is PartiqlAst.ColumnComponent.ReturningWildcard -> walkColumnComponentReturningWildcard(node)
                is PartiqlAst.ColumnComponent.ReturningColumn -> walkColumnComponentReturningColumn(node)
            }
        }
    
        open fun walkColumnComponentReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard) {
            visitColumnComponentReturningWildcard(node)
            walkMetas(node.metas)
        }
    
        open fun walkColumnComponentReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn) {
            visitColumnComponentReturningColumn(node)
            walkExpr(node.expr)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: ReturningMapping
        //////////////////////////////////////
        open fun walkReturningMapping(node: PartiqlAst.ReturningMapping) {
            visitReturningMapping(node)
            when(node) {
                is PartiqlAst.ReturningMapping.ModifiedNew -> walkReturningMappingModifiedNew(node)
                is PartiqlAst.ReturningMapping.ModifiedOld -> walkReturningMappingModifiedOld(node)
                is PartiqlAst.ReturningMapping.AllNew -> walkReturningMappingAllNew(node)
                is PartiqlAst.ReturningMapping.AllOld -> walkReturningMappingAllOld(node)
            }
        }
    
        open fun walkReturningMappingModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew) {
            visitReturningMappingModifiedNew(node)
            walkMetas(node.metas)
        }
    
        open fun walkReturningMappingModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld) {
            visitReturningMappingModifiedOld(node)
            walkMetas(node.metas)
        }
    
        open fun walkReturningMappingAllNew(node: PartiqlAst.ReturningMapping.AllNew) {
            visitReturningMappingAllNew(node)
            walkMetas(node.metas)
        }
    
        open fun walkReturningMappingAllOld(node: PartiqlAst.ReturningMapping.AllOld) {
            visitReturningMappingAllOld(node)
            walkMetas(node.metas)
        }
    
        //////////////////////////////////////
        // Sum Type: Type
        //////////////////////////////////////
        open fun walkType(node: PartiqlAst.Type) {
            visitType(node)
            when(node) {
                is PartiqlAst.Type.NullType -> walkTypeNullType(node)
                is PartiqlAst.Type.BooleanType -> walkTypeBooleanType(node)
                is PartiqlAst.Type.SmallintType -> walkTypeSmallintType(node)
                is PartiqlAst.Type.Integer4Type -> walkTypeInteger4Type(node)
                is PartiqlAst.Type.Integer8Type -> walkTypeInteger8Type(node)
                is PartiqlAst.Type.IntegerType -> walkTypeIntegerType(node)
                is PartiqlAst.Type.FloatType -> walkTypeFloatType(node)
                is PartiqlAst.Type.RealType -> walkTypeRealType(node)
                is PartiqlAst.Type.DoublePrecisionType -> walkTypeDoublePrecisionType(node)
                is PartiqlAst.Type.DecimalType -> walkTypeDecimalType(node)
                is PartiqlAst.Type.NumericType -> walkTypeNumericType(node)
                is PartiqlAst.Type.TimestampType -> walkTypeTimestampType(node)
                is PartiqlAst.Type.CharacterType -> walkTypeCharacterType(node)
                is PartiqlAst.Type.CharacterVaryingType -> walkTypeCharacterVaryingType(node)
                is PartiqlAst.Type.MissingType -> walkTypeMissingType(node)
                is PartiqlAst.Type.StringType -> walkTypeStringType(node)
                is PartiqlAst.Type.SymbolType -> walkTypeSymbolType(node)
                is PartiqlAst.Type.BlobType -> walkTypeBlobType(node)
                is PartiqlAst.Type.ClobType -> walkTypeClobType(node)
                is PartiqlAst.Type.DateType -> walkTypeDateType(node)
                is PartiqlAst.Type.TimeType -> walkTypeTimeType(node)
                is PartiqlAst.Type.TimeWithTimeZoneType -> walkTypeTimeWithTimeZoneType(node)
                is PartiqlAst.Type.StructType -> walkTypeStructType(node)
                is PartiqlAst.Type.TupleType -> walkTypeTupleType(node)
                is PartiqlAst.Type.ListType -> walkTypeListType(node)
                is PartiqlAst.Type.SexpType -> walkTypeSexpType(node)
                is PartiqlAst.Type.BagType -> walkTypeBagType(node)
                is PartiqlAst.Type.AnyType -> walkTypeAnyType(node)
                is PartiqlAst.Type.EsBoolean -> walkTypeEsBoolean(node)
                is PartiqlAst.Type.EsInteger -> walkTypeEsInteger(node)
                is PartiqlAst.Type.EsFloat -> walkTypeEsFloat(node)
                is PartiqlAst.Type.EsText -> walkTypeEsText(node)
                is PartiqlAst.Type.EsAny -> walkTypeEsAny(node)
                is PartiqlAst.Type.SparkShort -> walkTypeSparkShort(node)
                is PartiqlAst.Type.SparkInteger -> walkTypeSparkInteger(node)
                is PartiqlAst.Type.SparkLong -> walkTypeSparkLong(node)
                is PartiqlAst.Type.SparkDouble -> walkTypeSparkDouble(node)
                is PartiqlAst.Type.SparkBoolean -> walkTypeSparkBoolean(node)
                is PartiqlAst.Type.SparkFloat -> walkTypeSparkFloat(node)
                is PartiqlAst.Type.RsVarcharMax -> walkTypeRsVarcharMax(node)
                is PartiqlAst.Type.RsInteger -> walkTypeRsInteger(node)
                is PartiqlAst.Type.RsBigint -> walkTypeRsBigint(node)
                is PartiqlAst.Type.RsBoolean -> walkTypeRsBoolean(node)
                is PartiqlAst.Type.RsReal -> walkTypeRsReal(node)
                is PartiqlAst.Type.RsDoublePrecision -> walkTypeRsDoublePrecision(node)
                is PartiqlAst.Type.CustomType -> walkTypeCustomType(node)
            }
        }
    
        open fun walkTypeNullType(node: PartiqlAst.Type.NullType) {
            visitTypeNullType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeBooleanType(node: PartiqlAst.Type.BooleanType) {
            visitTypeBooleanType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSmallintType(node: PartiqlAst.Type.SmallintType) {
            visitTypeSmallintType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeInteger4Type(node: PartiqlAst.Type.Integer4Type) {
            visitTypeInteger4Type(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeInteger8Type(node: PartiqlAst.Type.Integer8Type) {
            visitTypeInteger8Type(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeIntegerType(node: PartiqlAst.Type.IntegerType) {
            visitTypeIntegerType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeFloatType(node: PartiqlAst.Type.FloatType) {
            visitTypeFloatType(node)
            node.precision?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeRealType(node: PartiqlAst.Type.RealType) {
            visitTypeRealType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType) {
            visitTypeDoublePrecisionType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeDecimalType(node: PartiqlAst.Type.DecimalType) {
            visitTypeDecimalType(node)
            node.precision?.let { walkLongPrimitive(it) }
            node.scale?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeNumericType(node: PartiqlAst.Type.NumericType) {
            visitTypeNumericType(node)
            node.precision?.let { walkLongPrimitive(it) }
            node.scale?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeTimestampType(node: PartiqlAst.Type.TimestampType) {
            visitTypeTimestampType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeCharacterType(node: PartiqlAst.Type.CharacterType) {
            visitTypeCharacterType(node)
            node.length?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType) {
            visitTypeCharacterVaryingType(node)
            node.length?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeMissingType(node: PartiqlAst.Type.MissingType) {
            visitTypeMissingType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeStringType(node: PartiqlAst.Type.StringType) {
            visitTypeStringType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSymbolType(node: PartiqlAst.Type.SymbolType) {
            visitTypeSymbolType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeBlobType(node: PartiqlAst.Type.BlobType) {
            visitTypeBlobType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeClobType(node: PartiqlAst.Type.ClobType) {
            visitTypeClobType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeDateType(node: PartiqlAst.Type.DateType) {
            visitTypeDateType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeTimeType(node: PartiqlAst.Type.TimeType) {
            visitTypeTimeType(node)
            node.precision?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType) {
            visitTypeTimeWithTimeZoneType(node)
            node.precision?.let { walkLongPrimitive(it) }
            walkMetas(node.metas)
        }
    
        open fun walkTypeStructType(node: PartiqlAst.Type.StructType) {
            visitTypeStructType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeTupleType(node: PartiqlAst.Type.TupleType) {
            visitTypeTupleType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeListType(node: PartiqlAst.Type.ListType) {
            visitTypeListType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSexpType(node: PartiqlAst.Type.SexpType) {
            visitTypeSexpType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeBagType(node: PartiqlAst.Type.BagType) {
            visitTypeBagType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeAnyType(node: PartiqlAst.Type.AnyType) {
            visitTypeAnyType(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeEsBoolean(node: PartiqlAst.Type.EsBoolean) {
            visitTypeEsBoolean(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeEsInteger(node: PartiqlAst.Type.EsInteger) {
            visitTypeEsInteger(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeEsFloat(node: PartiqlAst.Type.EsFloat) {
            visitTypeEsFloat(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeEsText(node: PartiqlAst.Type.EsText) {
            visitTypeEsText(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeEsAny(node: PartiqlAst.Type.EsAny) {
            visitTypeEsAny(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkShort(node: PartiqlAst.Type.SparkShort) {
            visitTypeSparkShort(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkInteger(node: PartiqlAst.Type.SparkInteger) {
            visitTypeSparkInteger(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkLong(node: PartiqlAst.Type.SparkLong) {
            visitTypeSparkLong(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkDouble(node: PartiqlAst.Type.SparkDouble) {
            visitTypeSparkDouble(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkBoolean(node: PartiqlAst.Type.SparkBoolean) {
            visitTypeSparkBoolean(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeSparkFloat(node: PartiqlAst.Type.SparkFloat) {
            visitTypeSparkFloat(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax) {
            visitTypeRsVarcharMax(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsInteger(node: PartiqlAst.Type.RsInteger) {
            visitTypeRsInteger(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsBigint(node: PartiqlAst.Type.RsBigint) {
            visitTypeRsBigint(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsBoolean(node: PartiqlAst.Type.RsBoolean) {
            visitTypeRsBoolean(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsReal(node: PartiqlAst.Type.RsReal) {
            visitTypeRsReal(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision) {
            visitTypeRsDoublePrecision(node)
            walkMetas(node.metas)
        }
    
        open fun walkTypeCustomType(node: PartiqlAst.Type.CustomType) {
            visitTypeCustomType(node)
            walkSymbolPrimitive(node.name)
            walkMetas(node.metas)
        }
    
    }
    
    
    open class VisitorFold<T> : DomainVisitorFoldBase<T>() {
        ////////////////////////////////////////////////////////////////////////////
        // Visit Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open protected fun visitTimeValue(node: PartiqlAst.TimeValue, accumulator: T): T = accumulator
        open protected fun visitLet(node: PartiqlAst.Let, accumulator: T): T = accumulator
        open protected fun visitLetBinding(node: PartiqlAst.LetBinding, accumulator: T): T = accumulator
        open protected fun visitExprPair(node: PartiqlAst.ExprPair, accumulator: T): T = accumulator
        open protected fun visitExprPairList(node: PartiqlAst.ExprPairList, accumulator: T): T = accumulator
        open protected fun visitGroupBy(node: PartiqlAst.GroupBy, accumulator: T): T = accumulator
        open protected fun visitGroupKeyList(node: PartiqlAst.GroupKeyList, accumulator: T): T = accumulator
        open protected fun visitGroupKey(node: PartiqlAst.GroupKey, accumulator: T): T = accumulator
        open protected fun visitOrderBy(node: PartiqlAst.OrderBy, accumulator: T): T = accumulator
        open protected fun visitSortSpec(node: PartiqlAst.SortSpec, accumulator: T): T = accumulator
        open protected fun visitDmlOpList(node: PartiqlAst.DmlOpList, accumulator: T): T = accumulator
        open protected fun visitOnConflict(node: PartiqlAst.OnConflict, accumulator: T): T = accumulator
        open protected fun visitReturningExpr(node: PartiqlAst.ReturningExpr, accumulator: T): T = accumulator
        open protected fun visitReturningElem(node: PartiqlAst.ReturningElem, accumulator: T): T = accumulator
        open protected fun visitIdentifier(node: PartiqlAst.Identifier, accumulator: T): T = accumulator
        open protected fun visitAssignment(node: PartiqlAst.Assignment, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Statement
        //////////////////////////////////////
        open protected fun visitStatement(node: PartiqlAst.Statement, accumulator: T): T = accumulator
        open protected fun visitStatementQuery(node: PartiqlAst.Statement.Query, accumulator: T): T = accumulator
        open protected fun visitStatementDml(node: PartiqlAst.Statement.Dml, accumulator: T): T = accumulator
        open protected fun visitStatementDdl(node: PartiqlAst.Statement.Ddl, accumulator: T): T = accumulator
        open protected fun visitStatementExec(node: PartiqlAst.Statement.Exec, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open protected fun visitExpr(node: PartiqlAst.Expr, accumulator: T): T = accumulator
        open protected fun visitExprMissing(node: PartiqlAst.Expr.Missing, accumulator: T): T = accumulator
        open protected fun visitExprLit(node: PartiqlAst.Expr.Lit, accumulator: T): T = accumulator
        open protected fun visitExprId(node: PartiqlAst.Expr.Id, accumulator: T): T = accumulator
        open protected fun visitExprParameter(node: PartiqlAst.Expr.Parameter, accumulator: T): T = accumulator
        open protected fun visitExprNot(node: PartiqlAst.Expr.Not, accumulator: T): T = accumulator
        open protected fun visitExprPos(node: PartiqlAst.Expr.Pos, accumulator: T): T = accumulator
        open protected fun visitExprNeg(node: PartiqlAst.Expr.Neg, accumulator: T): T = accumulator
        open protected fun visitExprPlus(node: PartiqlAst.Expr.Plus, accumulator: T): T = accumulator
        open protected fun visitExprMinus(node: PartiqlAst.Expr.Minus, accumulator: T): T = accumulator
        open protected fun visitExprTimes(node: PartiqlAst.Expr.Times, accumulator: T): T = accumulator
        open protected fun visitExprDivide(node: PartiqlAst.Expr.Divide, accumulator: T): T = accumulator
        open protected fun visitExprModulo(node: PartiqlAst.Expr.Modulo, accumulator: T): T = accumulator
        open protected fun visitExprConcat(node: PartiqlAst.Expr.Concat, accumulator: T): T = accumulator
        open protected fun visitExprAnd(node: PartiqlAst.Expr.And, accumulator: T): T = accumulator
        open protected fun visitExprOr(node: PartiqlAst.Expr.Or, accumulator: T): T = accumulator
        open protected fun visitExprEq(node: PartiqlAst.Expr.Eq, accumulator: T): T = accumulator
        open protected fun visitExprNe(node: PartiqlAst.Expr.Ne, accumulator: T): T = accumulator
        open protected fun visitExprGt(node: PartiqlAst.Expr.Gt, accumulator: T): T = accumulator
        open protected fun visitExprGte(node: PartiqlAst.Expr.Gte, accumulator: T): T = accumulator
        open protected fun visitExprLt(node: PartiqlAst.Expr.Lt, accumulator: T): T = accumulator
        open protected fun visitExprLte(node: PartiqlAst.Expr.Lte, accumulator: T): T = accumulator
        open protected fun visitExprLike(node: PartiqlAst.Expr.Like, accumulator: T): T = accumulator
        open protected fun visitExprBetween(node: PartiqlAst.Expr.Between, accumulator: T): T = accumulator
        open protected fun visitExprInCollection(node: PartiqlAst.Expr.InCollection, accumulator: T): T = accumulator
        open protected fun visitExprIsType(node: PartiqlAst.Expr.IsType, accumulator: T): T = accumulator
        open protected fun visitExprSimpleCase(node: PartiqlAst.Expr.SimpleCase, accumulator: T): T = accumulator
        open protected fun visitExprSearchedCase(node: PartiqlAst.Expr.SearchedCase, accumulator: T): T = accumulator
        open protected fun visitExprStruct(node: PartiqlAst.Expr.Struct, accumulator: T): T = accumulator
        open protected fun visitExprBag(node: PartiqlAst.Expr.Bag, accumulator: T): T = accumulator
        open protected fun visitExprList(node: PartiqlAst.Expr.List, accumulator: T): T = accumulator
        open protected fun visitExprSexp(node: PartiqlAst.Expr.Sexp, accumulator: T): T = accumulator
        open protected fun visitExprDate(node: PartiqlAst.Expr.Date, accumulator: T): T = accumulator
        open protected fun visitExprLitTime(node: PartiqlAst.Expr.LitTime, accumulator: T): T = accumulator
        open protected fun visitExprUnion(node: PartiqlAst.Expr.Union, accumulator: T): T = accumulator
        open protected fun visitExprExcept(node: PartiqlAst.Expr.Except, accumulator: T): T = accumulator
        open protected fun visitExprIntersect(node: PartiqlAst.Expr.Intersect, accumulator: T): T = accumulator
        open protected fun visitExprPath(node: PartiqlAst.Expr.Path, accumulator: T): T = accumulator
        open protected fun visitExprCall(node: PartiqlAst.Expr.Call, accumulator: T): T = accumulator
        open protected fun visitExprCallAgg(node: PartiqlAst.Expr.CallAgg, accumulator: T): T = accumulator
        open protected fun visitExprCast(node: PartiqlAst.Expr.Cast, accumulator: T): T = accumulator
        open protected fun visitExprCanCast(node: PartiqlAst.Expr.CanCast, accumulator: T): T = accumulator
        open protected fun visitExprCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast, accumulator: T): T = accumulator
        open protected fun visitExprNullIf(node: PartiqlAst.Expr.NullIf, accumulator: T): T = accumulator
        open protected fun visitExprCoalesce(node: PartiqlAst.Expr.Coalesce, accumulator: T): T = accumulator
        open protected fun visitExprSelect(node: PartiqlAst.Expr.Select, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: PathStep
        //////////////////////////////////////
        open protected fun visitPathStep(node: PartiqlAst.PathStep, accumulator: T): T = accumulator
        open protected fun visitPathStepPathExpr(node: PartiqlAst.PathStep.PathExpr, accumulator: T): T = accumulator
        open protected fun visitPathStepPathWildcard(node: PartiqlAst.PathStep.PathWildcard, accumulator: T): T = accumulator
        open protected fun visitPathStepPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open protected fun visitProjection(node: PartiqlAst.Projection, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectStar(node: PartiqlAst.Projection.ProjectStar, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectList(node: PartiqlAst.Projection.ProjectList, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectPivot(node: PartiqlAst.Projection.ProjectPivot, accumulator: T): T = accumulator
        open protected fun visitProjectionProjectValue(node: PartiqlAst.Projection.ProjectValue, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open protected fun visitProjectItem(node: PartiqlAst.ProjectItem, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectAll(node: PartiqlAst.ProjectItem.ProjectAll, accumulator: T): T = accumulator
        open protected fun visitProjectItemProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open protected fun visitFromSource(node: PartiqlAst.FromSource, accumulator: T): T = accumulator
        open protected fun visitFromSourceScan(node: PartiqlAst.FromSource.Scan, accumulator: T): T = accumulator
        open protected fun visitFromSourceUnpivot(node: PartiqlAst.FromSource.Unpivot, accumulator: T): T = accumulator
        open protected fun visitFromSourceJoin(node: PartiqlAst.FromSource.Join, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open protected fun visitJoinType(node: PartiqlAst.JoinType, accumulator: T): T = accumulator
        open protected fun visitJoinTypeInner(node: PartiqlAst.JoinType.Inner, accumulator: T): T = accumulator
        open protected fun visitJoinTypeLeft(node: PartiqlAst.JoinType.Left, accumulator: T): T = accumulator
        open protected fun visitJoinTypeRight(node: PartiqlAst.JoinType.Right, accumulator: T): T = accumulator
        open protected fun visitJoinTypeFull(node: PartiqlAst.JoinType.Full, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: GroupingStrategy
        //////////////////////////////////////
        open protected fun visitGroupingStrategy(node: PartiqlAst.GroupingStrategy, accumulator: T): T = accumulator
        open protected fun visitGroupingStrategyGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull, accumulator: T): T = accumulator
        open protected fun visitGroupingStrategyGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: OrderingSpec
        //////////////////////////////////////
        open protected fun visitOrderingSpec(node: PartiqlAst.OrderingSpec, accumulator: T): T = accumulator
        open protected fun visitOrderingSpecAsc(node: PartiqlAst.OrderingSpec.Asc, accumulator: T): T = accumulator
        open protected fun visitOrderingSpecDesc(node: PartiqlAst.OrderingSpec.Desc, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open protected fun visitCaseSensitivity(node: PartiqlAst.CaseSensitivity, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive, accumulator: T): T = accumulator
        open protected fun visitCaseSensitivityCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open protected fun visitScopeQualifier(node: PartiqlAst.ScopeQualifier, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified, accumulator: T): T = accumulator
        open protected fun visitScopeQualifierLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open protected fun visitSetQuantifier(node: PartiqlAst.SetQuantifier, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierAll(node: PartiqlAst.SetQuantifier.All, accumulator: T): T = accumulator
        open protected fun visitSetQuantifierDistinct(node: PartiqlAst.SetQuantifier.Distinct, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: DmlOp
        //////////////////////////////////////
        open protected fun visitDmlOp(node: PartiqlAst.DmlOp, accumulator: T): T = accumulator
        open protected fun visitDmlOpInsert(node: PartiqlAst.DmlOp.Insert, accumulator: T): T = accumulator
        open protected fun visitDmlOpInsertValue(node: PartiqlAst.DmlOp.InsertValue, accumulator: T): T = accumulator
        open protected fun visitDmlOpSet(node: PartiqlAst.DmlOp.Set, accumulator: T): T = accumulator
        open protected fun visitDmlOpRemove(node: PartiqlAst.DmlOp.Remove, accumulator: T): T = accumulator
        open protected fun visitDmlOpDelete(node: PartiqlAst.DmlOp.Delete, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ConflictAction
        //////////////////////////////////////
        open protected fun visitConflictAction(node: PartiqlAst.ConflictAction, accumulator: T): T = accumulator
        open protected fun visitConflictActionDoNothing(node: PartiqlAst.ConflictAction.DoNothing, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: DdlOp
        //////////////////////////////////////
        open protected fun visitDdlOp(node: PartiqlAst.DdlOp, accumulator: T): T = accumulator
        open protected fun visitDdlOpCreateTable(node: PartiqlAst.DdlOp.CreateTable, accumulator: T): T = accumulator
        open protected fun visitDdlOpDropTable(node: PartiqlAst.DdlOp.DropTable, accumulator: T): T = accumulator
        open protected fun visitDdlOpUndropTable(node: PartiqlAst.DdlOp.UndropTable, accumulator: T): T = accumulator
        open protected fun visitDdlOpCreateIndex(node: PartiqlAst.DdlOp.CreateIndex, accumulator: T): T = accumulator
        open protected fun visitDdlOpDropIndex(node: PartiqlAst.DdlOp.DropIndex, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ColumnComponent
        //////////////////////////////////////
        open protected fun visitColumnComponent(node: PartiqlAst.ColumnComponent, accumulator: T): T = accumulator
        open protected fun visitColumnComponentReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard, accumulator: T): T = accumulator
        open protected fun visitColumnComponentReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: ReturningMapping
        //////////////////////////////////////
        open protected fun visitReturningMapping(node: PartiqlAst.ReturningMapping, accumulator: T): T = accumulator
        open protected fun visitReturningMappingModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew, accumulator: T): T = accumulator
        open protected fun visitReturningMappingModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld, accumulator: T): T = accumulator
        open protected fun visitReturningMappingAllNew(node: PartiqlAst.ReturningMapping.AllNew, accumulator: T): T = accumulator
        open protected fun visitReturningMappingAllOld(node: PartiqlAst.ReturningMapping.AllOld, accumulator: T): T = accumulator
        //////////////////////////////////////
        // Sum Type: Type
        //////////////////////////////////////
        open protected fun visitType(node: PartiqlAst.Type, accumulator: T): T = accumulator
        open protected fun visitTypeNullType(node: PartiqlAst.Type.NullType, accumulator: T): T = accumulator
        open protected fun visitTypeBooleanType(node: PartiqlAst.Type.BooleanType, accumulator: T): T = accumulator
        open protected fun visitTypeSmallintType(node: PartiqlAst.Type.SmallintType, accumulator: T): T = accumulator
        open protected fun visitTypeInteger4Type(node: PartiqlAst.Type.Integer4Type, accumulator: T): T = accumulator
        open protected fun visitTypeInteger8Type(node: PartiqlAst.Type.Integer8Type, accumulator: T): T = accumulator
        open protected fun visitTypeIntegerType(node: PartiqlAst.Type.IntegerType, accumulator: T): T = accumulator
        open protected fun visitTypeFloatType(node: PartiqlAst.Type.FloatType, accumulator: T): T = accumulator
        open protected fun visitTypeRealType(node: PartiqlAst.Type.RealType, accumulator: T): T = accumulator
        open protected fun visitTypeDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType, accumulator: T): T = accumulator
        open protected fun visitTypeDecimalType(node: PartiqlAst.Type.DecimalType, accumulator: T): T = accumulator
        open protected fun visitTypeNumericType(node: PartiqlAst.Type.NumericType, accumulator: T): T = accumulator
        open protected fun visitTypeTimestampType(node: PartiqlAst.Type.TimestampType, accumulator: T): T = accumulator
        open protected fun visitTypeCharacterType(node: PartiqlAst.Type.CharacterType, accumulator: T): T = accumulator
        open protected fun visitTypeCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType, accumulator: T): T = accumulator
        open protected fun visitTypeMissingType(node: PartiqlAst.Type.MissingType, accumulator: T): T = accumulator
        open protected fun visitTypeStringType(node: PartiqlAst.Type.StringType, accumulator: T): T = accumulator
        open protected fun visitTypeSymbolType(node: PartiqlAst.Type.SymbolType, accumulator: T): T = accumulator
        open protected fun visitTypeBlobType(node: PartiqlAst.Type.BlobType, accumulator: T): T = accumulator
        open protected fun visitTypeClobType(node: PartiqlAst.Type.ClobType, accumulator: T): T = accumulator
        open protected fun visitTypeDateType(node: PartiqlAst.Type.DateType, accumulator: T): T = accumulator
        open protected fun visitTypeTimeType(node: PartiqlAst.Type.TimeType, accumulator: T): T = accumulator
        open protected fun visitTypeTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType, accumulator: T): T = accumulator
        open protected fun visitTypeStructType(node: PartiqlAst.Type.StructType, accumulator: T): T = accumulator
        open protected fun visitTypeTupleType(node: PartiqlAst.Type.TupleType, accumulator: T): T = accumulator
        open protected fun visitTypeListType(node: PartiqlAst.Type.ListType, accumulator: T): T = accumulator
        open protected fun visitTypeSexpType(node: PartiqlAst.Type.SexpType, accumulator: T): T = accumulator
        open protected fun visitTypeBagType(node: PartiqlAst.Type.BagType, accumulator: T): T = accumulator
        open protected fun visitTypeAnyType(node: PartiqlAst.Type.AnyType, accumulator: T): T = accumulator
        open protected fun visitTypeEsBoolean(node: PartiqlAst.Type.EsBoolean, accumulator: T): T = accumulator
        open protected fun visitTypeEsInteger(node: PartiqlAst.Type.EsInteger, accumulator: T): T = accumulator
        open protected fun visitTypeEsFloat(node: PartiqlAst.Type.EsFloat, accumulator: T): T = accumulator
        open protected fun visitTypeEsText(node: PartiqlAst.Type.EsText, accumulator: T): T = accumulator
        open protected fun visitTypeEsAny(node: PartiqlAst.Type.EsAny, accumulator: T): T = accumulator
        open protected fun visitTypeSparkShort(node: PartiqlAst.Type.SparkShort, accumulator: T): T = accumulator
        open protected fun visitTypeSparkInteger(node: PartiqlAst.Type.SparkInteger, accumulator: T): T = accumulator
        open protected fun visitTypeSparkLong(node: PartiqlAst.Type.SparkLong, accumulator: T): T = accumulator
        open protected fun visitTypeSparkDouble(node: PartiqlAst.Type.SparkDouble, accumulator: T): T = accumulator
        open protected fun visitTypeSparkBoolean(node: PartiqlAst.Type.SparkBoolean, accumulator: T): T = accumulator
        open protected fun visitTypeSparkFloat(node: PartiqlAst.Type.SparkFloat, accumulator: T): T = accumulator
        open protected fun visitTypeRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax, accumulator: T): T = accumulator
        open protected fun visitTypeRsInteger(node: PartiqlAst.Type.RsInteger, accumulator: T): T = accumulator
        open protected fun visitTypeRsBigint(node: PartiqlAst.Type.RsBigint, accumulator: T): T = accumulator
        open protected fun visitTypeRsBoolean(node: PartiqlAst.Type.RsBoolean, accumulator: T): T = accumulator
        open protected fun visitTypeRsReal(node: PartiqlAst.Type.RsReal, accumulator: T): T = accumulator
        open protected fun visitTypeRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision, accumulator: T): T = accumulator
        open protected fun visitTypeCustomType(node: PartiqlAst.Type.CustomType, accumulator: T): T = accumulator
    
        ////////////////////////////////////////////////////////////////////////////
        // Walk Functions
        ////////////////////////////////////////////////////////////////////////////
    
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        open fun walkTimeValue(node: PartiqlAst.TimeValue, accumulator: T): T {
            var current = accumulator
            current = visitTimeValue(node, current)
            current = walkLongPrimitive(node.hour, current)
            current = walkLongPrimitive(node.minute, current)
            current = walkLongPrimitive(node.second, current)
            current = walkLongPrimitive(node.nano, current)
            current = walkLongPrimitive(node.precision, current)
            node.tzMinutes?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkLet(node: PartiqlAst.Let, accumulator: T): T {
            var current = accumulator
            current = visitLet(node, current)
            node.letBindings.map { current = walkLetBinding(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkLetBinding(node: PartiqlAst.LetBinding, accumulator: T): T {
            var current = accumulator
            current = visitLetBinding(node, current)
            current = walkExpr(node.expr, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPair(node: PartiqlAst.ExprPair, accumulator: T): T {
            var current = accumulator
            current = visitExprPair(node, current)
            current = walkExpr(node.first, current)
            current = walkExpr(node.second, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPairList(node: PartiqlAst.ExprPairList, accumulator: T): T {
            var current = accumulator
            current = visitExprPairList(node, current)
            node.pairs.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupBy(node: PartiqlAst.GroupBy, accumulator: T): T {
            var current = accumulator
            current = visitGroupBy(node, current)
            current = walkGroupingStrategy(node.strategy, current)
            current = walkGroupKeyList(node.keyList, current)
            node.groupAsAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupKeyList(node: PartiqlAst.GroupKeyList, accumulator: T): T {
            var current = accumulator
            current = visitGroupKeyList(node, current)
            node.keys.map { current = walkGroupKey(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupKey(node: PartiqlAst.GroupKey, accumulator: T): T {
            var current = accumulator
            current = visitGroupKey(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOrderBy(node: PartiqlAst.OrderBy, accumulator: T): T {
            var current = accumulator
            current = visitOrderBy(node, current)
            node.sortSpecs.map { current = walkSortSpec(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSortSpec(node: PartiqlAst.SortSpec, accumulator: T): T {
            var current = accumulator
            current = visitSortSpec(node, current)
            current = walkExpr(node.expr, current)
            node.orderingSpec?.let { current = walkOrderingSpec(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDmlOpList(node: PartiqlAst.DmlOpList, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpList(node, current)
            node.ops.map { current = walkDmlOp(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOnConflict(node: PartiqlAst.OnConflict, accumulator: T): T {
            var current = accumulator
            current = visitOnConflict(node, current)
            current = walkExpr(node.expr, current)
            current = walkConflictAction(node.conflictAction, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkReturningExpr(node: PartiqlAst.ReturningExpr, accumulator: T): T {
            var current = accumulator
            current = visitReturningExpr(node, current)
            node.elems.map { current = walkReturningElem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkReturningElem(node: PartiqlAst.ReturningElem, accumulator: T): T {
            var current = accumulator
            current = visitReturningElem(node, current)
            current = walkReturningMapping(node.mapping, current)
            current = walkColumnComponent(node.column, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkIdentifier(node: PartiqlAst.Identifier, accumulator: T): T {
            var current = accumulator
            current = visitIdentifier(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkCaseSensitivity(node.case, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkAssignment(node: PartiqlAst.Assignment, accumulator: T): T {
            var current = accumulator
            current = visitAssignment(node, current)
            current = walkExpr(node.target, current)
            current = walkExpr(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Statement
        //////////////////////////////////////
        open fun walkStatement(node: PartiqlAst.Statement, accumulator: T): T {
            val current = visitStatement(node, accumulator)
            return when(node) {
                is PartiqlAst.Statement.Query -> walkStatementQuery(node, current)
                is PartiqlAst.Statement.Dml -> walkStatementDml(node, current)
                is PartiqlAst.Statement.Ddl -> walkStatementDdl(node, current)
                is PartiqlAst.Statement.Exec -> walkStatementExec(node, current)
            }
        }
    
        open fun walkStatementQuery(node: PartiqlAst.Statement.Query, accumulator: T): T {
            var current = accumulator
            current = visitStatementQuery(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkStatementDml(node: PartiqlAst.Statement.Dml, accumulator: T): T {
            var current = accumulator
            current = visitStatementDml(node, current)
            current = walkDmlOpList(node.operations, current)
            node.from?.let { current = walkFromSource(it, current) }
            node.where?.let { current = walkExpr(it, current) }
            node.returning?.let { current = walkReturningExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkStatementDdl(node: PartiqlAst.Statement.Ddl, accumulator: T): T {
            var current = accumulator
            current = visitStatementDdl(node, current)
            current = walkDdlOp(node.op, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkStatementExec(node: PartiqlAst.Statement.Exec, accumulator: T): T {
            var current = accumulator
            current = visitStatementExec(node, current)
            current = walkSymbolPrimitive(node.procedureName, current)
            node.args.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun walkExpr(node: PartiqlAst.Expr, accumulator: T): T {
            val current = visitExpr(node, accumulator)
            return when(node) {
                is PartiqlAst.Expr.Missing -> walkExprMissing(node, current)
                is PartiqlAst.Expr.Lit -> walkExprLit(node, current)
                is PartiqlAst.Expr.Id -> walkExprId(node, current)
                is PartiqlAst.Expr.Parameter -> walkExprParameter(node, current)
                is PartiqlAst.Expr.Not -> walkExprNot(node, current)
                is PartiqlAst.Expr.Pos -> walkExprPos(node, current)
                is PartiqlAst.Expr.Neg -> walkExprNeg(node, current)
                is PartiqlAst.Expr.Plus -> walkExprPlus(node, current)
                is PartiqlAst.Expr.Minus -> walkExprMinus(node, current)
                is PartiqlAst.Expr.Times -> walkExprTimes(node, current)
                is PartiqlAst.Expr.Divide -> walkExprDivide(node, current)
                is PartiqlAst.Expr.Modulo -> walkExprModulo(node, current)
                is PartiqlAst.Expr.Concat -> walkExprConcat(node, current)
                is PartiqlAst.Expr.And -> walkExprAnd(node, current)
                is PartiqlAst.Expr.Or -> walkExprOr(node, current)
                is PartiqlAst.Expr.Eq -> walkExprEq(node, current)
                is PartiqlAst.Expr.Ne -> walkExprNe(node, current)
                is PartiqlAst.Expr.Gt -> walkExprGt(node, current)
                is PartiqlAst.Expr.Gte -> walkExprGte(node, current)
                is PartiqlAst.Expr.Lt -> walkExprLt(node, current)
                is PartiqlAst.Expr.Lte -> walkExprLte(node, current)
                is PartiqlAst.Expr.Like -> walkExprLike(node, current)
                is PartiqlAst.Expr.Between -> walkExprBetween(node, current)
                is PartiqlAst.Expr.InCollection -> walkExprInCollection(node, current)
                is PartiqlAst.Expr.IsType -> walkExprIsType(node, current)
                is PartiqlAst.Expr.SimpleCase -> walkExprSimpleCase(node, current)
                is PartiqlAst.Expr.SearchedCase -> walkExprSearchedCase(node, current)
                is PartiqlAst.Expr.Struct -> walkExprStruct(node, current)
                is PartiqlAst.Expr.Bag -> walkExprBag(node, current)
                is PartiqlAst.Expr.List -> walkExprList(node, current)
                is PartiqlAst.Expr.Sexp -> walkExprSexp(node, current)
                is PartiqlAst.Expr.Date -> walkExprDate(node, current)
                is PartiqlAst.Expr.LitTime -> walkExprLitTime(node, current)
                is PartiqlAst.Expr.Union -> walkExprUnion(node, current)
                is PartiqlAst.Expr.Except -> walkExprExcept(node, current)
                is PartiqlAst.Expr.Intersect -> walkExprIntersect(node, current)
                is PartiqlAst.Expr.Path -> walkExprPath(node, current)
                is PartiqlAst.Expr.Call -> walkExprCall(node, current)
                is PartiqlAst.Expr.CallAgg -> walkExprCallAgg(node, current)
                is PartiqlAst.Expr.Cast -> walkExprCast(node, current)
                is PartiqlAst.Expr.CanCast -> walkExprCanCast(node, current)
                is PartiqlAst.Expr.CanLosslessCast -> walkExprCanLosslessCast(node, current)
                is PartiqlAst.Expr.NullIf -> walkExprNullIf(node, current)
                is PartiqlAst.Expr.Coalesce -> walkExprCoalesce(node, current)
                is PartiqlAst.Expr.Select -> walkExprSelect(node, current)
            }
        }
    
        open fun walkExprMissing(node: PartiqlAst.Expr.Missing, accumulator: T): T {
            var current = accumulator
            current = visitExprMissing(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLit(node: PartiqlAst.Expr.Lit, accumulator: T): T {
            var current = accumulator
            current = visitExprLit(node, current)
            current = walkAnyElement(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprId(node: PartiqlAst.Expr.Id, accumulator: T): T {
            var current = accumulator
            current = visitExprId(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkCaseSensitivity(node.case, current)
            current = walkScopeQualifier(node.qualifier, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprParameter(node: PartiqlAst.Expr.Parameter, accumulator: T): T {
            var current = accumulator
            current = visitExprParameter(node, current)
            current = walkLongPrimitive(node.index, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNot(node: PartiqlAst.Expr.Not, accumulator: T): T {
            var current = accumulator
            current = visitExprNot(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPos(node: PartiqlAst.Expr.Pos, accumulator: T): T {
            var current = accumulator
            current = visitExprPos(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNeg(node: PartiqlAst.Expr.Neg, accumulator: T): T {
            var current = accumulator
            current = visitExprNeg(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPlus(node: PartiqlAst.Expr.Plus, accumulator: T): T {
            var current = accumulator
            current = visitExprPlus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprMinus(node: PartiqlAst.Expr.Minus, accumulator: T): T {
            var current = accumulator
            current = visitExprMinus(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprTimes(node: PartiqlAst.Expr.Times, accumulator: T): T {
            var current = accumulator
            current = visitExprTimes(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDivide(node: PartiqlAst.Expr.Divide, accumulator: T): T {
            var current = accumulator
            current = visitExprDivide(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprModulo(node: PartiqlAst.Expr.Modulo, accumulator: T): T {
            var current = accumulator
            current = visitExprModulo(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprConcat(node: PartiqlAst.Expr.Concat, accumulator: T): T {
            var current = accumulator
            current = visitExprConcat(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprAnd(node: PartiqlAst.Expr.And, accumulator: T): T {
            var current = accumulator
            current = visitExprAnd(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprOr(node: PartiqlAst.Expr.Or, accumulator: T): T {
            var current = accumulator
            current = visitExprOr(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprEq(node: PartiqlAst.Expr.Eq, accumulator: T): T {
            var current = accumulator
            current = visitExprEq(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNe(node: PartiqlAst.Expr.Ne, accumulator: T): T {
            var current = accumulator
            current = visitExprNe(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprGt(node: PartiqlAst.Expr.Gt, accumulator: T): T {
            var current = accumulator
            current = visitExprGt(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprGte(node: PartiqlAst.Expr.Gte, accumulator: T): T {
            var current = accumulator
            current = visitExprGte(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLt(node: PartiqlAst.Expr.Lt, accumulator: T): T {
            var current = accumulator
            current = visitExprLt(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLte(node: PartiqlAst.Expr.Lte, accumulator: T): T {
            var current = accumulator
            current = visitExprLte(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLike(node: PartiqlAst.Expr.Like, accumulator: T): T {
            var current = accumulator
            current = visitExprLike(node, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.pattern, current)
            node.escape?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBetween(node: PartiqlAst.Expr.Between, accumulator: T): T {
            var current = accumulator
            current = visitExprBetween(node, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.from, current)
            current = walkExpr(node.to, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprInCollection(node: PartiqlAst.Expr.InCollection, accumulator: T): T {
            var current = accumulator
            current = visitExprInCollection(node, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprIsType(node: PartiqlAst.Expr.IsType, accumulator: T): T {
            var current = accumulator
            current = visitExprIsType(node, current)
            current = walkExpr(node.value, current)
            current = walkType(node.type, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSimpleCase(node: PartiqlAst.Expr.SimpleCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSimpleCase(node, current)
            current = walkExpr(node.expr, current)
            current = walkExprPairList(node.cases, current)
            node.default?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSearchedCase(node: PartiqlAst.Expr.SearchedCase, accumulator: T): T {
            var current = accumulator
            current = visitExprSearchedCase(node, current)
            current = walkExprPairList(node.cases, current)
            node.default?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprStruct(node: PartiqlAst.Expr.Struct, accumulator: T): T {
            var current = accumulator
            current = visitExprStruct(node, current)
            node.fields.map { current = walkExprPair(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprBag(node: PartiqlAst.Expr.Bag, accumulator: T): T {
            var current = accumulator
            current = visitExprBag(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprList(node: PartiqlAst.Expr.List, accumulator: T): T {
            var current = accumulator
            current = visitExprList(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSexp(node: PartiqlAst.Expr.Sexp, accumulator: T): T {
            var current = accumulator
            current = visitExprSexp(node, current)
            node.values.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprDate(node: PartiqlAst.Expr.Date, accumulator: T): T {
            var current = accumulator
            current = visitExprDate(node, current)
            current = walkLongPrimitive(node.year, current)
            current = walkLongPrimitive(node.month, current)
            current = walkLongPrimitive(node.day, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprLitTime(node: PartiqlAst.Expr.LitTime, accumulator: T): T {
            var current = accumulator
            current = visitExprLitTime(node, current)
            current = walkTimeValue(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprUnion(node: PartiqlAst.Expr.Union, accumulator: T): T {
            var current = accumulator
            current = visitExprUnion(node, current)
            current = walkSetQuantifier(node.setq, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprExcept(node: PartiqlAst.Expr.Except, accumulator: T): T {
            var current = accumulator
            current = visitExprExcept(node, current)
            current = walkSetQuantifier(node.setq, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprIntersect(node: PartiqlAst.Expr.Intersect, accumulator: T): T {
            var current = accumulator
            current = visitExprIntersect(node, current)
            current = walkSetQuantifier(node.setq, current)
            node.operands.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprPath(node: PartiqlAst.Expr.Path, accumulator: T): T {
            var current = accumulator
            current = visitExprPath(node, current)
            current = walkExpr(node.root, current)
            node.steps.map { current = walkPathStep(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCall(node: PartiqlAst.Expr.Call, accumulator: T): T {
            var current = accumulator
            current = visitExprCall(node, current)
            current = walkSymbolPrimitive(node.funcName, current)
            node.args.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCallAgg(node: PartiqlAst.Expr.CallAgg, accumulator: T): T {
            var current = accumulator
            current = visitExprCallAgg(node, current)
            current = walkSetQuantifier(node.setq, current)
            current = walkSymbolPrimitive(node.funcName, current)
            current = walkExpr(node.arg, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCast(node: PartiqlAst.Expr.Cast, accumulator: T): T {
            var current = accumulator
            current = visitExprCast(node, current)
            current = walkExpr(node.value, current)
            current = walkType(node.asType, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCanCast(node: PartiqlAst.Expr.CanCast, accumulator: T): T {
            var current = accumulator
            current = visitExprCanCast(node, current)
            current = walkExpr(node.value, current)
            current = walkType(node.asType, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast, accumulator: T): T {
            var current = accumulator
            current = visitExprCanLosslessCast(node, current)
            current = walkExpr(node.value, current)
            current = walkType(node.asType, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprNullIf(node: PartiqlAst.Expr.NullIf, accumulator: T): T {
            var current = accumulator
            current = visitExprNullIf(node, current)
            current = walkExpr(node.expr1, current)
            current = walkExpr(node.expr2, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprCoalesce(node: PartiqlAst.Expr.Coalesce, accumulator: T): T {
            var current = accumulator
            current = visitExprCoalesce(node, current)
            node.args.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkExprSelect(node: PartiqlAst.Expr.Select, accumulator: T): T {
            var current = accumulator
            current = visitExprSelect(node, current)
            node.setq?.let { current = walkSetQuantifier(it, current) }
            current = walkProjection(node.project, current)
            current = walkFromSource(node.from, current)
            node.fromLet?.let { current = walkLet(it, current) }
            node.where?.let { current = walkExpr(it, current) }
            node.group?.let { current = walkGroupBy(it, current) }
            node.having?.let { current = walkExpr(it, current) }
            node.order?.let { current = walkOrderBy(it, current) }
            node.limit?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: PathStep
        //////////////////////////////////////
        open fun walkPathStep(node: PartiqlAst.PathStep, accumulator: T): T {
            val current = visitPathStep(node, accumulator)
            return when(node) {
                is PartiqlAst.PathStep.PathExpr -> walkPathStepPathExpr(node, current)
                is PartiqlAst.PathStep.PathWildcard -> walkPathStepPathWildcard(node, current)
                is PartiqlAst.PathStep.PathUnpivot -> walkPathStepPathUnpivot(node, current)
            }
        }
    
        open fun walkPathStepPathExpr(node: PartiqlAst.PathStep.PathExpr, accumulator: T): T {
            var current = accumulator
            current = visitPathStepPathExpr(node, current)
            current = walkExpr(node.index, current)
            current = walkCaseSensitivity(node.case, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathStepPathWildcard(node: PartiqlAst.PathStep.PathWildcard, accumulator: T): T {
            var current = accumulator
            current = visitPathStepPathWildcard(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkPathStepPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot, accumulator: T): T {
            var current = accumulator
            current = visitPathStepPathUnpivot(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun walkProjection(node: PartiqlAst.Projection, accumulator: T): T {
            val current = visitProjection(node, accumulator)
            return when(node) {
                is PartiqlAst.Projection.ProjectStar -> walkProjectionProjectStar(node, current)
                is PartiqlAst.Projection.ProjectList -> walkProjectionProjectList(node, current)
                is PartiqlAst.Projection.ProjectPivot -> walkProjectionProjectPivot(node, current)
                is PartiqlAst.Projection.ProjectValue -> walkProjectionProjectValue(node, current)
            }
        }
    
        open fun walkProjectionProjectStar(node: PartiqlAst.Projection.ProjectStar, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectStar(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectionProjectList(node: PartiqlAst.Projection.ProjectList, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectList(node, current)
            node.projectItems.map { current = walkProjectItem(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectionProjectPivot(node: PartiqlAst.Projection.ProjectPivot, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectPivot(node, current)
            current = walkExpr(node.value, current)
            current = walkExpr(node.key, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectionProjectValue(node: PartiqlAst.Projection.ProjectValue, accumulator: T): T {
            var current = accumulator
            current = visitProjectionProjectValue(node, current)
            current = walkExpr(node.value, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun walkProjectItem(node: PartiqlAst.ProjectItem, accumulator: T): T {
            val current = visitProjectItem(node, accumulator)
            return when(node) {
                is PartiqlAst.ProjectItem.ProjectAll -> walkProjectItemProjectAll(node, current)
                is PartiqlAst.ProjectItem.ProjectExpr -> walkProjectItemProjectExpr(node, current)
            }
        }
    
        open fun walkProjectItemProjectAll(node: PartiqlAst.ProjectItem.ProjectAll, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectAll(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkProjectItemProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr, accumulator: T): T {
            var current = accumulator
            current = visitProjectItemProjectExpr(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun walkFromSource(node: PartiqlAst.FromSource, accumulator: T): T {
            val current = visitFromSource(node, accumulator)
            return when(node) {
                is PartiqlAst.FromSource.Scan -> walkFromSourceScan(node, current)
                is PartiqlAst.FromSource.Unpivot -> walkFromSourceUnpivot(node, current)
                is PartiqlAst.FromSource.Join -> walkFromSourceJoin(node, current)
            }
        }
    
        open fun walkFromSourceScan(node: PartiqlAst.FromSource.Scan, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceScan(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.atAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.byAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkFromSourceUnpivot(node: PartiqlAst.FromSource.Unpivot, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceUnpivot(node, current)
            current = walkExpr(node.expr, current)
            node.asAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.atAlias?.let { current = walkSymbolPrimitive(it, current) }
            node.byAlias?.let { current = walkSymbolPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkFromSourceJoin(node: PartiqlAst.FromSource.Join, accumulator: T): T {
            var current = accumulator
            current = visitFromSourceJoin(node, current)
            current = walkJoinType(node.type, current)
            current = walkFromSource(node.left, current)
            current = walkFromSource(node.right, current)
            node.predicate?.let { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun walkJoinType(node: PartiqlAst.JoinType, accumulator: T): T {
            val current = visitJoinType(node, accumulator)
            return when(node) {
                is PartiqlAst.JoinType.Inner -> walkJoinTypeInner(node, current)
                is PartiqlAst.JoinType.Left -> walkJoinTypeLeft(node, current)
                is PartiqlAst.JoinType.Right -> walkJoinTypeRight(node, current)
                is PartiqlAst.JoinType.Full -> walkJoinTypeFull(node, current)
            }
        }
    
        open fun walkJoinTypeInner(node: PartiqlAst.JoinType.Inner, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeInner(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeLeft(node: PartiqlAst.JoinType.Left, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeLeft(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeRight(node: PartiqlAst.JoinType.Right, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeRight(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkJoinTypeFull(node: PartiqlAst.JoinType.Full, accumulator: T): T {
            var current = accumulator
            current = visitJoinTypeFull(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: GroupingStrategy
        //////////////////////////////////////
        open fun walkGroupingStrategy(node: PartiqlAst.GroupingStrategy, accumulator: T): T {
            val current = visitGroupingStrategy(node, accumulator)
            return when(node) {
                is PartiqlAst.GroupingStrategy.GroupFull -> walkGroupingStrategyGroupFull(node, current)
                is PartiqlAst.GroupingStrategy.GroupPartial -> walkGroupingStrategyGroupPartial(node, current)
            }
        }
    
        open fun walkGroupingStrategyGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull, accumulator: T): T {
            var current = accumulator
            current = visitGroupingStrategyGroupFull(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkGroupingStrategyGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial, accumulator: T): T {
            var current = accumulator
            current = visitGroupingStrategyGroupPartial(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: OrderingSpec
        //////////////////////////////////////
        open fun walkOrderingSpec(node: PartiqlAst.OrderingSpec, accumulator: T): T {
            val current = visitOrderingSpec(node, accumulator)
            return when(node) {
                is PartiqlAst.OrderingSpec.Asc -> walkOrderingSpecAsc(node, current)
                is PartiqlAst.OrderingSpec.Desc -> walkOrderingSpecDesc(node, current)
            }
        }
    
        open fun walkOrderingSpecAsc(node: PartiqlAst.OrderingSpec.Asc, accumulator: T): T {
            var current = accumulator
            current = visitOrderingSpecAsc(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkOrderingSpecDesc(node: PartiqlAst.OrderingSpec.Desc, accumulator: T): T {
            var current = accumulator
            current = visitOrderingSpecDesc(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun walkCaseSensitivity(node: PartiqlAst.CaseSensitivity, accumulator: T): T {
            val current = visitCaseSensitivity(node, accumulator)
            return when(node) {
                is PartiqlAst.CaseSensitivity.CaseSensitive -> walkCaseSensitivityCaseSensitive(node, current)
                is PartiqlAst.CaseSensitivity.CaseInsensitive -> walkCaseSensitivityCaseInsensitive(node, current)
            }
        }
    
        open fun walkCaseSensitivityCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseSensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkCaseSensitivityCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive, accumulator: T): T {
            var current = accumulator
            current = visitCaseSensitivityCaseInsensitive(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun walkScopeQualifier(node: PartiqlAst.ScopeQualifier, accumulator: T): T {
            val current = visitScopeQualifier(node, accumulator)
            return when(node) {
                is PartiqlAst.ScopeQualifier.Unqualified -> walkScopeQualifierUnqualified(node, current)
                is PartiqlAst.ScopeQualifier.LocalsFirst -> walkScopeQualifierLocalsFirst(node, current)
            }
        }
    
        open fun walkScopeQualifierUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierUnqualified(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkScopeQualifierLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst, accumulator: T): T {
            var current = accumulator
            current = visitScopeQualifierLocalsFirst(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun walkSetQuantifier(node: PartiqlAst.SetQuantifier, accumulator: T): T {
            val current = visitSetQuantifier(node, accumulator)
            return when(node) {
                is PartiqlAst.SetQuantifier.All -> walkSetQuantifierAll(node, current)
                is PartiqlAst.SetQuantifier.Distinct -> walkSetQuantifierDistinct(node, current)
            }
        }
    
        open fun walkSetQuantifierAll(node: PartiqlAst.SetQuantifier.All, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierAll(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkSetQuantifierDistinct(node: PartiqlAst.SetQuantifier.Distinct, accumulator: T): T {
            var current = accumulator
            current = visitSetQuantifierDistinct(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: DmlOp
        //////////////////////////////////////
        open fun walkDmlOp(node: PartiqlAst.DmlOp, accumulator: T): T {
            val current = visitDmlOp(node, accumulator)
            return when(node) {
                is PartiqlAst.DmlOp.Insert -> walkDmlOpInsert(node, current)
                is PartiqlAst.DmlOp.InsertValue -> walkDmlOpInsertValue(node, current)
                is PartiqlAst.DmlOp.Set -> walkDmlOpSet(node, current)
                is PartiqlAst.DmlOp.Remove -> walkDmlOpRemove(node, current)
                is PartiqlAst.DmlOp.Delete -> walkDmlOpDelete(node, current)
            }
        }
    
        open fun walkDmlOpInsert(node: PartiqlAst.DmlOp.Insert, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpInsert(node, current)
            current = walkExpr(node.target, current)
            current = walkExpr(node.values, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDmlOpInsertValue(node: PartiqlAst.DmlOp.InsertValue, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpInsertValue(node, current)
            current = walkExpr(node.target, current)
            current = walkExpr(node.value, current)
            node.index?.let { current = walkExpr(it, current) }
            node.onConflict?.let { current = walkOnConflict(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDmlOpSet(node: PartiqlAst.DmlOp.Set, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpSet(node, current)
            current = walkAssignment(node.assignment, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDmlOpRemove(node: PartiqlAst.DmlOp.Remove, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpRemove(node, current)
            current = walkExpr(node.target, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDmlOpDelete(node: PartiqlAst.DmlOp.Delete, accumulator: T): T {
            var current = accumulator
            current = visitDmlOpDelete(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ConflictAction
        //////////////////////////////////////
        open fun walkConflictAction(node: PartiqlAst.ConflictAction, accumulator: T): T {
            val current = visitConflictAction(node, accumulator)
            return when(node) {
                is PartiqlAst.ConflictAction.DoNothing -> walkConflictActionDoNothing(node, current)
            }
        }
    
        open fun walkConflictActionDoNothing(node: PartiqlAst.ConflictAction.DoNothing, accumulator: T): T {
            var current = accumulator
            current = visitConflictActionDoNothing(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: DdlOp
        //////////////////////////////////////
        open fun walkDdlOp(node: PartiqlAst.DdlOp, accumulator: T): T {
            val current = visitDdlOp(node, accumulator)
            return when(node) {
                is PartiqlAst.DdlOp.CreateTable -> walkDdlOpCreateTable(node, current)
                is PartiqlAst.DdlOp.DropTable -> walkDdlOpDropTable(node, current)
                is PartiqlAst.DdlOp.UndropTable -> walkDdlOpUndropTable(node, current)
                is PartiqlAst.DdlOp.CreateIndex -> walkDdlOpCreateIndex(node, current)
                is PartiqlAst.DdlOp.DropIndex -> walkDdlOpDropIndex(node, current)
            }
        }
    
        open fun walkDdlOpCreateTable(node: PartiqlAst.DdlOp.CreateTable, accumulator: T): T {
            var current = accumulator
            current = visitDdlOpCreateTable(node, current)
            current = walkSymbolPrimitive(node.tableName, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDdlOpDropTable(node: PartiqlAst.DdlOp.DropTable, accumulator: T): T {
            var current = accumulator
            current = visitDdlOpDropTable(node, current)
            current = walkIdentifier(node.tableName, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDdlOpUndropTable(node: PartiqlAst.DdlOp.UndropTable, accumulator: T): T {
            var current = accumulator
            current = visitDdlOpUndropTable(node, current)
            current = walkSymbolPrimitive(node.tableName, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDdlOpCreateIndex(node: PartiqlAst.DdlOp.CreateIndex, accumulator: T): T {
            var current = accumulator
            current = visitDdlOpCreateIndex(node, current)
            current = walkIdentifier(node.indexName, current)
            node.fields.map { current = walkExpr(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkDdlOpDropIndex(node: PartiqlAst.DdlOp.DropIndex, accumulator: T): T {
            var current = accumulator
            current = visitDdlOpDropIndex(node, current)
            current = walkIdentifier(node.table, current)
            current = walkIdentifier(node.keys, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ColumnComponent
        //////////////////////////////////////
        open fun walkColumnComponent(node: PartiqlAst.ColumnComponent, accumulator: T): T {
            val current = visitColumnComponent(node, accumulator)
            return when(node) {
                is PartiqlAst.ColumnComponent.ReturningWildcard -> walkColumnComponentReturningWildcard(node, current)
                is PartiqlAst.ColumnComponent.ReturningColumn -> walkColumnComponentReturningColumn(node, current)
            }
        }
    
        open fun walkColumnComponentReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard, accumulator: T): T {
            var current = accumulator
            current = visitColumnComponentReturningWildcard(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkColumnComponentReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn, accumulator: T): T {
            var current = accumulator
            current = visitColumnComponentReturningColumn(node, current)
            current = walkExpr(node.expr, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: ReturningMapping
        //////////////////////////////////////
        open fun walkReturningMapping(node: PartiqlAst.ReturningMapping, accumulator: T): T {
            val current = visitReturningMapping(node, accumulator)
            return when(node) {
                is PartiqlAst.ReturningMapping.ModifiedNew -> walkReturningMappingModifiedNew(node, current)
                is PartiqlAst.ReturningMapping.ModifiedOld -> walkReturningMappingModifiedOld(node, current)
                is PartiqlAst.ReturningMapping.AllNew -> walkReturningMappingAllNew(node, current)
                is PartiqlAst.ReturningMapping.AllOld -> walkReturningMappingAllOld(node, current)
            }
        }
    
        open fun walkReturningMappingModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew, accumulator: T): T {
            var current = accumulator
            current = visitReturningMappingModifiedNew(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkReturningMappingModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld, accumulator: T): T {
            var current = accumulator
            current = visitReturningMappingModifiedOld(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkReturningMappingAllNew(node: PartiqlAst.ReturningMapping.AllNew, accumulator: T): T {
            var current = accumulator
            current = visitReturningMappingAllNew(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkReturningMappingAllOld(node: PartiqlAst.ReturningMapping.AllOld, accumulator: T): T {
            var current = accumulator
            current = visitReturningMappingAllOld(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        //////////////////////////////////////
        // Sum Type: Type
        //////////////////////////////////////
        open fun walkType(node: PartiqlAst.Type, accumulator: T): T {
            val current = visitType(node, accumulator)
            return when(node) {
                is PartiqlAst.Type.NullType -> walkTypeNullType(node, current)
                is PartiqlAst.Type.BooleanType -> walkTypeBooleanType(node, current)
                is PartiqlAst.Type.SmallintType -> walkTypeSmallintType(node, current)
                is PartiqlAst.Type.Integer4Type -> walkTypeInteger4Type(node, current)
                is PartiqlAst.Type.Integer8Type -> walkTypeInteger8Type(node, current)
                is PartiqlAst.Type.IntegerType -> walkTypeIntegerType(node, current)
                is PartiqlAst.Type.FloatType -> walkTypeFloatType(node, current)
                is PartiqlAst.Type.RealType -> walkTypeRealType(node, current)
                is PartiqlAst.Type.DoublePrecisionType -> walkTypeDoublePrecisionType(node, current)
                is PartiqlAst.Type.DecimalType -> walkTypeDecimalType(node, current)
                is PartiqlAst.Type.NumericType -> walkTypeNumericType(node, current)
                is PartiqlAst.Type.TimestampType -> walkTypeTimestampType(node, current)
                is PartiqlAst.Type.CharacterType -> walkTypeCharacterType(node, current)
                is PartiqlAst.Type.CharacterVaryingType -> walkTypeCharacterVaryingType(node, current)
                is PartiqlAst.Type.MissingType -> walkTypeMissingType(node, current)
                is PartiqlAst.Type.StringType -> walkTypeStringType(node, current)
                is PartiqlAst.Type.SymbolType -> walkTypeSymbolType(node, current)
                is PartiqlAst.Type.BlobType -> walkTypeBlobType(node, current)
                is PartiqlAst.Type.ClobType -> walkTypeClobType(node, current)
                is PartiqlAst.Type.DateType -> walkTypeDateType(node, current)
                is PartiqlAst.Type.TimeType -> walkTypeTimeType(node, current)
                is PartiqlAst.Type.TimeWithTimeZoneType -> walkTypeTimeWithTimeZoneType(node, current)
                is PartiqlAst.Type.StructType -> walkTypeStructType(node, current)
                is PartiqlAst.Type.TupleType -> walkTypeTupleType(node, current)
                is PartiqlAst.Type.ListType -> walkTypeListType(node, current)
                is PartiqlAst.Type.SexpType -> walkTypeSexpType(node, current)
                is PartiqlAst.Type.BagType -> walkTypeBagType(node, current)
                is PartiqlAst.Type.AnyType -> walkTypeAnyType(node, current)
                is PartiqlAst.Type.EsBoolean -> walkTypeEsBoolean(node, current)
                is PartiqlAst.Type.EsInteger -> walkTypeEsInteger(node, current)
                is PartiqlAst.Type.EsFloat -> walkTypeEsFloat(node, current)
                is PartiqlAst.Type.EsText -> walkTypeEsText(node, current)
                is PartiqlAst.Type.EsAny -> walkTypeEsAny(node, current)
                is PartiqlAst.Type.SparkShort -> walkTypeSparkShort(node, current)
                is PartiqlAst.Type.SparkInteger -> walkTypeSparkInteger(node, current)
                is PartiqlAst.Type.SparkLong -> walkTypeSparkLong(node, current)
                is PartiqlAst.Type.SparkDouble -> walkTypeSparkDouble(node, current)
                is PartiqlAst.Type.SparkBoolean -> walkTypeSparkBoolean(node, current)
                is PartiqlAst.Type.SparkFloat -> walkTypeSparkFloat(node, current)
                is PartiqlAst.Type.RsVarcharMax -> walkTypeRsVarcharMax(node, current)
                is PartiqlAst.Type.RsInteger -> walkTypeRsInteger(node, current)
                is PartiqlAst.Type.RsBigint -> walkTypeRsBigint(node, current)
                is PartiqlAst.Type.RsBoolean -> walkTypeRsBoolean(node, current)
                is PartiqlAst.Type.RsReal -> walkTypeRsReal(node, current)
                is PartiqlAst.Type.RsDoublePrecision -> walkTypeRsDoublePrecision(node, current)
                is PartiqlAst.Type.CustomType -> walkTypeCustomType(node, current)
            }
        }
    
        open fun walkTypeNullType(node: PartiqlAst.Type.NullType, accumulator: T): T {
            var current = accumulator
            current = visitTypeNullType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeBooleanType(node: PartiqlAst.Type.BooleanType, accumulator: T): T {
            var current = accumulator
            current = visitTypeBooleanType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSmallintType(node: PartiqlAst.Type.SmallintType, accumulator: T): T {
            var current = accumulator
            current = visitTypeSmallintType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeInteger4Type(node: PartiqlAst.Type.Integer4Type, accumulator: T): T {
            var current = accumulator
            current = visitTypeInteger4Type(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeInteger8Type(node: PartiqlAst.Type.Integer8Type, accumulator: T): T {
            var current = accumulator
            current = visitTypeInteger8Type(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeIntegerType(node: PartiqlAst.Type.IntegerType, accumulator: T): T {
            var current = accumulator
            current = visitTypeIntegerType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeFloatType(node: PartiqlAst.Type.FloatType, accumulator: T): T {
            var current = accumulator
            current = visitTypeFloatType(node, current)
            node.precision?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRealType(node: PartiqlAst.Type.RealType, accumulator: T): T {
            var current = accumulator
            current = visitTypeRealType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType, accumulator: T): T {
            var current = accumulator
            current = visitTypeDoublePrecisionType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeDecimalType(node: PartiqlAst.Type.DecimalType, accumulator: T): T {
            var current = accumulator
            current = visitTypeDecimalType(node, current)
            node.precision?.let { current = walkLongPrimitive(it, current) }
            node.scale?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeNumericType(node: PartiqlAst.Type.NumericType, accumulator: T): T {
            var current = accumulator
            current = visitTypeNumericType(node, current)
            node.precision?.let { current = walkLongPrimitive(it, current) }
            node.scale?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeTimestampType(node: PartiqlAst.Type.TimestampType, accumulator: T): T {
            var current = accumulator
            current = visitTypeTimestampType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeCharacterType(node: PartiqlAst.Type.CharacterType, accumulator: T): T {
            var current = accumulator
            current = visitTypeCharacterType(node, current)
            node.length?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType, accumulator: T): T {
            var current = accumulator
            current = visitTypeCharacterVaryingType(node, current)
            node.length?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeMissingType(node: PartiqlAst.Type.MissingType, accumulator: T): T {
            var current = accumulator
            current = visitTypeMissingType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeStringType(node: PartiqlAst.Type.StringType, accumulator: T): T {
            var current = accumulator
            current = visitTypeStringType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSymbolType(node: PartiqlAst.Type.SymbolType, accumulator: T): T {
            var current = accumulator
            current = visitTypeSymbolType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeBlobType(node: PartiqlAst.Type.BlobType, accumulator: T): T {
            var current = accumulator
            current = visitTypeBlobType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeClobType(node: PartiqlAst.Type.ClobType, accumulator: T): T {
            var current = accumulator
            current = visitTypeClobType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeDateType(node: PartiqlAst.Type.DateType, accumulator: T): T {
            var current = accumulator
            current = visitTypeDateType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeTimeType(node: PartiqlAst.Type.TimeType, accumulator: T): T {
            var current = accumulator
            current = visitTypeTimeType(node, current)
            node.precision?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType, accumulator: T): T {
            var current = accumulator
            current = visitTypeTimeWithTimeZoneType(node, current)
            node.precision?.let { current = walkLongPrimitive(it, current) }
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeStructType(node: PartiqlAst.Type.StructType, accumulator: T): T {
            var current = accumulator
            current = visitTypeStructType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeTupleType(node: PartiqlAst.Type.TupleType, accumulator: T): T {
            var current = accumulator
            current = visitTypeTupleType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeListType(node: PartiqlAst.Type.ListType, accumulator: T): T {
            var current = accumulator
            current = visitTypeListType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSexpType(node: PartiqlAst.Type.SexpType, accumulator: T): T {
            var current = accumulator
            current = visitTypeSexpType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeBagType(node: PartiqlAst.Type.BagType, accumulator: T): T {
            var current = accumulator
            current = visitTypeBagType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeAnyType(node: PartiqlAst.Type.AnyType, accumulator: T): T {
            var current = accumulator
            current = visitTypeAnyType(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeEsBoolean(node: PartiqlAst.Type.EsBoolean, accumulator: T): T {
            var current = accumulator
            current = visitTypeEsBoolean(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeEsInteger(node: PartiqlAst.Type.EsInteger, accumulator: T): T {
            var current = accumulator
            current = visitTypeEsInteger(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeEsFloat(node: PartiqlAst.Type.EsFloat, accumulator: T): T {
            var current = accumulator
            current = visitTypeEsFloat(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeEsText(node: PartiqlAst.Type.EsText, accumulator: T): T {
            var current = accumulator
            current = visitTypeEsText(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeEsAny(node: PartiqlAst.Type.EsAny, accumulator: T): T {
            var current = accumulator
            current = visitTypeEsAny(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkShort(node: PartiqlAst.Type.SparkShort, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkShort(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkInteger(node: PartiqlAst.Type.SparkInteger, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkInteger(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkLong(node: PartiqlAst.Type.SparkLong, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkLong(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkDouble(node: PartiqlAst.Type.SparkDouble, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkDouble(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkBoolean(node: PartiqlAst.Type.SparkBoolean, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkBoolean(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeSparkFloat(node: PartiqlAst.Type.SparkFloat, accumulator: T): T {
            var current = accumulator
            current = visitTypeSparkFloat(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsVarcharMax(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsInteger(node: PartiqlAst.Type.RsInteger, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsInteger(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsBigint(node: PartiqlAst.Type.RsBigint, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsBigint(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsBoolean(node: PartiqlAst.Type.RsBoolean, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsBoolean(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsReal(node: PartiqlAst.Type.RsReal, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsReal(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision, accumulator: T): T {
            var current = accumulator
            current = visitTypeRsDoublePrecision(node, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
        open fun walkTypeCustomType(node: PartiqlAst.Type.CustomType, accumulator: T): T {
            var current = accumulator
            current = visitTypeCustomType(node, current)
            current = walkSymbolPrimitive(node.name, current)
            current = walkMetas(node.metas, current)
            return current
        }
    
    }
    abstract class VisitorTransform : DomainVisitorTransformBase() {
        //////////////////////////////////////
        // Tuple Types
        //////////////////////////////////////
        // Tuple TimeValue
        open fun transformTimeValue(node: PartiqlAst.TimeValue): PartiqlAst.TimeValue {
            val new_hour = transformTimeValue_hour(node)
            val new_minute = transformTimeValue_minute(node)
            val new_second = transformTimeValue_second(node)
            val new_nano = transformTimeValue_nano(node)
            val new_precision = transformTimeValue_precision(node)
            val new_tzMinutes = transformTimeValue_tzMinutes(node)
            val new_metas = transformTimeValue_metas(node)
            return if (
                node.hour !== new_hour ||
                node.minute !== new_minute ||
                node.second !== new_second ||
                node.nano !== new_nano ||
                node.precision !== new_precision ||
                node.tzMinutes !== new_tzMinutes ||
                node.metas !== new_metas
            ) {
                PartiqlAst.TimeValue(
                    hour = new_hour,
                    minute = new_minute,
                    second = new_second,
                    nano = new_nano,
                    precision = new_precision,
                    tzMinutes = new_tzMinutes,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTimeValue_hour(node: PartiqlAst.TimeValue) =
            transformLongPrimitive(node.hour)
        open fun transformTimeValue_minute(node: PartiqlAst.TimeValue) =
            transformLongPrimitive(node.minute)
        open fun transformTimeValue_second(node: PartiqlAst.TimeValue) =
            transformLongPrimitive(node.second)
        open fun transformTimeValue_nano(node: PartiqlAst.TimeValue) =
            transformLongPrimitive(node.nano)
        open fun transformTimeValue_precision(node: PartiqlAst.TimeValue) =
            transformLongPrimitive(node.precision)
        open fun transformTimeValue_tzMinutes(node: PartiqlAst.TimeValue) =
            node.tzMinutes?.let { transformLongPrimitive(it) }
        open fun transformTimeValue_metas(node: PartiqlAst.TimeValue) =
            transformMetas(node.metas)
    
        // Tuple Let
        open fun transformLet(node: PartiqlAst.Let): PartiqlAst.Let {
            val new_letBindings = transformLet_letBindings(node)
            val new_metas = transformLet_metas(node)
            return if (
                node.letBindings !== new_letBindings ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Let(
                    letBindings = new_letBindings,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformLet_letBindings(node: PartiqlAst.Let) =
            node.letBindings.map { transformLetBinding(it) }
        open fun transformLet_metas(node: PartiqlAst.Let) =
            transformMetas(node.metas)
    
        // Tuple LetBinding
        open fun transformLetBinding(node: PartiqlAst.LetBinding): PartiqlAst.LetBinding {
            val new_expr = transformLetBinding_expr(node)
            val new_name = transformLetBinding_name(node)
            val new_metas = transformLetBinding_metas(node)
            return if (
                node.expr !== new_expr ||
                node.name !== new_name ||
                node.metas !== new_metas
            ) {
                PartiqlAst.LetBinding(
                    expr = new_expr,
                    name = new_name,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformLetBinding_expr(node: PartiqlAst.LetBinding) =
            transformExpr(node.expr)
        open fun transformLetBinding_name(node: PartiqlAst.LetBinding) =
            transformSymbolPrimitive(node.name)
        open fun transformLetBinding_metas(node: PartiqlAst.LetBinding) =
            transformMetas(node.metas)
    
        // Tuple ExprPair
        open fun transformExprPair(node: PartiqlAst.ExprPair): PartiqlAst.ExprPair {
            val new_first = transformExprPair_first(node)
            val new_second = transformExprPair_second(node)
            val new_metas = transformExprPair_metas(node)
            return if (
                node.first !== new_first ||
                node.second !== new_second ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ExprPair(
                    first = new_first,
                    second = new_second,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPair_first(node: PartiqlAst.ExprPair) =
            transformExpr(node.first)
        open fun transformExprPair_second(node: PartiqlAst.ExprPair) =
            transformExpr(node.second)
        open fun transformExprPair_metas(node: PartiqlAst.ExprPair) =
            transformMetas(node.metas)
    
        // Tuple ExprPairList
        open fun transformExprPairList(node: PartiqlAst.ExprPairList): PartiqlAst.ExprPairList {
            val new_pairs = transformExprPairList_pairs(node)
            val new_metas = transformExprPairList_metas(node)
            return if (
                node.pairs !== new_pairs ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ExprPairList(
                    pairs = new_pairs,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPairList_pairs(node: PartiqlAst.ExprPairList) =
            node.pairs.map { transformExprPair(it) }
        open fun transformExprPairList_metas(node: PartiqlAst.ExprPairList) =
            transformMetas(node.metas)
    
        // Tuple GroupBy
        open fun transformGroupBy(node: PartiqlAst.GroupBy): PartiqlAst.GroupBy {
            val new_strategy = transformGroupBy_strategy(node)
            val new_keyList = transformGroupBy_keyList(node)
            val new_groupAsAlias = transformGroupBy_groupAsAlias(node)
            val new_metas = transformGroupBy_metas(node)
            return if (
                node.strategy !== new_strategy ||
                node.keyList !== new_keyList ||
                node.groupAsAlias !== new_groupAsAlias ||
                node.metas !== new_metas
            ) {
                PartiqlAst.GroupBy(
                    strategy = new_strategy,
                    keyList = new_keyList,
                    groupAsAlias = new_groupAsAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupBy_strategy(node: PartiqlAst.GroupBy) =
            transformGroupingStrategy(node.strategy)
        open fun transformGroupBy_keyList(node: PartiqlAst.GroupBy) =
            transformGroupKeyList(node.keyList)
        open fun transformGroupBy_groupAsAlias(node: PartiqlAst.GroupBy) =
            node.groupAsAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupBy_metas(node: PartiqlAst.GroupBy) =
            transformMetas(node.metas)
    
        // Tuple GroupKeyList
        open fun transformGroupKeyList(node: PartiqlAst.GroupKeyList): PartiqlAst.GroupKeyList {
            val new_keys = transformGroupKeyList_keys(node)
            val new_metas = transformGroupKeyList_metas(node)
            return if (
                node.keys !== new_keys ||
                node.metas !== new_metas
            ) {
                PartiqlAst.GroupKeyList(
                    keys = new_keys,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupKeyList_keys(node: PartiqlAst.GroupKeyList) =
            node.keys.map { transformGroupKey(it) }
        open fun transformGroupKeyList_metas(node: PartiqlAst.GroupKeyList) =
            transformMetas(node.metas)
    
        // Tuple GroupKey
        open fun transformGroupKey(node: PartiqlAst.GroupKey): PartiqlAst.GroupKey {
            val new_expr = transformGroupKey_expr(node)
            val new_asAlias = transformGroupKey_asAlias(node)
            val new_metas = transformGroupKey_metas(node)
            return if (
                node.expr !== new_expr ||
                node.asAlias !== new_asAlias ||
                node.metas !== new_metas
            ) {
                PartiqlAst.GroupKey(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupKey_expr(node: PartiqlAst.GroupKey) =
            transformExpr(node.expr)
        open fun transformGroupKey_asAlias(node: PartiqlAst.GroupKey) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformGroupKey_metas(node: PartiqlAst.GroupKey) =
            transformMetas(node.metas)
    
        // Tuple OrderBy
        open fun transformOrderBy(node: PartiqlAst.OrderBy): PartiqlAst.OrderBy {
            val new_sortSpecs = transformOrderBy_sortSpecs(node)
            val new_metas = transformOrderBy_metas(node)
            return if (
                node.sortSpecs !== new_sortSpecs ||
                node.metas !== new_metas
            ) {
                PartiqlAst.OrderBy(
                    sortSpecs = new_sortSpecs,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOrderBy_sortSpecs(node: PartiqlAst.OrderBy) =
            node.sortSpecs.map { transformSortSpec(it) }
        open fun transformOrderBy_metas(node: PartiqlAst.OrderBy) =
            transformMetas(node.metas)
    
        // Tuple SortSpec
        open fun transformSortSpec(node: PartiqlAst.SortSpec): PartiqlAst.SortSpec {
            val new_expr = transformSortSpec_expr(node)
            val new_orderingSpec = transformSortSpec_orderingSpec(node)
            val new_metas = transformSortSpec_metas(node)
            return if (
                node.expr !== new_expr ||
                node.orderingSpec !== new_orderingSpec ||
                node.metas !== new_metas
            ) {
                PartiqlAst.SortSpec(
                    expr = new_expr,
                    orderingSpec = new_orderingSpec,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSortSpec_expr(node: PartiqlAst.SortSpec) =
            transformExpr(node.expr)
        open fun transformSortSpec_orderingSpec(node: PartiqlAst.SortSpec) =
            node.orderingSpec?.let { transformOrderingSpec(it) }
        open fun transformSortSpec_metas(node: PartiqlAst.SortSpec) =
            transformMetas(node.metas)
    
        // Tuple DmlOpList
        open fun transformDmlOpList(node: PartiqlAst.DmlOpList): PartiqlAst.DmlOpList {
            val new_ops = transformDmlOpList_ops(node)
            val new_metas = transformDmlOpList_metas(node)
            return if (
                node.ops !== new_ops ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOpList(
                    ops = new_ops,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpList_ops(node: PartiqlAst.DmlOpList) =
            node.ops.map { transformDmlOp(it) }
        open fun transformDmlOpList_metas(node: PartiqlAst.DmlOpList) =
            transformMetas(node.metas)
    
        // Tuple OnConflict
        open fun transformOnConflict(node: PartiqlAst.OnConflict): PartiqlAst.OnConflict {
            val new_expr = transformOnConflict_expr(node)
            val new_conflictAction = transformOnConflict_conflictAction(node)
            val new_metas = transformOnConflict_metas(node)
            return if (
                node.expr !== new_expr ||
                node.conflictAction !== new_conflictAction ||
                node.metas !== new_metas
            ) {
                PartiqlAst.OnConflict(
                    expr = new_expr,
                    conflictAction = new_conflictAction,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOnConflict_expr(node: PartiqlAst.OnConflict) =
            transformExpr(node.expr)
        open fun transformOnConflict_conflictAction(node: PartiqlAst.OnConflict) =
            transformConflictAction(node.conflictAction)
        open fun transformOnConflict_metas(node: PartiqlAst.OnConflict) =
            transformMetas(node.metas)
    
        // Tuple ReturningExpr
        open fun transformReturningExpr(node: PartiqlAst.ReturningExpr): PartiqlAst.ReturningExpr {
            val new_elems = transformReturningExpr_elems(node)
            val new_metas = transformReturningExpr_metas(node)
            return if (
                node.elems !== new_elems ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningExpr(
                    elems = new_elems,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningExpr_elems(node: PartiqlAst.ReturningExpr) =
            node.elems.map { transformReturningElem(it) }
        open fun transformReturningExpr_metas(node: PartiqlAst.ReturningExpr) =
            transformMetas(node.metas)
    
        // Tuple ReturningElem
        open fun transformReturningElem(node: PartiqlAst.ReturningElem): PartiqlAst.ReturningElem {
            val new_mapping = transformReturningElem_mapping(node)
            val new_column = transformReturningElem_column(node)
            val new_metas = transformReturningElem_metas(node)
            return if (
                node.mapping !== new_mapping ||
                node.column !== new_column ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningElem(
                    mapping = new_mapping,
                    column = new_column,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningElem_mapping(node: PartiqlAst.ReturningElem) =
            transformReturningMapping(node.mapping)
        open fun transformReturningElem_column(node: PartiqlAst.ReturningElem) =
            transformColumnComponent(node.column)
        open fun transformReturningElem_metas(node: PartiqlAst.ReturningElem) =
            transformMetas(node.metas)
    
        // Tuple Identifier
        open fun transformIdentifier(node: PartiqlAst.Identifier): PartiqlAst.Identifier {
            val new_name = transformIdentifier_name(node)
            val new_case = transformIdentifier_case(node)
            val new_metas = transformIdentifier_metas(node)
            return if (
                node.name !== new_name ||
                node.case !== new_case ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Identifier(
                    name = new_name,
                    case = new_case,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformIdentifier_name(node: PartiqlAst.Identifier) =
            transformSymbolPrimitive(node.name)
        open fun transformIdentifier_case(node: PartiqlAst.Identifier) =
            transformCaseSensitivity(node.case)
        open fun transformIdentifier_metas(node: PartiqlAst.Identifier) =
            transformMetas(node.metas)
    
        // Tuple Assignment
        open fun transformAssignment(node: PartiqlAst.Assignment): PartiqlAst.Assignment {
            val new_target = transformAssignment_target(node)
            val new_value = transformAssignment_value(node)
            val new_metas = transformAssignment_metas(node)
            return if (
                node.target !== new_target ||
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Assignment(
                    target = new_target,
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformAssignment_target(node: PartiqlAst.Assignment) =
            transformExpr(node.target)
        open fun transformAssignment_value(node: PartiqlAst.Assignment) =
            transformExpr(node.value)
        open fun transformAssignment_metas(node: PartiqlAst.Assignment) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Statement
        //////////////////////////////////////
        open fun transformStatement(node: PartiqlAst.Statement): PartiqlAst.Statement =
            when(node) {
                is PartiqlAst.Statement.Query -> transformStatementQuery(node)
                is PartiqlAst.Statement.Dml -> transformStatementDml(node)
                is PartiqlAst.Statement.Ddl -> transformStatementDdl(node)
                is PartiqlAst.Statement.Exec -> transformStatementExec(node)
            }
        // Variant StatementQuery
        open fun transformStatementQuery(node: PartiqlAst.Statement.Query): PartiqlAst.Statement  {
            val new_expr = transformStatementQuery_expr(node)
            val new_metas = transformStatementQuery_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Statement.Query(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformStatementQuery_expr(node: PartiqlAst.Statement.Query) =
            transformExpr(node.expr)
        open fun transformStatementQuery_metas(node: PartiqlAst.Statement.Query) =
            transformMetas(node.metas)
    
        // Variant StatementDml
        open fun transformStatementDml(node: PartiqlAst.Statement.Dml): PartiqlAst.Statement  {
            val new_operations = transformStatementDml_operations(node)
            val new_from = transformStatementDml_from(node)
            val new_where = transformStatementDml_where(node)
            val new_returning = transformStatementDml_returning(node)
            val new_metas = transformStatementDml_metas(node)
            return if (
                node.operations !== new_operations ||
                node.from !== new_from ||
                node.where !== new_where ||
                node.returning !== new_returning ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Statement.Dml(
                    operations = new_operations,
                    from = new_from,
                    where = new_where,
                    returning = new_returning,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformStatementDml_operations(node: PartiqlAst.Statement.Dml) =
            transformDmlOpList(node.operations)
        open fun transformStatementDml_from(node: PartiqlAst.Statement.Dml) =
            node.from?.let { transformFromSource(it) }
        open fun transformStatementDml_where(node: PartiqlAst.Statement.Dml) =
            node.where?.let { transformExpr(it) }
        open fun transformStatementDml_returning(node: PartiqlAst.Statement.Dml) =
            node.returning?.let { transformReturningExpr(it) }
        open fun transformStatementDml_metas(node: PartiqlAst.Statement.Dml) =
            transformMetas(node.metas)
    
        // Variant StatementDdl
        open fun transformStatementDdl(node: PartiqlAst.Statement.Ddl): PartiqlAst.Statement  {
            val new_op = transformStatementDdl_op(node)
            val new_metas = transformStatementDdl_metas(node)
            return if (
                node.op !== new_op ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Statement.Ddl(
                    op = new_op,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformStatementDdl_op(node: PartiqlAst.Statement.Ddl) =
            transformDdlOp(node.op)
        open fun transformStatementDdl_metas(node: PartiqlAst.Statement.Ddl) =
            transformMetas(node.metas)
    
        // Variant StatementExec
        open fun transformStatementExec(node: PartiqlAst.Statement.Exec): PartiqlAst.Statement  {
            val new_procedureName = transformStatementExec_procedureName(node)
            val new_args = transformStatementExec_args(node)
            val new_metas = transformStatementExec_metas(node)
            return if (
                node.procedureName !== new_procedureName ||
                node.args !== new_args ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Statement.Exec(
                    procedureName = new_procedureName,
                    args = new_args,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformStatementExec_procedureName(node: PartiqlAst.Statement.Exec) =
            transformSymbolPrimitive(node.procedureName)
        open fun transformStatementExec_args(node: PartiqlAst.Statement.Exec) =
            node.args.map { transformExpr(it) }
        open fun transformStatementExec_metas(node: PartiqlAst.Statement.Exec) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Expr
        //////////////////////////////////////
        open fun transformExpr(node: PartiqlAst.Expr): PartiqlAst.Expr =
            when(node) {
                is PartiqlAst.Expr.Missing -> transformExprMissing(node)
                is PartiqlAst.Expr.Lit -> transformExprLit(node)
                is PartiqlAst.Expr.Id -> transformExprId(node)
                is PartiqlAst.Expr.Parameter -> transformExprParameter(node)
                is PartiqlAst.Expr.Not -> transformExprNot(node)
                is PartiqlAst.Expr.Pos -> transformExprPos(node)
                is PartiqlAst.Expr.Neg -> transformExprNeg(node)
                is PartiqlAst.Expr.Plus -> transformExprPlus(node)
                is PartiqlAst.Expr.Minus -> transformExprMinus(node)
                is PartiqlAst.Expr.Times -> transformExprTimes(node)
                is PartiqlAst.Expr.Divide -> transformExprDivide(node)
                is PartiqlAst.Expr.Modulo -> transformExprModulo(node)
                is PartiqlAst.Expr.Concat -> transformExprConcat(node)
                is PartiqlAst.Expr.And -> transformExprAnd(node)
                is PartiqlAst.Expr.Or -> transformExprOr(node)
                is PartiqlAst.Expr.Eq -> transformExprEq(node)
                is PartiqlAst.Expr.Ne -> transformExprNe(node)
                is PartiqlAst.Expr.Gt -> transformExprGt(node)
                is PartiqlAst.Expr.Gte -> transformExprGte(node)
                is PartiqlAst.Expr.Lt -> transformExprLt(node)
                is PartiqlAst.Expr.Lte -> transformExprLte(node)
                is PartiqlAst.Expr.Like -> transformExprLike(node)
                is PartiqlAst.Expr.Between -> transformExprBetween(node)
                is PartiqlAst.Expr.InCollection -> transformExprInCollection(node)
                is PartiqlAst.Expr.IsType -> transformExprIsType(node)
                is PartiqlAst.Expr.SimpleCase -> transformExprSimpleCase(node)
                is PartiqlAst.Expr.SearchedCase -> transformExprSearchedCase(node)
                is PartiqlAst.Expr.Struct -> transformExprStruct(node)
                is PartiqlAst.Expr.Bag -> transformExprBag(node)
                is PartiqlAst.Expr.List -> transformExprList(node)
                is PartiqlAst.Expr.Sexp -> transformExprSexp(node)
                is PartiqlAst.Expr.Date -> transformExprDate(node)
                is PartiqlAst.Expr.LitTime -> transformExprLitTime(node)
                is PartiqlAst.Expr.Union -> transformExprUnion(node)
                is PartiqlAst.Expr.Except -> transformExprExcept(node)
                is PartiqlAst.Expr.Intersect -> transformExprIntersect(node)
                is PartiqlAst.Expr.Path -> transformExprPath(node)
                is PartiqlAst.Expr.Call -> transformExprCall(node)
                is PartiqlAst.Expr.CallAgg -> transformExprCallAgg(node)
                is PartiqlAst.Expr.Cast -> transformExprCast(node)
                is PartiqlAst.Expr.CanCast -> transformExprCanCast(node)
                is PartiqlAst.Expr.CanLosslessCast -> transformExprCanLosslessCast(node)
                is PartiqlAst.Expr.NullIf -> transformExprNullIf(node)
                is PartiqlAst.Expr.Coalesce -> transformExprCoalesce(node)
                is PartiqlAst.Expr.Select -> transformExprSelect(node)
            }
        // Variant ExprMissing
        open fun transformExprMissing(node: PartiqlAst.Expr.Missing): PartiqlAst.Expr  {
            val new_metas = transformExprMissing_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Missing(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprMissing_metas(node: PartiqlAst.Expr.Missing) =
            transformMetas(node.metas)
    
        // Variant ExprLit
        open fun transformExprLit(node: PartiqlAst.Expr.Lit): PartiqlAst.Expr  {
            val new_value = transformExprLit_value(node)
            val new_metas = transformExprLit_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Lit(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLit_value(node: PartiqlAst.Expr.Lit) =
            transformAnyElement(node.value)
        open fun transformExprLit_metas(node: PartiqlAst.Expr.Lit) =
            transformMetas(node.metas)
    
        // Variant ExprId
        open fun transformExprId(node: PartiqlAst.Expr.Id): PartiqlAst.Expr  {
            val new_name = transformExprId_name(node)
            val new_case = transformExprId_case(node)
            val new_qualifier = transformExprId_qualifier(node)
            val new_metas = transformExprId_metas(node)
            return if (
                node.name !== new_name ||
                node.case !== new_case ||
                node.qualifier !== new_qualifier ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Id(
                    name = new_name,
                    case = new_case,
                    qualifier = new_qualifier,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprId_name(node: PartiqlAst.Expr.Id) =
            transformSymbolPrimitive(node.name)
        open fun transformExprId_case(node: PartiqlAst.Expr.Id) =
            transformCaseSensitivity(node.case)
        open fun transformExprId_qualifier(node: PartiqlAst.Expr.Id) =
            transformScopeQualifier(node.qualifier)
        open fun transformExprId_metas(node: PartiqlAst.Expr.Id) =
            transformMetas(node.metas)
    
        // Variant ExprParameter
        open fun transformExprParameter(node: PartiqlAst.Expr.Parameter): PartiqlAst.Expr  {
            val new_index = transformExprParameter_index(node)
            val new_metas = transformExprParameter_metas(node)
            return if (
                node.index !== new_index ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Parameter(
                    index = new_index,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprParameter_index(node: PartiqlAst.Expr.Parameter) =
            transformLongPrimitive(node.index)
        open fun transformExprParameter_metas(node: PartiqlAst.Expr.Parameter) =
            transformMetas(node.metas)
    
        // Variant ExprNot
        open fun transformExprNot(node: PartiqlAst.Expr.Not): PartiqlAst.Expr  {
            val new_expr = transformExprNot_expr(node)
            val new_metas = transformExprNot_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Not(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNot_expr(node: PartiqlAst.Expr.Not) =
            transformExpr(node.expr)
        open fun transformExprNot_metas(node: PartiqlAst.Expr.Not) =
            transformMetas(node.metas)
    
        // Variant ExprPos
        open fun transformExprPos(node: PartiqlAst.Expr.Pos): PartiqlAst.Expr  {
            val new_expr = transformExprPos_expr(node)
            val new_metas = transformExprPos_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Pos(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPos_expr(node: PartiqlAst.Expr.Pos) =
            transformExpr(node.expr)
        open fun transformExprPos_metas(node: PartiqlAst.Expr.Pos) =
            transformMetas(node.metas)
    
        // Variant ExprNeg
        open fun transformExprNeg(node: PartiqlAst.Expr.Neg): PartiqlAst.Expr  {
            val new_expr = transformExprNeg_expr(node)
            val new_metas = transformExprNeg_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Neg(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNeg_expr(node: PartiqlAst.Expr.Neg) =
            transformExpr(node.expr)
        open fun transformExprNeg_metas(node: PartiqlAst.Expr.Neg) =
            transformMetas(node.metas)
    
        // Variant ExprPlus
        open fun transformExprPlus(node: PartiqlAst.Expr.Plus): PartiqlAst.Expr  {
            val new_operands = transformExprPlus_operands(node)
            val new_metas = transformExprPlus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Plus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPlus_operands(node: PartiqlAst.Expr.Plus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprPlus_metas(node: PartiqlAst.Expr.Plus) =
            transformMetas(node.metas)
    
        // Variant ExprMinus
        open fun transformExprMinus(node: PartiqlAst.Expr.Minus): PartiqlAst.Expr  {
            val new_operands = transformExprMinus_operands(node)
            val new_metas = transformExprMinus_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Minus(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprMinus_operands(node: PartiqlAst.Expr.Minus) =
            node.operands.map { transformExpr(it) }
        open fun transformExprMinus_metas(node: PartiqlAst.Expr.Minus) =
            transformMetas(node.metas)
    
        // Variant ExprTimes
        open fun transformExprTimes(node: PartiqlAst.Expr.Times): PartiqlAst.Expr  {
            val new_operands = transformExprTimes_operands(node)
            val new_metas = transformExprTimes_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Times(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprTimes_operands(node: PartiqlAst.Expr.Times) =
            node.operands.map { transformExpr(it) }
        open fun transformExprTimes_metas(node: PartiqlAst.Expr.Times) =
            transformMetas(node.metas)
    
        // Variant ExprDivide
        open fun transformExprDivide(node: PartiqlAst.Expr.Divide): PartiqlAst.Expr  {
            val new_operands = transformExprDivide_operands(node)
            val new_metas = transformExprDivide_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Divide(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprDivide_operands(node: PartiqlAst.Expr.Divide) =
            node.operands.map { transformExpr(it) }
        open fun transformExprDivide_metas(node: PartiqlAst.Expr.Divide) =
            transformMetas(node.metas)
    
        // Variant ExprModulo
        open fun transformExprModulo(node: PartiqlAst.Expr.Modulo): PartiqlAst.Expr  {
            val new_operands = transformExprModulo_operands(node)
            val new_metas = transformExprModulo_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Modulo(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprModulo_operands(node: PartiqlAst.Expr.Modulo) =
            node.operands.map { transformExpr(it) }
        open fun transformExprModulo_metas(node: PartiqlAst.Expr.Modulo) =
            transformMetas(node.metas)
    
        // Variant ExprConcat
        open fun transformExprConcat(node: PartiqlAst.Expr.Concat): PartiqlAst.Expr  {
            val new_operands = transformExprConcat_operands(node)
            val new_metas = transformExprConcat_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Concat(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprConcat_operands(node: PartiqlAst.Expr.Concat) =
            node.operands.map { transformExpr(it) }
        open fun transformExprConcat_metas(node: PartiqlAst.Expr.Concat) =
            transformMetas(node.metas)
    
        // Variant ExprAnd
        open fun transformExprAnd(node: PartiqlAst.Expr.And): PartiqlAst.Expr  {
            val new_operands = transformExprAnd_operands(node)
            val new_metas = transformExprAnd_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.And(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprAnd_operands(node: PartiqlAst.Expr.And) =
            node.operands.map { transformExpr(it) }
        open fun transformExprAnd_metas(node: PartiqlAst.Expr.And) =
            transformMetas(node.metas)
    
        // Variant ExprOr
        open fun transformExprOr(node: PartiqlAst.Expr.Or): PartiqlAst.Expr  {
            val new_operands = transformExprOr_operands(node)
            val new_metas = transformExprOr_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Or(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprOr_operands(node: PartiqlAst.Expr.Or) =
            node.operands.map { transformExpr(it) }
        open fun transformExprOr_metas(node: PartiqlAst.Expr.Or) =
            transformMetas(node.metas)
    
        // Variant ExprEq
        open fun transformExprEq(node: PartiqlAst.Expr.Eq): PartiqlAst.Expr  {
            val new_operands = transformExprEq_operands(node)
            val new_metas = transformExprEq_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Eq(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprEq_operands(node: PartiqlAst.Expr.Eq) =
            node.operands.map { transformExpr(it) }
        open fun transformExprEq_metas(node: PartiqlAst.Expr.Eq) =
            transformMetas(node.metas)
    
        // Variant ExprNe
        open fun transformExprNe(node: PartiqlAst.Expr.Ne): PartiqlAst.Expr  {
            val new_operands = transformExprNe_operands(node)
            val new_metas = transformExprNe_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Ne(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNe_operands(node: PartiqlAst.Expr.Ne) =
            node.operands.map { transformExpr(it) }
        open fun transformExprNe_metas(node: PartiqlAst.Expr.Ne) =
            transformMetas(node.metas)
    
        // Variant ExprGt
        open fun transformExprGt(node: PartiqlAst.Expr.Gt): PartiqlAst.Expr  {
            val new_operands = transformExprGt_operands(node)
            val new_metas = transformExprGt_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Gt(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprGt_operands(node: PartiqlAst.Expr.Gt) =
            node.operands.map { transformExpr(it) }
        open fun transformExprGt_metas(node: PartiqlAst.Expr.Gt) =
            transformMetas(node.metas)
    
        // Variant ExprGte
        open fun transformExprGte(node: PartiqlAst.Expr.Gte): PartiqlAst.Expr  {
            val new_operands = transformExprGte_operands(node)
            val new_metas = transformExprGte_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Gte(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprGte_operands(node: PartiqlAst.Expr.Gte) =
            node.operands.map { transformExpr(it) }
        open fun transformExprGte_metas(node: PartiqlAst.Expr.Gte) =
            transformMetas(node.metas)
    
        // Variant ExprLt
        open fun transformExprLt(node: PartiqlAst.Expr.Lt): PartiqlAst.Expr  {
            val new_operands = transformExprLt_operands(node)
            val new_metas = transformExprLt_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Lt(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLt_operands(node: PartiqlAst.Expr.Lt) =
            node.operands.map { transformExpr(it) }
        open fun transformExprLt_metas(node: PartiqlAst.Expr.Lt) =
            transformMetas(node.metas)
    
        // Variant ExprLte
        open fun transformExprLte(node: PartiqlAst.Expr.Lte): PartiqlAst.Expr  {
            val new_operands = transformExprLte_operands(node)
            val new_metas = transformExprLte_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Lte(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLte_operands(node: PartiqlAst.Expr.Lte) =
            node.operands.map { transformExpr(it) }
        open fun transformExprLte_metas(node: PartiqlAst.Expr.Lte) =
            transformMetas(node.metas)
    
        // Variant ExprLike
        open fun transformExprLike(node: PartiqlAst.Expr.Like): PartiqlAst.Expr  {
            val new_value = transformExprLike_value(node)
            val new_pattern = transformExprLike_pattern(node)
            val new_escape = transformExprLike_escape(node)
            val new_metas = transformExprLike_metas(node)
            return if (
                node.value !== new_value ||
                node.pattern !== new_pattern ||
                node.escape !== new_escape ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Like(
                    value = new_value,
                    pattern = new_pattern,
                    escape = new_escape,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLike_value(node: PartiqlAst.Expr.Like) =
            transformExpr(node.value)
        open fun transformExprLike_pattern(node: PartiqlAst.Expr.Like) =
            transformExpr(node.pattern)
        open fun transformExprLike_escape(node: PartiqlAst.Expr.Like) =
            node.escape?.let { transformExpr(it) }
        open fun transformExprLike_metas(node: PartiqlAst.Expr.Like) =
            transformMetas(node.metas)
    
        // Variant ExprBetween
        open fun transformExprBetween(node: PartiqlAst.Expr.Between): PartiqlAst.Expr  {
            val new_value = transformExprBetween_value(node)
            val new_from = transformExprBetween_from(node)
            val new_to = transformExprBetween_to(node)
            val new_metas = transformExprBetween_metas(node)
            return if (
                node.value !== new_value ||
                node.from !== new_from ||
                node.to !== new_to ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Between(
                    value = new_value,
                    from = new_from,
                    to = new_to,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBetween_value(node: PartiqlAst.Expr.Between) =
            transformExpr(node.value)
        open fun transformExprBetween_from(node: PartiqlAst.Expr.Between) =
            transformExpr(node.from)
        open fun transformExprBetween_to(node: PartiqlAst.Expr.Between) =
            transformExpr(node.to)
        open fun transformExprBetween_metas(node: PartiqlAst.Expr.Between) =
            transformMetas(node.metas)
    
        // Variant ExprInCollection
        open fun transformExprInCollection(node: PartiqlAst.Expr.InCollection): PartiqlAst.Expr  {
            val new_operands = transformExprInCollection_operands(node)
            val new_metas = transformExprInCollection_metas(node)
            return if (
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.InCollection(
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprInCollection_operands(node: PartiqlAst.Expr.InCollection) =
            node.operands.map { transformExpr(it) }
        open fun transformExprInCollection_metas(node: PartiqlAst.Expr.InCollection) =
            transformMetas(node.metas)
    
        // Variant ExprIsType
        open fun transformExprIsType(node: PartiqlAst.Expr.IsType): PartiqlAst.Expr  {
            val new_value = transformExprIsType_value(node)
            val new_type = transformExprIsType_type(node)
            val new_metas = transformExprIsType_metas(node)
            return if (
                node.value !== new_value ||
                node.type !== new_type ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.IsType(
                    value = new_value,
                    type = new_type,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprIsType_value(node: PartiqlAst.Expr.IsType) =
            transformExpr(node.value)
        open fun transformExprIsType_type(node: PartiqlAst.Expr.IsType) =
            transformType(node.type)
        open fun transformExprIsType_metas(node: PartiqlAst.Expr.IsType) =
            transformMetas(node.metas)
    
        // Variant ExprSimpleCase
        open fun transformExprSimpleCase(node: PartiqlAst.Expr.SimpleCase): PartiqlAst.Expr  {
            val new_expr = transformExprSimpleCase_expr(node)
            val new_cases = transformExprSimpleCase_cases(node)
            val new_default = transformExprSimpleCase_default(node)
            val new_metas = transformExprSimpleCase_metas(node)
            return if (
                node.expr !== new_expr ||
                node.cases !== new_cases ||
                node.default !== new_default ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.SimpleCase(
                    expr = new_expr,
                    cases = new_cases,
                    default = new_default,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSimpleCase_expr(node: PartiqlAst.Expr.SimpleCase) =
            transformExpr(node.expr)
        open fun transformExprSimpleCase_cases(node: PartiqlAst.Expr.SimpleCase) =
            transformExprPairList(node.cases)
        open fun transformExprSimpleCase_default(node: PartiqlAst.Expr.SimpleCase) =
            node.default?.let { transformExpr(it) }
        open fun transformExprSimpleCase_metas(node: PartiqlAst.Expr.SimpleCase) =
            transformMetas(node.metas)
    
        // Variant ExprSearchedCase
        open fun transformExprSearchedCase(node: PartiqlAst.Expr.SearchedCase): PartiqlAst.Expr  {
            val new_cases = transformExprSearchedCase_cases(node)
            val new_default = transformExprSearchedCase_default(node)
            val new_metas = transformExprSearchedCase_metas(node)
            return if (
                node.cases !== new_cases ||
                node.default !== new_default ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.SearchedCase(
                    cases = new_cases,
                    default = new_default,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSearchedCase_cases(node: PartiqlAst.Expr.SearchedCase) =
            transformExprPairList(node.cases)
        open fun transformExprSearchedCase_default(node: PartiqlAst.Expr.SearchedCase) =
            node.default?.let { transformExpr(it) }
        open fun transformExprSearchedCase_metas(node: PartiqlAst.Expr.SearchedCase) =
            transformMetas(node.metas)
    
        // Variant ExprStruct
        open fun transformExprStruct(node: PartiqlAst.Expr.Struct): PartiqlAst.Expr  {
            val new_fields = transformExprStruct_fields(node)
            val new_metas = transformExprStruct_metas(node)
            return if (
                node.fields !== new_fields ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Struct(
                    fields = new_fields,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprStruct_fields(node: PartiqlAst.Expr.Struct) =
            node.fields.map { transformExprPair(it) }
        open fun transformExprStruct_metas(node: PartiqlAst.Expr.Struct) =
            transformMetas(node.metas)
    
        // Variant ExprBag
        open fun transformExprBag(node: PartiqlAst.Expr.Bag): PartiqlAst.Expr  {
            val new_values = transformExprBag_values(node)
            val new_metas = transformExprBag_metas(node)
            return if (
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Bag(
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprBag_values(node: PartiqlAst.Expr.Bag) =
            node.values.map { transformExpr(it) }
        open fun transformExprBag_metas(node: PartiqlAst.Expr.Bag) =
            transformMetas(node.metas)
    
        // Variant ExprList
        open fun transformExprList(node: PartiqlAst.Expr.List): PartiqlAst.Expr  {
            val new_values = transformExprList_values(node)
            val new_metas = transformExprList_metas(node)
            return if (
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.List(
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprList_values(node: PartiqlAst.Expr.List) =
            node.values.map { transformExpr(it) }
        open fun transformExprList_metas(node: PartiqlAst.Expr.List) =
            transformMetas(node.metas)
    
        // Variant ExprSexp
        open fun transformExprSexp(node: PartiqlAst.Expr.Sexp): PartiqlAst.Expr  {
            val new_values = transformExprSexp_values(node)
            val new_metas = transformExprSexp_metas(node)
            return if (
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Sexp(
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSexp_values(node: PartiqlAst.Expr.Sexp) =
            node.values.map { transformExpr(it) }
        open fun transformExprSexp_metas(node: PartiqlAst.Expr.Sexp) =
            transformMetas(node.metas)
    
        // Variant ExprDate
        open fun transformExprDate(node: PartiqlAst.Expr.Date): PartiqlAst.Expr  {
            val new_year = transformExprDate_year(node)
            val new_month = transformExprDate_month(node)
            val new_day = transformExprDate_day(node)
            val new_metas = transformExprDate_metas(node)
            return if (
                node.year !== new_year ||
                node.month !== new_month ||
                node.day !== new_day ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Date(
                    year = new_year,
                    month = new_month,
                    day = new_day,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprDate_year(node: PartiqlAst.Expr.Date) =
            transformLongPrimitive(node.year)
        open fun transformExprDate_month(node: PartiqlAst.Expr.Date) =
            transformLongPrimitive(node.month)
        open fun transformExprDate_day(node: PartiqlAst.Expr.Date) =
            transformLongPrimitive(node.day)
        open fun transformExprDate_metas(node: PartiqlAst.Expr.Date) =
            transformMetas(node.metas)
    
        // Variant ExprLitTime
        open fun transformExprLitTime(node: PartiqlAst.Expr.LitTime): PartiqlAst.Expr  {
            val new_value = transformExprLitTime_value(node)
            val new_metas = transformExprLitTime_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.LitTime(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprLitTime_value(node: PartiqlAst.Expr.LitTime) =
            transformTimeValue(node.value)
        open fun transformExprLitTime_metas(node: PartiqlAst.Expr.LitTime) =
            transformMetas(node.metas)
    
        // Variant ExprUnion
        open fun transformExprUnion(node: PartiqlAst.Expr.Union): PartiqlAst.Expr  {
            val new_setq = transformExprUnion_setq(node)
            val new_operands = transformExprUnion_operands(node)
            val new_metas = transformExprUnion_metas(node)
            return if (
                node.setq !== new_setq ||
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Union(
                    setq = new_setq,
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprUnion_setq(node: PartiqlAst.Expr.Union) =
            transformSetQuantifier(node.setq)
        open fun transformExprUnion_operands(node: PartiqlAst.Expr.Union) =
            node.operands.map { transformExpr(it) }
        open fun transformExprUnion_metas(node: PartiqlAst.Expr.Union) =
            transformMetas(node.metas)
    
        // Variant ExprExcept
        open fun transformExprExcept(node: PartiqlAst.Expr.Except): PartiqlAst.Expr  {
            val new_setq = transformExprExcept_setq(node)
            val new_operands = transformExprExcept_operands(node)
            val new_metas = transformExprExcept_metas(node)
            return if (
                node.setq !== new_setq ||
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Except(
                    setq = new_setq,
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprExcept_setq(node: PartiqlAst.Expr.Except) =
            transformSetQuantifier(node.setq)
        open fun transformExprExcept_operands(node: PartiqlAst.Expr.Except) =
            node.operands.map { transformExpr(it) }
        open fun transformExprExcept_metas(node: PartiqlAst.Expr.Except) =
            transformMetas(node.metas)
    
        // Variant ExprIntersect
        open fun transformExprIntersect(node: PartiqlAst.Expr.Intersect): PartiqlAst.Expr  {
            val new_setq = transformExprIntersect_setq(node)
            val new_operands = transformExprIntersect_operands(node)
            val new_metas = transformExprIntersect_metas(node)
            return if (
                node.setq !== new_setq ||
                node.operands !== new_operands ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Intersect(
                    setq = new_setq,
                    operands = new_operands,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprIntersect_setq(node: PartiqlAst.Expr.Intersect) =
            transformSetQuantifier(node.setq)
        open fun transformExprIntersect_operands(node: PartiqlAst.Expr.Intersect) =
            node.operands.map { transformExpr(it) }
        open fun transformExprIntersect_metas(node: PartiqlAst.Expr.Intersect) =
            transformMetas(node.metas)
    
        // Variant ExprPath
        open fun transformExprPath(node: PartiqlAst.Expr.Path): PartiqlAst.Expr  {
            val new_root = transformExprPath_root(node)
            val new_steps = transformExprPath_steps(node)
            val new_metas = transformExprPath_metas(node)
            return if (
                node.root !== new_root ||
                node.steps !== new_steps ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Path(
                    root = new_root,
                    steps = new_steps,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprPath_root(node: PartiqlAst.Expr.Path) =
            transformExpr(node.root)
        open fun transformExprPath_steps(node: PartiqlAst.Expr.Path) =
            node.steps.map { transformPathStep(it) }
        open fun transformExprPath_metas(node: PartiqlAst.Expr.Path) =
            transformMetas(node.metas)
    
        // Variant ExprCall
        open fun transformExprCall(node: PartiqlAst.Expr.Call): PartiqlAst.Expr  {
            val new_funcName = transformExprCall_funcName(node)
            val new_args = transformExprCall_args(node)
            val new_metas = transformExprCall_metas(node)
            return if (
                node.funcName !== new_funcName ||
                node.args !== new_args ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Call(
                    funcName = new_funcName,
                    args = new_args,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCall_funcName(node: PartiqlAst.Expr.Call) =
            transformSymbolPrimitive(node.funcName)
        open fun transformExprCall_args(node: PartiqlAst.Expr.Call) =
            node.args.map { transformExpr(it) }
        open fun transformExprCall_metas(node: PartiqlAst.Expr.Call) =
            transformMetas(node.metas)
    
        // Variant ExprCallAgg
        open fun transformExprCallAgg(node: PartiqlAst.Expr.CallAgg): PartiqlAst.Expr  {
            val new_setq = transformExprCallAgg_setq(node)
            val new_funcName = transformExprCallAgg_funcName(node)
            val new_arg = transformExprCallAgg_arg(node)
            val new_metas = transformExprCallAgg_metas(node)
            return if (
                node.setq !== new_setq ||
                node.funcName !== new_funcName ||
                node.arg !== new_arg ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.CallAgg(
                    setq = new_setq,
                    funcName = new_funcName,
                    arg = new_arg,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCallAgg_setq(node: PartiqlAst.Expr.CallAgg) =
            transformSetQuantifier(node.setq)
        open fun transformExprCallAgg_funcName(node: PartiqlAst.Expr.CallAgg) =
            transformSymbolPrimitive(node.funcName)
        open fun transformExprCallAgg_arg(node: PartiqlAst.Expr.CallAgg) =
            transformExpr(node.arg)
        open fun transformExprCallAgg_metas(node: PartiqlAst.Expr.CallAgg) =
            transformMetas(node.metas)
    
        // Variant ExprCast
        open fun transformExprCast(node: PartiqlAst.Expr.Cast): PartiqlAst.Expr  {
            val new_value = transformExprCast_value(node)
            val new_asType = transformExprCast_asType(node)
            val new_metas = transformExprCast_metas(node)
            return if (
                node.value !== new_value ||
                node.asType !== new_asType ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Cast(
                    value = new_value,
                    asType = new_asType,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCast_value(node: PartiqlAst.Expr.Cast) =
            transformExpr(node.value)
        open fun transformExprCast_asType(node: PartiqlAst.Expr.Cast) =
            transformType(node.asType)
        open fun transformExprCast_metas(node: PartiqlAst.Expr.Cast) =
            transformMetas(node.metas)
    
        // Variant ExprCanCast
        open fun transformExprCanCast(node: PartiqlAst.Expr.CanCast): PartiqlAst.Expr  {
            val new_value = transformExprCanCast_value(node)
            val new_asType = transformExprCanCast_asType(node)
            val new_metas = transformExprCanCast_metas(node)
            return if (
                node.value !== new_value ||
                node.asType !== new_asType ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.CanCast(
                    value = new_value,
                    asType = new_asType,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCanCast_value(node: PartiqlAst.Expr.CanCast) =
            transformExpr(node.value)
        open fun transformExprCanCast_asType(node: PartiqlAst.Expr.CanCast) =
            transformType(node.asType)
        open fun transformExprCanCast_metas(node: PartiqlAst.Expr.CanCast) =
            transformMetas(node.metas)
    
        // Variant ExprCanLosslessCast
        open fun transformExprCanLosslessCast(node: PartiqlAst.Expr.CanLosslessCast): PartiqlAst.Expr  {
            val new_value = transformExprCanLosslessCast_value(node)
            val new_asType = transformExprCanLosslessCast_asType(node)
            val new_metas = transformExprCanLosslessCast_metas(node)
            return if (
                node.value !== new_value ||
                node.asType !== new_asType ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.CanLosslessCast(
                    value = new_value,
                    asType = new_asType,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCanLosslessCast_value(node: PartiqlAst.Expr.CanLosslessCast) =
            transformExpr(node.value)
        open fun transformExprCanLosslessCast_asType(node: PartiqlAst.Expr.CanLosslessCast) =
            transformType(node.asType)
        open fun transformExprCanLosslessCast_metas(node: PartiqlAst.Expr.CanLosslessCast) =
            transformMetas(node.metas)
    
        // Variant ExprNullIf
        open fun transformExprNullIf(node: PartiqlAst.Expr.NullIf): PartiqlAst.Expr  {
            val new_expr1 = transformExprNullIf_expr1(node)
            val new_expr2 = transformExprNullIf_expr2(node)
            val new_metas = transformExprNullIf_metas(node)
            return if (
                node.expr1 !== new_expr1 ||
                node.expr2 !== new_expr2 ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.NullIf(
                    expr1 = new_expr1,
                    expr2 = new_expr2,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprNullIf_expr1(node: PartiqlAst.Expr.NullIf) =
            transformExpr(node.expr1)
        open fun transformExprNullIf_expr2(node: PartiqlAst.Expr.NullIf) =
            transformExpr(node.expr2)
        open fun transformExprNullIf_metas(node: PartiqlAst.Expr.NullIf) =
            transformMetas(node.metas)
    
        // Variant ExprCoalesce
        open fun transformExprCoalesce(node: PartiqlAst.Expr.Coalesce): PartiqlAst.Expr  {
            val new_args = transformExprCoalesce_args(node)
            val new_metas = transformExprCoalesce_metas(node)
            return if (
                node.args !== new_args ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Coalesce(
                    args = new_args,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprCoalesce_args(node: PartiqlAst.Expr.Coalesce) =
            node.args.map { transformExpr(it) }
        open fun transformExprCoalesce_metas(node: PartiqlAst.Expr.Coalesce) =
            transformMetas(node.metas)
    
        // Variant ExprSelect
        open fun transformExprSelect(node: PartiqlAst.Expr.Select): PartiqlAst.Expr  {
            val new_setq = transformExprSelect_setq(node)
            val new_project = transformExprSelect_project(node)
            val new_from = transformExprSelect_from(node)
            val new_fromLet = transformExprSelect_fromLet(node)
            val new_where = transformExprSelect_where(node)
            val new_group = transformExprSelect_group(node)
            val new_having = transformExprSelect_having(node)
            val new_order = transformExprSelect_order(node)
            val new_limit = transformExprSelect_limit(node)
            val new_metas = transformExprSelect_metas(node)
            return if (
                node.setq !== new_setq ||
                node.project !== new_project ||
                node.from !== new_from ||
                node.fromLet !== new_fromLet ||
                node.where !== new_where ||
                node.group !== new_group ||
                node.having !== new_having ||
                node.order !== new_order ||
                node.limit !== new_limit ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Expr.Select(
                    setq = new_setq,
                    project = new_project,
                    from = new_from,
                    fromLet = new_fromLet,
                    where = new_where,
                    group = new_group,
                    having = new_having,
                    order = new_order,
                    limit = new_limit,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformExprSelect_setq(node: PartiqlAst.Expr.Select) =
            node.setq?.let { transformSetQuantifier(it) }
        open fun transformExprSelect_project(node: PartiqlAst.Expr.Select) =
            transformProjection(node.project)
        open fun transformExprSelect_from(node: PartiqlAst.Expr.Select) =
            transformFromSource(node.from)
        open fun transformExprSelect_fromLet(node: PartiqlAst.Expr.Select) =
            node.fromLet?.let { transformLet(it) }
        open fun transformExprSelect_where(node: PartiqlAst.Expr.Select) =
            node.where?.let { transformExpr(it) }
        open fun transformExprSelect_group(node: PartiqlAst.Expr.Select) =
            node.group?.let { transformGroupBy(it) }
        open fun transformExprSelect_having(node: PartiqlAst.Expr.Select) =
            node.having?.let { transformExpr(it) }
        open fun transformExprSelect_order(node: PartiqlAst.Expr.Select) =
            node.order?.let { transformOrderBy(it) }
        open fun transformExprSelect_limit(node: PartiqlAst.Expr.Select) =
            node.limit?.let { transformExpr(it) }
        open fun transformExprSelect_metas(node: PartiqlAst.Expr.Select) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: PathStep
        //////////////////////////////////////
        open fun transformPathStep(node: PartiqlAst.PathStep): PartiqlAst.PathStep =
            when(node) {
                is PartiqlAst.PathStep.PathExpr -> transformPathStepPathExpr(node)
                is PartiqlAst.PathStep.PathWildcard -> transformPathStepPathWildcard(node)
                is PartiqlAst.PathStep.PathUnpivot -> transformPathStepPathUnpivot(node)
            }
        // Variant PathStepPathExpr
        open fun transformPathStepPathExpr(node: PartiqlAst.PathStep.PathExpr): PartiqlAst.PathStep  {
            val new_index = transformPathStepPathExpr_index(node)
            val new_case = transformPathStepPathExpr_case(node)
            val new_metas = transformPathStepPathExpr_metas(node)
            return if (
                node.index !== new_index ||
                node.case !== new_case ||
                node.metas !== new_metas
            ) {
                PartiqlAst.PathStep.PathExpr(
                    index = new_index,
                    case = new_case,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathStepPathExpr_index(node: PartiqlAst.PathStep.PathExpr) =
            transformExpr(node.index)
        open fun transformPathStepPathExpr_case(node: PartiqlAst.PathStep.PathExpr) =
            transformCaseSensitivity(node.case)
        open fun transformPathStepPathExpr_metas(node: PartiqlAst.PathStep.PathExpr) =
            transformMetas(node.metas)
    
        // Variant PathStepPathWildcard
        open fun transformPathStepPathWildcard(node: PartiqlAst.PathStep.PathWildcard): PartiqlAst.PathStep  {
            val new_metas = transformPathStepPathWildcard_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.PathStep.PathWildcard(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathStepPathWildcard_metas(node: PartiqlAst.PathStep.PathWildcard) =
            transformMetas(node.metas)
    
        // Variant PathStepPathUnpivot
        open fun transformPathStepPathUnpivot(node: PartiqlAst.PathStep.PathUnpivot): PartiqlAst.PathStep  {
            val new_metas = transformPathStepPathUnpivot_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.PathStep.PathUnpivot(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformPathStepPathUnpivot_metas(node: PartiqlAst.PathStep.PathUnpivot) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Projection
        //////////////////////////////////////
        open fun transformProjection(node: PartiqlAst.Projection): PartiqlAst.Projection =
            when(node) {
                is PartiqlAst.Projection.ProjectStar -> transformProjectionProjectStar(node)
                is PartiqlAst.Projection.ProjectList -> transformProjectionProjectList(node)
                is PartiqlAst.Projection.ProjectPivot -> transformProjectionProjectPivot(node)
                is PartiqlAst.Projection.ProjectValue -> transformProjectionProjectValue(node)
            }
        // Variant ProjectionProjectStar
        open fun transformProjectionProjectStar(node: PartiqlAst.Projection.ProjectStar): PartiqlAst.Projection  {
            val new_metas = transformProjectionProjectStar_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Projection.ProjectStar(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectStar_metas(node: PartiqlAst.Projection.ProjectStar) =
            transformMetas(node.metas)
    
        // Variant ProjectionProjectList
        open fun transformProjectionProjectList(node: PartiqlAst.Projection.ProjectList): PartiqlAst.Projection  {
            val new_projectItems = transformProjectionProjectList_projectItems(node)
            val new_metas = transformProjectionProjectList_metas(node)
            return if (
                node.projectItems !== new_projectItems ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Projection.ProjectList(
                    projectItems = new_projectItems,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectList_projectItems(node: PartiqlAst.Projection.ProjectList) =
            node.projectItems.map { transformProjectItem(it) }
        open fun transformProjectionProjectList_metas(node: PartiqlAst.Projection.ProjectList) =
            transformMetas(node.metas)
    
        // Variant ProjectionProjectPivot
        open fun transformProjectionProjectPivot(node: PartiqlAst.Projection.ProjectPivot): PartiqlAst.Projection  {
            val new_value = transformProjectionProjectPivot_value(node)
            val new_key = transformProjectionProjectPivot_key(node)
            val new_metas = transformProjectionProjectPivot_metas(node)
            return if (
                node.value !== new_value ||
                node.key !== new_key ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Projection.ProjectPivot(
                    value = new_value,
                    key = new_key,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectPivot_value(node: PartiqlAst.Projection.ProjectPivot) =
            transformExpr(node.value)
        open fun transformProjectionProjectPivot_key(node: PartiqlAst.Projection.ProjectPivot) =
            transformExpr(node.key)
        open fun transformProjectionProjectPivot_metas(node: PartiqlAst.Projection.ProjectPivot) =
            transformMetas(node.metas)
    
        // Variant ProjectionProjectValue
        open fun transformProjectionProjectValue(node: PartiqlAst.Projection.ProjectValue): PartiqlAst.Projection  {
            val new_value = transformProjectionProjectValue_value(node)
            val new_metas = transformProjectionProjectValue_metas(node)
            return if (
                node.value !== new_value ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Projection.ProjectValue(
                    value = new_value,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectionProjectValue_value(node: PartiqlAst.Projection.ProjectValue) =
            transformExpr(node.value)
        open fun transformProjectionProjectValue_metas(node: PartiqlAst.Projection.ProjectValue) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ProjectItem
        //////////////////////////////////////
        open fun transformProjectItem(node: PartiqlAst.ProjectItem): PartiqlAst.ProjectItem =
            when(node) {
                is PartiqlAst.ProjectItem.ProjectAll -> transformProjectItemProjectAll(node)
                is PartiqlAst.ProjectItem.ProjectExpr -> transformProjectItemProjectExpr(node)
            }
        // Variant ProjectItemProjectAll
        open fun transformProjectItemProjectAll(node: PartiqlAst.ProjectItem.ProjectAll): PartiqlAst.ProjectItem  {
            val new_expr = transformProjectItemProjectAll_expr(node)
            val new_metas = transformProjectItemProjectAll_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ProjectItem.ProjectAll(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectItemProjectAll_expr(node: PartiqlAst.ProjectItem.ProjectAll) =
            transformExpr(node.expr)
        open fun transformProjectItemProjectAll_metas(node: PartiqlAst.ProjectItem.ProjectAll) =
            transformMetas(node.metas)
    
        // Variant ProjectItemProjectExpr
        open fun transformProjectItemProjectExpr(node: PartiqlAst.ProjectItem.ProjectExpr): PartiqlAst.ProjectItem  {
            val new_expr = transformProjectItemProjectExpr_expr(node)
            val new_asAlias = transformProjectItemProjectExpr_asAlias(node)
            val new_metas = transformProjectItemProjectExpr_metas(node)
            return if (
                node.expr !== new_expr ||
                node.asAlias !== new_asAlias ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ProjectItem.ProjectExpr(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformProjectItemProjectExpr_expr(node: PartiqlAst.ProjectItem.ProjectExpr) =
            transformExpr(node.expr)
        open fun transformProjectItemProjectExpr_asAlias(node: PartiqlAst.ProjectItem.ProjectExpr) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformProjectItemProjectExpr_metas(node: PartiqlAst.ProjectItem.ProjectExpr) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: FromSource
        //////////////////////////////////////
        open fun transformFromSource(node: PartiqlAst.FromSource): PartiqlAst.FromSource =
            when(node) {
                is PartiqlAst.FromSource.Scan -> transformFromSourceScan(node)
                is PartiqlAst.FromSource.Unpivot -> transformFromSourceUnpivot(node)
                is PartiqlAst.FromSource.Join -> transformFromSourceJoin(node)
            }
        // Variant FromSourceScan
        open fun transformFromSourceScan(node: PartiqlAst.FromSource.Scan): PartiqlAst.FromSource  {
            val new_expr = transformFromSourceScan_expr(node)
            val new_asAlias = transformFromSourceScan_asAlias(node)
            val new_atAlias = transformFromSourceScan_atAlias(node)
            val new_byAlias = transformFromSourceScan_byAlias(node)
            val new_metas = transformFromSourceScan_metas(node)
            return if (
                node.expr !== new_expr ||
                node.asAlias !== new_asAlias ||
                node.atAlias !== new_atAlias ||
                node.byAlias !== new_byAlias ||
                node.metas !== new_metas
            ) {
                PartiqlAst.FromSource.Scan(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    atAlias = new_atAlias,
                    byAlias = new_byAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformFromSourceScan_expr(node: PartiqlAst.FromSource.Scan) =
            transformExpr(node.expr)
        open fun transformFromSourceScan_asAlias(node: PartiqlAst.FromSource.Scan) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_atAlias(node: PartiqlAst.FromSource.Scan) =
            node.atAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_byAlias(node: PartiqlAst.FromSource.Scan) =
            node.byAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceScan_metas(node: PartiqlAst.FromSource.Scan) =
            transformMetas(node.metas)
    
        // Variant FromSourceUnpivot
        open fun transformFromSourceUnpivot(node: PartiqlAst.FromSource.Unpivot): PartiqlAst.FromSource  {
            val new_expr = transformFromSourceUnpivot_expr(node)
            val new_asAlias = transformFromSourceUnpivot_asAlias(node)
            val new_atAlias = transformFromSourceUnpivot_atAlias(node)
            val new_byAlias = transformFromSourceUnpivot_byAlias(node)
            val new_metas = transformFromSourceUnpivot_metas(node)
            return if (
                node.expr !== new_expr ||
                node.asAlias !== new_asAlias ||
                node.atAlias !== new_atAlias ||
                node.byAlias !== new_byAlias ||
                node.metas !== new_metas
            ) {
                PartiqlAst.FromSource.Unpivot(
                    expr = new_expr,
                    asAlias = new_asAlias,
                    atAlias = new_atAlias,
                    byAlias = new_byAlias,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformFromSourceUnpivot_expr(node: PartiqlAst.FromSource.Unpivot) =
            transformExpr(node.expr)
        open fun transformFromSourceUnpivot_asAlias(node: PartiqlAst.FromSource.Unpivot) =
            node.asAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceUnpivot_atAlias(node: PartiqlAst.FromSource.Unpivot) =
            node.atAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceUnpivot_byAlias(node: PartiqlAst.FromSource.Unpivot) =
            node.byAlias?.let { transformSymbolPrimitive(it) }
        open fun transformFromSourceUnpivot_metas(node: PartiqlAst.FromSource.Unpivot) =
            transformMetas(node.metas)
    
        // Variant FromSourceJoin
        open fun transformFromSourceJoin(node: PartiqlAst.FromSource.Join): PartiqlAst.FromSource  {
            val new_type = transformFromSourceJoin_type(node)
            val new_left = transformFromSourceJoin_left(node)
            val new_right = transformFromSourceJoin_right(node)
            val new_predicate = transformFromSourceJoin_predicate(node)
            val new_metas = transformFromSourceJoin_metas(node)
            return if (
                node.type !== new_type ||
                node.left !== new_left ||
                node.right !== new_right ||
                node.predicate !== new_predicate ||
                node.metas !== new_metas
            ) {
                PartiqlAst.FromSource.Join(
                    type = new_type,
                    left = new_left,
                    right = new_right,
                    predicate = new_predicate,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformFromSourceJoin_type(node: PartiqlAst.FromSource.Join) =
            transformJoinType(node.type)
        open fun transformFromSourceJoin_left(node: PartiqlAst.FromSource.Join) =
            transformFromSource(node.left)
        open fun transformFromSourceJoin_right(node: PartiqlAst.FromSource.Join) =
            transformFromSource(node.right)
        open fun transformFromSourceJoin_predicate(node: PartiqlAst.FromSource.Join) =
            node.predicate?.let { transformExpr(it) }
        open fun transformFromSourceJoin_metas(node: PartiqlAst.FromSource.Join) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: JoinType
        //////////////////////////////////////
        open fun transformJoinType(node: PartiqlAst.JoinType): PartiqlAst.JoinType =
            when(node) {
                is PartiqlAst.JoinType.Inner -> transformJoinTypeInner(node)
                is PartiqlAst.JoinType.Left -> transformJoinTypeLeft(node)
                is PartiqlAst.JoinType.Right -> transformJoinTypeRight(node)
                is PartiqlAst.JoinType.Full -> transformJoinTypeFull(node)
            }
        // Variant JoinTypeInner
        open fun transformJoinTypeInner(node: PartiqlAst.JoinType.Inner): PartiqlAst.JoinType  {
            val new_metas = transformJoinTypeInner_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.JoinType.Inner(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeInner_metas(node: PartiqlAst.JoinType.Inner) =
            transformMetas(node.metas)
    
        // Variant JoinTypeLeft
        open fun transformJoinTypeLeft(node: PartiqlAst.JoinType.Left): PartiqlAst.JoinType  {
            val new_metas = transformJoinTypeLeft_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.JoinType.Left(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeLeft_metas(node: PartiqlAst.JoinType.Left) =
            transformMetas(node.metas)
    
        // Variant JoinTypeRight
        open fun transformJoinTypeRight(node: PartiqlAst.JoinType.Right): PartiqlAst.JoinType  {
            val new_metas = transformJoinTypeRight_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.JoinType.Right(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeRight_metas(node: PartiqlAst.JoinType.Right) =
            transformMetas(node.metas)
    
        // Variant JoinTypeFull
        open fun transformJoinTypeFull(node: PartiqlAst.JoinType.Full): PartiqlAst.JoinType  {
            val new_metas = transformJoinTypeFull_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.JoinType.Full(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformJoinTypeFull_metas(node: PartiqlAst.JoinType.Full) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: GroupingStrategy
        //////////////////////////////////////
        open fun transformGroupingStrategy(node: PartiqlAst.GroupingStrategy): PartiqlAst.GroupingStrategy =
            when(node) {
                is PartiqlAst.GroupingStrategy.GroupFull -> transformGroupingStrategyGroupFull(node)
                is PartiqlAst.GroupingStrategy.GroupPartial -> transformGroupingStrategyGroupPartial(node)
            }
        // Variant GroupingStrategyGroupFull
        open fun transformGroupingStrategyGroupFull(node: PartiqlAst.GroupingStrategy.GroupFull): PartiqlAst.GroupingStrategy  {
            val new_metas = transformGroupingStrategyGroupFull_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.GroupingStrategy.GroupFull(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupingStrategyGroupFull_metas(node: PartiqlAst.GroupingStrategy.GroupFull) =
            transformMetas(node.metas)
    
        // Variant GroupingStrategyGroupPartial
        open fun transformGroupingStrategyGroupPartial(node: PartiqlAst.GroupingStrategy.GroupPartial): PartiqlAst.GroupingStrategy  {
            val new_metas = transformGroupingStrategyGroupPartial_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.GroupingStrategy.GroupPartial(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformGroupingStrategyGroupPartial_metas(node: PartiqlAst.GroupingStrategy.GroupPartial) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: OrderingSpec
        //////////////////////////////////////
        open fun transformOrderingSpec(node: PartiqlAst.OrderingSpec): PartiqlAst.OrderingSpec =
            when(node) {
                is PartiqlAst.OrderingSpec.Asc -> transformOrderingSpecAsc(node)
                is PartiqlAst.OrderingSpec.Desc -> transformOrderingSpecDesc(node)
            }
        // Variant OrderingSpecAsc
        open fun transformOrderingSpecAsc(node: PartiqlAst.OrderingSpec.Asc): PartiqlAst.OrderingSpec  {
            val new_metas = transformOrderingSpecAsc_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.OrderingSpec.Asc(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOrderingSpecAsc_metas(node: PartiqlAst.OrderingSpec.Asc) =
            transformMetas(node.metas)
    
        // Variant OrderingSpecDesc
        open fun transformOrderingSpecDesc(node: PartiqlAst.OrderingSpec.Desc): PartiqlAst.OrderingSpec  {
            val new_metas = transformOrderingSpecDesc_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.OrderingSpec.Desc(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformOrderingSpecDesc_metas(node: PartiqlAst.OrderingSpec.Desc) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: CaseSensitivity
        //////////////////////////////////////
        open fun transformCaseSensitivity(node: PartiqlAst.CaseSensitivity): PartiqlAst.CaseSensitivity =
            when(node) {
                is PartiqlAst.CaseSensitivity.CaseSensitive -> transformCaseSensitivityCaseSensitive(node)
                is PartiqlAst.CaseSensitivity.CaseInsensitive -> transformCaseSensitivityCaseInsensitive(node)
            }
        // Variant CaseSensitivityCaseSensitive
        open fun transformCaseSensitivityCaseSensitive(node: PartiqlAst.CaseSensitivity.CaseSensitive): PartiqlAst.CaseSensitivity  {
            val new_metas = transformCaseSensitivityCaseSensitive_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.CaseSensitivity.CaseSensitive(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformCaseSensitivityCaseSensitive_metas(node: PartiqlAst.CaseSensitivity.CaseSensitive) =
            transformMetas(node.metas)
    
        // Variant CaseSensitivityCaseInsensitive
        open fun transformCaseSensitivityCaseInsensitive(node: PartiqlAst.CaseSensitivity.CaseInsensitive): PartiqlAst.CaseSensitivity  {
            val new_metas = transformCaseSensitivityCaseInsensitive_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.CaseSensitivity.CaseInsensitive(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformCaseSensitivityCaseInsensitive_metas(node: PartiqlAst.CaseSensitivity.CaseInsensitive) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ScopeQualifier
        //////////////////////////////////////
        open fun transformScopeQualifier(node: PartiqlAst.ScopeQualifier): PartiqlAst.ScopeQualifier =
            when(node) {
                is PartiqlAst.ScopeQualifier.Unqualified -> transformScopeQualifierUnqualified(node)
                is PartiqlAst.ScopeQualifier.LocalsFirst -> transformScopeQualifierLocalsFirst(node)
            }
        // Variant ScopeQualifierUnqualified
        open fun transformScopeQualifierUnqualified(node: PartiqlAst.ScopeQualifier.Unqualified): PartiqlAst.ScopeQualifier  {
            val new_metas = transformScopeQualifierUnqualified_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ScopeQualifier.Unqualified(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformScopeQualifierUnqualified_metas(node: PartiqlAst.ScopeQualifier.Unqualified) =
            transformMetas(node.metas)
    
        // Variant ScopeQualifierLocalsFirst
        open fun transformScopeQualifierLocalsFirst(node: PartiqlAst.ScopeQualifier.LocalsFirst): PartiqlAst.ScopeQualifier  {
            val new_metas = transformScopeQualifierLocalsFirst_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ScopeQualifier.LocalsFirst(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformScopeQualifierLocalsFirst_metas(node: PartiqlAst.ScopeQualifier.LocalsFirst) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: SetQuantifier
        //////////////////////////////////////
        open fun transformSetQuantifier(node: PartiqlAst.SetQuantifier): PartiqlAst.SetQuantifier =
            when(node) {
                is PartiqlAst.SetQuantifier.All -> transformSetQuantifierAll(node)
                is PartiqlAst.SetQuantifier.Distinct -> transformSetQuantifierDistinct(node)
            }
        // Variant SetQuantifierAll
        open fun transformSetQuantifierAll(node: PartiqlAst.SetQuantifier.All): PartiqlAst.SetQuantifier  {
            val new_metas = transformSetQuantifierAll_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.SetQuantifier.All(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSetQuantifierAll_metas(node: PartiqlAst.SetQuantifier.All) =
            transformMetas(node.metas)
    
        // Variant SetQuantifierDistinct
        open fun transformSetQuantifierDistinct(node: PartiqlAst.SetQuantifier.Distinct): PartiqlAst.SetQuantifier  {
            val new_metas = transformSetQuantifierDistinct_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.SetQuantifier.Distinct(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformSetQuantifierDistinct_metas(node: PartiqlAst.SetQuantifier.Distinct) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: DmlOp
        //////////////////////////////////////
        open fun transformDmlOp(node: PartiqlAst.DmlOp): PartiqlAst.DmlOp =
            when(node) {
                is PartiqlAst.DmlOp.Insert -> transformDmlOpInsert(node)
                is PartiqlAst.DmlOp.InsertValue -> transformDmlOpInsertValue(node)
                is PartiqlAst.DmlOp.Set -> transformDmlOpSet(node)
                is PartiqlAst.DmlOp.Remove -> transformDmlOpRemove(node)
                is PartiqlAst.DmlOp.Delete -> transformDmlOpDelete(node)
            }
        // Variant DmlOpInsert
        open fun transformDmlOpInsert(node: PartiqlAst.DmlOp.Insert): PartiqlAst.DmlOp  {
            val new_target = transformDmlOpInsert_target(node)
            val new_values = transformDmlOpInsert_values(node)
            val new_metas = transformDmlOpInsert_metas(node)
            return if (
                node.target !== new_target ||
                node.values !== new_values ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOp.Insert(
                    target = new_target,
                    values = new_values,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpInsert_target(node: PartiqlAst.DmlOp.Insert) =
            transformExpr(node.target)
        open fun transformDmlOpInsert_values(node: PartiqlAst.DmlOp.Insert) =
            transformExpr(node.values)
        open fun transformDmlOpInsert_metas(node: PartiqlAst.DmlOp.Insert) =
            transformMetas(node.metas)
    
        // Variant DmlOpInsertValue
        open fun transformDmlOpInsertValue(node: PartiqlAst.DmlOp.InsertValue): PartiqlAst.DmlOp  {
            val new_target = transformDmlOpInsertValue_target(node)
            val new_value = transformDmlOpInsertValue_value(node)
            val new_index = transformDmlOpInsertValue_index(node)
            val new_onConflict = transformDmlOpInsertValue_onConflict(node)
            val new_metas = transformDmlOpInsertValue_metas(node)
            return if (
                node.target !== new_target ||
                node.value !== new_value ||
                node.index !== new_index ||
                node.onConflict !== new_onConflict ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOp.InsertValue(
                    target = new_target,
                    value = new_value,
                    index = new_index,
                    onConflict = new_onConflict,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpInsertValue_target(node: PartiqlAst.DmlOp.InsertValue) =
            transformExpr(node.target)
        open fun transformDmlOpInsertValue_value(node: PartiqlAst.DmlOp.InsertValue) =
            transformExpr(node.value)
        open fun transformDmlOpInsertValue_index(node: PartiqlAst.DmlOp.InsertValue) =
            node.index?.let { transformExpr(it) }
        open fun transformDmlOpInsertValue_onConflict(node: PartiqlAst.DmlOp.InsertValue) =
            node.onConflict?.let { transformOnConflict(it) }
        open fun transformDmlOpInsertValue_metas(node: PartiqlAst.DmlOp.InsertValue) =
            transformMetas(node.metas)
    
        // Variant DmlOpSet
        open fun transformDmlOpSet(node: PartiqlAst.DmlOp.Set): PartiqlAst.DmlOp  {
            val new_assignment = transformDmlOpSet_assignment(node)
            val new_metas = transformDmlOpSet_metas(node)
            return if (
                node.assignment !== new_assignment ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOp.Set(
                    assignment = new_assignment,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpSet_assignment(node: PartiqlAst.DmlOp.Set) =
            transformAssignment(node.assignment)
        open fun transformDmlOpSet_metas(node: PartiqlAst.DmlOp.Set) =
            transformMetas(node.metas)
    
        // Variant DmlOpRemove
        open fun transformDmlOpRemove(node: PartiqlAst.DmlOp.Remove): PartiqlAst.DmlOp  {
            val new_target = transformDmlOpRemove_target(node)
            val new_metas = transformDmlOpRemove_metas(node)
            return if (
                node.target !== new_target ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOp.Remove(
                    target = new_target,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpRemove_target(node: PartiqlAst.DmlOp.Remove) =
            transformExpr(node.target)
        open fun transformDmlOpRemove_metas(node: PartiqlAst.DmlOp.Remove) =
            transformMetas(node.metas)
    
        // Variant DmlOpDelete
        open fun transformDmlOpDelete(node: PartiqlAst.DmlOp.Delete): PartiqlAst.DmlOp  {
            val new_metas = transformDmlOpDelete_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.DmlOp.Delete(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDmlOpDelete_metas(node: PartiqlAst.DmlOp.Delete) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ConflictAction
        //////////////////////////////////////
        open fun transformConflictAction(node: PartiqlAst.ConflictAction): PartiqlAst.ConflictAction =
            when(node) {
                is PartiqlAst.ConflictAction.DoNothing -> transformConflictActionDoNothing(node)
            }
        // Variant ConflictActionDoNothing
        open fun transformConflictActionDoNothing(node: PartiqlAst.ConflictAction.DoNothing): PartiqlAst.ConflictAction  {
            val new_metas = transformConflictActionDoNothing_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ConflictAction.DoNothing(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformConflictActionDoNothing_metas(node: PartiqlAst.ConflictAction.DoNothing) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: DdlOp
        //////////////////////////////////////
        open fun transformDdlOp(node: PartiqlAst.DdlOp): PartiqlAst.DdlOp =
            when(node) {
                is PartiqlAst.DdlOp.CreateTable -> transformDdlOpCreateTable(node)
                is PartiqlAst.DdlOp.DropTable -> transformDdlOpDropTable(node)
                is PartiqlAst.DdlOp.UndropTable -> transformDdlOpUndropTable(node)
                is PartiqlAst.DdlOp.CreateIndex -> transformDdlOpCreateIndex(node)
                is PartiqlAst.DdlOp.DropIndex -> transformDdlOpDropIndex(node)
            }
        // Variant DdlOpCreateTable
        open fun transformDdlOpCreateTable(node: PartiqlAst.DdlOp.CreateTable): PartiqlAst.DdlOp  {
            val new_tableName = transformDdlOpCreateTable_tableName(node)
            val new_metas = transformDdlOpCreateTable_metas(node)
            return if (
                node.tableName !== new_tableName ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DdlOp.CreateTable(
                    tableName = new_tableName,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDdlOpCreateTable_tableName(node: PartiqlAst.DdlOp.CreateTable) =
            transformSymbolPrimitive(node.tableName)
        open fun transformDdlOpCreateTable_metas(node: PartiqlAst.DdlOp.CreateTable) =
            transformMetas(node.metas)
    
        // Variant DdlOpDropTable
        open fun transformDdlOpDropTable(node: PartiqlAst.DdlOp.DropTable): PartiqlAst.DdlOp  {
            val new_tableName = transformDdlOpDropTable_tableName(node)
            val new_metas = transformDdlOpDropTable_metas(node)
            return if (
                node.tableName !== new_tableName ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DdlOp.DropTable(
                    tableName = new_tableName,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDdlOpDropTable_tableName(node: PartiqlAst.DdlOp.DropTable) =
            transformIdentifier(node.tableName)
        open fun transformDdlOpDropTable_metas(node: PartiqlAst.DdlOp.DropTable) =
            transformMetas(node.metas)
    
        // Variant DdlOpUndropTable
        open fun transformDdlOpUndropTable(node: PartiqlAst.DdlOp.UndropTable): PartiqlAst.DdlOp  {
            val new_tableName = transformDdlOpUndropTable_tableName(node)
            val new_metas = transformDdlOpUndropTable_metas(node)
            return if (
                node.tableName !== new_tableName ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DdlOp.UndropTable(
                    tableName = new_tableName,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDdlOpUndropTable_tableName(node: PartiqlAst.DdlOp.UndropTable) =
            transformSymbolPrimitive(node.tableName)
        open fun transformDdlOpUndropTable_metas(node: PartiqlAst.DdlOp.UndropTable) =
            transformMetas(node.metas)
    
        // Variant DdlOpCreateIndex
        open fun transformDdlOpCreateIndex(node: PartiqlAst.DdlOp.CreateIndex): PartiqlAst.DdlOp  {
            val new_indexName = transformDdlOpCreateIndex_indexName(node)
            val new_fields = transformDdlOpCreateIndex_fields(node)
            val new_metas = transformDdlOpCreateIndex_metas(node)
            return if (
                node.indexName !== new_indexName ||
                node.fields !== new_fields ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DdlOp.CreateIndex(
                    indexName = new_indexName,
                    fields = new_fields,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDdlOpCreateIndex_indexName(node: PartiqlAst.DdlOp.CreateIndex) =
            transformIdentifier(node.indexName)
        open fun transformDdlOpCreateIndex_fields(node: PartiqlAst.DdlOp.CreateIndex) =
            node.fields.map { transformExpr(it) }
        open fun transformDdlOpCreateIndex_metas(node: PartiqlAst.DdlOp.CreateIndex) =
            transformMetas(node.metas)
    
        // Variant DdlOpDropIndex
        open fun transformDdlOpDropIndex(node: PartiqlAst.DdlOp.DropIndex): PartiqlAst.DdlOp  {
            val new_table = transformDdlOpDropIndex_table(node)
            val new_keys = transformDdlOpDropIndex_keys(node)
            val new_metas = transformDdlOpDropIndex_metas(node)
            return if (
                node.table !== new_table ||
                node.keys !== new_keys ||
                node.metas !== new_metas
            ) {
                PartiqlAst.DdlOp.DropIndex(
                    table = new_table,
                    keys = new_keys,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformDdlOpDropIndex_table(node: PartiqlAst.DdlOp.DropIndex) =
            transformIdentifier(node.table)
        open fun transformDdlOpDropIndex_keys(node: PartiqlAst.DdlOp.DropIndex) =
            transformIdentifier(node.keys)
        open fun transformDdlOpDropIndex_metas(node: PartiqlAst.DdlOp.DropIndex) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ColumnComponent
        //////////////////////////////////////
        open fun transformColumnComponent(node: PartiqlAst.ColumnComponent): PartiqlAst.ColumnComponent =
            when(node) {
                is PartiqlAst.ColumnComponent.ReturningWildcard -> transformColumnComponentReturningWildcard(node)
                is PartiqlAst.ColumnComponent.ReturningColumn -> transformColumnComponentReturningColumn(node)
            }
        // Variant ColumnComponentReturningWildcard
        open fun transformColumnComponentReturningWildcard(node: PartiqlAst.ColumnComponent.ReturningWildcard): PartiqlAst.ColumnComponent  {
            val new_metas = transformColumnComponentReturningWildcard_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ColumnComponent.ReturningWildcard(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformColumnComponentReturningWildcard_metas(node: PartiqlAst.ColumnComponent.ReturningWildcard) =
            transformMetas(node.metas)
    
        // Variant ColumnComponentReturningColumn
        open fun transformColumnComponentReturningColumn(node: PartiqlAst.ColumnComponent.ReturningColumn): PartiqlAst.ColumnComponent  {
            val new_expr = transformColumnComponentReturningColumn_expr(node)
            val new_metas = transformColumnComponentReturningColumn_metas(node)
            return if (
                node.expr !== new_expr ||
                node.metas !== new_metas
            ) {
                PartiqlAst.ColumnComponent.ReturningColumn(
                    expr = new_expr,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformColumnComponentReturningColumn_expr(node: PartiqlAst.ColumnComponent.ReturningColumn) =
            transformExpr(node.expr)
        open fun transformColumnComponentReturningColumn_metas(node: PartiqlAst.ColumnComponent.ReturningColumn) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: ReturningMapping
        //////////////////////////////////////
        open fun transformReturningMapping(node: PartiqlAst.ReturningMapping): PartiqlAst.ReturningMapping =
            when(node) {
                is PartiqlAst.ReturningMapping.ModifiedNew -> transformReturningMappingModifiedNew(node)
                is PartiqlAst.ReturningMapping.ModifiedOld -> transformReturningMappingModifiedOld(node)
                is PartiqlAst.ReturningMapping.AllNew -> transformReturningMappingAllNew(node)
                is PartiqlAst.ReturningMapping.AllOld -> transformReturningMappingAllOld(node)
            }
        // Variant ReturningMappingModifiedNew
        open fun transformReturningMappingModifiedNew(node: PartiqlAst.ReturningMapping.ModifiedNew): PartiqlAst.ReturningMapping  {
            val new_metas = transformReturningMappingModifiedNew_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningMapping.ModifiedNew(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningMappingModifiedNew_metas(node: PartiqlAst.ReturningMapping.ModifiedNew) =
            transformMetas(node.metas)
    
        // Variant ReturningMappingModifiedOld
        open fun transformReturningMappingModifiedOld(node: PartiqlAst.ReturningMapping.ModifiedOld): PartiqlAst.ReturningMapping  {
            val new_metas = transformReturningMappingModifiedOld_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningMapping.ModifiedOld(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningMappingModifiedOld_metas(node: PartiqlAst.ReturningMapping.ModifiedOld) =
            transformMetas(node.metas)
    
        // Variant ReturningMappingAllNew
        open fun transformReturningMappingAllNew(node: PartiqlAst.ReturningMapping.AllNew): PartiqlAst.ReturningMapping  {
            val new_metas = transformReturningMappingAllNew_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningMapping.AllNew(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningMappingAllNew_metas(node: PartiqlAst.ReturningMapping.AllNew) =
            transformMetas(node.metas)
    
        // Variant ReturningMappingAllOld
        open fun transformReturningMappingAllOld(node: PartiqlAst.ReturningMapping.AllOld): PartiqlAst.ReturningMapping  {
            val new_metas = transformReturningMappingAllOld_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.ReturningMapping.AllOld(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformReturningMappingAllOld_metas(node: PartiqlAst.ReturningMapping.AllOld) =
            transformMetas(node.metas)
    
        //////////////////////////////////////
        // Sum Type: Type
        //////////////////////////////////////
        open fun transformType(node: PartiqlAst.Type): PartiqlAst.Type =
            when(node) {
                is PartiqlAst.Type.NullType -> transformTypeNullType(node)
                is PartiqlAst.Type.BooleanType -> transformTypeBooleanType(node)
                is PartiqlAst.Type.SmallintType -> transformTypeSmallintType(node)
                is PartiqlAst.Type.Integer4Type -> transformTypeInteger4Type(node)
                is PartiqlAst.Type.Integer8Type -> transformTypeInteger8Type(node)
                is PartiqlAst.Type.IntegerType -> transformTypeIntegerType(node)
                is PartiqlAst.Type.FloatType -> transformTypeFloatType(node)
                is PartiqlAst.Type.RealType -> transformTypeRealType(node)
                is PartiqlAst.Type.DoublePrecisionType -> transformTypeDoublePrecisionType(node)
                is PartiqlAst.Type.DecimalType -> transformTypeDecimalType(node)
                is PartiqlAst.Type.NumericType -> transformTypeNumericType(node)
                is PartiqlAst.Type.TimestampType -> transformTypeTimestampType(node)
                is PartiqlAst.Type.CharacterType -> transformTypeCharacterType(node)
                is PartiqlAst.Type.CharacterVaryingType -> transformTypeCharacterVaryingType(node)
                is PartiqlAst.Type.MissingType -> transformTypeMissingType(node)
                is PartiqlAst.Type.StringType -> transformTypeStringType(node)
                is PartiqlAst.Type.SymbolType -> transformTypeSymbolType(node)
                is PartiqlAst.Type.BlobType -> transformTypeBlobType(node)
                is PartiqlAst.Type.ClobType -> transformTypeClobType(node)
                is PartiqlAst.Type.DateType -> transformTypeDateType(node)
                is PartiqlAst.Type.TimeType -> transformTypeTimeType(node)
                is PartiqlAst.Type.TimeWithTimeZoneType -> transformTypeTimeWithTimeZoneType(node)
                is PartiqlAst.Type.StructType -> transformTypeStructType(node)
                is PartiqlAst.Type.TupleType -> transformTypeTupleType(node)
                is PartiqlAst.Type.ListType -> transformTypeListType(node)
                is PartiqlAst.Type.SexpType -> transformTypeSexpType(node)
                is PartiqlAst.Type.BagType -> transformTypeBagType(node)
                is PartiqlAst.Type.AnyType -> transformTypeAnyType(node)
                is PartiqlAst.Type.EsBoolean -> transformTypeEsBoolean(node)
                is PartiqlAst.Type.EsInteger -> transformTypeEsInteger(node)
                is PartiqlAst.Type.EsFloat -> transformTypeEsFloat(node)
                is PartiqlAst.Type.EsText -> transformTypeEsText(node)
                is PartiqlAst.Type.EsAny -> transformTypeEsAny(node)
                is PartiqlAst.Type.SparkShort -> transformTypeSparkShort(node)
                is PartiqlAst.Type.SparkInteger -> transformTypeSparkInteger(node)
                is PartiqlAst.Type.SparkLong -> transformTypeSparkLong(node)
                is PartiqlAst.Type.SparkDouble -> transformTypeSparkDouble(node)
                is PartiqlAst.Type.SparkBoolean -> transformTypeSparkBoolean(node)
                is PartiqlAst.Type.SparkFloat -> transformTypeSparkFloat(node)
                is PartiqlAst.Type.RsVarcharMax -> transformTypeRsVarcharMax(node)
                is PartiqlAst.Type.RsInteger -> transformTypeRsInteger(node)
                is PartiqlAst.Type.RsBigint -> transformTypeRsBigint(node)
                is PartiqlAst.Type.RsBoolean -> transformTypeRsBoolean(node)
                is PartiqlAst.Type.RsReal -> transformTypeRsReal(node)
                is PartiqlAst.Type.RsDoublePrecision -> transformTypeRsDoublePrecision(node)
                is PartiqlAst.Type.CustomType -> transformTypeCustomType(node)
            }
        // Variant TypeNullType
        open fun transformTypeNullType(node: PartiqlAst.Type.NullType): PartiqlAst.Type  {
            val new_metas = transformTypeNullType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.NullType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeNullType_metas(node: PartiqlAst.Type.NullType) =
            transformMetas(node.metas)
    
        // Variant TypeBooleanType
        open fun transformTypeBooleanType(node: PartiqlAst.Type.BooleanType): PartiqlAst.Type  {
            val new_metas = transformTypeBooleanType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.BooleanType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeBooleanType_metas(node: PartiqlAst.Type.BooleanType) =
            transformMetas(node.metas)
    
        // Variant TypeSmallintType
        open fun transformTypeSmallintType(node: PartiqlAst.Type.SmallintType): PartiqlAst.Type  {
            val new_metas = transformTypeSmallintType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SmallintType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSmallintType_metas(node: PartiqlAst.Type.SmallintType) =
            transformMetas(node.metas)
    
        // Variant TypeInteger4Type
        open fun transformTypeInteger4Type(node: PartiqlAst.Type.Integer4Type): PartiqlAst.Type  {
            val new_metas = transformTypeInteger4Type_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.Integer4Type(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeInteger4Type_metas(node: PartiqlAst.Type.Integer4Type) =
            transformMetas(node.metas)
    
        // Variant TypeInteger8Type
        open fun transformTypeInteger8Type(node: PartiqlAst.Type.Integer8Type): PartiqlAst.Type  {
            val new_metas = transformTypeInteger8Type_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.Integer8Type(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeInteger8Type_metas(node: PartiqlAst.Type.Integer8Type) =
            transformMetas(node.metas)
    
        // Variant TypeIntegerType
        open fun transformTypeIntegerType(node: PartiqlAst.Type.IntegerType): PartiqlAst.Type  {
            val new_metas = transformTypeIntegerType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.IntegerType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeIntegerType_metas(node: PartiqlAst.Type.IntegerType) =
            transformMetas(node.metas)
    
        // Variant TypeFloatType
        open fun transformTypeFloatType(node: PartiqlAst.Type.FloatType): PartiqlAst.Type  {
            val new_precision = transformTypeFloatType_precision(node)
            val new_metas = transformTypeFloatType_metas(node)
            return if (
                node.precision !== new_precision ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.FloatType(
                    precision = new_precision,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeFloatType_precision(node: PartiqlAst.Type.FloatType) =
            node.precision?.let { transformLongPrimitive(it) }
        open fun transformTypeFloatType_metas(node: PartiqlAst.Type.FloatType) =
            transformMetas(node.metas)
    
        // Variant TypeRealType
        open fun transformTypeRealType(node: PartiqlAst.Type.RealType): PartiqlAst.Type  {
            val new_metas = transformTypeRealType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RealType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRealType_metas(node: PartiqlAst.Type.RealType) =
            transformMetas(node.metas)
    
        // Variant TypeDoublePrecisionType
        open fun transformTypeDoublePrecisionType(node: PartiqlAst.Type.DoublePrecisionType): PartiqlAst.Type  {
            val new_metas = transformTypeDoublePrecisionType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.DoublePrecisionType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeDoublePrecisionType_metas(node: PartiqlAst.Type.DoublePrecisionType) =
            transformMetas(node.metas)
    
        // Variant TypeDecimalType
        open fun transformTypeDecimalType(node: PartiqlAst.Type.DecimalType): PartiqlAst.Type  {
            val new_precision = transformTypeDecimalType_precision(node)
            val new_scale = transformTypeDecimalType_scale(node)
            val new_metas = transformTypeDecimalType_metas(node)
            return if (
                node.precision !== new_precision ||
                node.scale !== new_scale ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.DecimalType(
                    precision = new_precision,
                    scale = new_scale,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeDecimalType_precision(node: PartiqlAst.Type.DecimalType) =
            node.precision?.let { transformLongPrimitive(it) }
        open fun transformTypeDecimalType_scale(node: PartiqlAst.Type.DecimalType) =
            node.scale?.let { transformLongPrimitive(it) }
        open fun transformTypeDecimalType_metas(node: PartiqlAst.Type.DecimalType) =
            transformMetas(node.metas)
    
        // Variant TypeNumericType
        open fun transformTypeNumericType(node: PartiqlAst.Type.NumericType): PartiqlAst.Type  {
            val new_precision = transformTypeNumericType_precision(node)
            val new_scale = transformTypeNumericType_scale(node)
            val new_metas = transformTypeNumericType_metas(node)
            return if (
                node.precision !== new_precision ||
                node.scale !== new_scale ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.NumericType(
                    precision = new_precision,
                    scale = new_scale,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeNumericType_precision(node: PartiqlAst.Type.NumericType) =
            node.precision?.let { transformLongPrimitive(it) }
        open fun transformTypeNumericType_scale(node: PartiqlAst.Type.NumericType) =
            node.scale?.let { transformLongPrimitive(it) }
        open fun transformTypeNumericType_metas(node: PartiqlAst.Type.NumericType) =
            transformMetas(node.metas)
    
        // Variant TypeTimestampType
        open fun transformTypeTimestampType(node: PartiqlAst.Type.TimestampType): PartiqlAst.Type  {
            val new_metas = transformTypeTimestampType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.TimestampType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeTimestampType_metas(node: PartiqlAst.Type.TimestampType) =
            transformMetas(node.metas)
    
        // Variant TypeCharacterType
        open fun transformTypeCharacterType(node: PartiqlAst.Type.CharacterType): PartiqlAst.Type  {
            val new_length = transformTypeCharacterType_length(node)
            val new_metas = transformTypeCharacterType_metas(node)
            return if (
                node.length !== new_length ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.CharacterType(
                    length = new_length,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeCharacterType_length(node: PartiqlAst.Type.CharacterType) =
            node.length?.let { transformLongPrimitive(it) }
        open fun transformTypeCharacterType_metas(node: PartiqlAst.Type.CharacterType) =
            transformMetas(node.metas)
    
        // Variant TypeCharacterVaryingType
        open fun transformTypeCharacterVaryingType(node: PartiqlAst.Type.CharacterVaryingType): PartiqlAst.Type  {
            val new_length = transformTypeCharacterVaryingType_length(node)
            val new_metas = transformTypeCharacterVaryingType_metas(node)
            return if (
                node.length !== new_length ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.CharacterVaryingType(
                    length = new_length,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeCharacterVaryingType_length(node: PartiqlAst.Type.CharacterVaryingType) =
            node.length?.let { transformLongPrimitive(it) }
        open fun transformTypeCharacterVaryingType_metas(node: PartiqlAst.Type.CharacterVaryingType) =
            transformMetas(node.metas)
    
        // Variant TypeMissingType
        open fun transformTypeMissingType(node: PartiqlAst.Type.MissingType): PartiqlAst.Type  {
            val new_metas = transformTypeMissingType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.MissingType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeMissingType_metas(node: PartiqlAst.Type.MissingType) =
            transformMetas(node.metas)
    
        // Variant TypeStringType
        open fun transformTypeStringType(node: PartiqlAst.Type.StringType): PartiqlAst.Type  {
            val new_metas = transformTypeStringType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.StringType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeStringType_metas(node: PartiqlAst.Type.StringType) =
            transformMetas(node.metas)
    
        // Variant TypeSymbolType
        open fun transformTypeSymbolType(node: PartiqlAst.Type.SymbolType): PartiqlAst.Type  {
            val new_metas = transformTypeSymbolType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SymbolType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSymbolType_metas(node: PartiqlAst.Type.SymbolType) =
            transformMetas(node.metas)
    
        // Variant TypeBlobType
        open fun transformTypeBlobType(node: PartiqlAst.Type.BlobType): PartiqlAst.Type  {
            val new_metas = transformTypeBlobType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.BlobType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeBlobType_metas(node: PartiqlAst.Type.BlobType) =
            transformMetas(node.metas)
    
        // Variant TypeClobType
        open fun transformTypeClobType(node: PartiqlAst.Type.ClobType): PartiqlAst.Type  {
            val new_metas = transformTypeClobType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.ClobType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeClobType_metas(node: PartiqlAst.Type.ClobType) =
            transformMetas(node.metas)
    
        // Variant TypeDateType
        open fun transformTypeDateType(node: PartiqlAst.Type.DateType): PartiqlAst.Type  {
            val new_metas = transformTypeDateType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.DateType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeDateType_metas(node: PartiqlAst.Type.DateType) =
            transformMetas(node.metas)
    
        // Variant TypeTimeType
        open fun transformTypeTimeType(node: PartiqlAst.Type.TimeType): PartiqlAst.Type  {
            val new_precision = transformTypeTimeType_precision(node)
            val new_metas = transformTypeTimeType_metas(node)
            return if (
                node.precision !== new_precision ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.TimeType(
                    precision = new_precision,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeTimeType_precision(node: PartiqlAst.Type.TimeType) =
            node.precision?.let { transformLongPrimitive(it) }
        open fun transformTypeTimeType_metas(node: PartiqlAst.Type.TimeType) =
            transformMetas(node.metas)
    
        // Variant TypeTimeWithTimeZoneType
        open fun transformTypeTimeWithTimeZoneType(node: PartiqlAst.Type.TimeWithTimeZoneType): PartiqlAst.Type  {
            val new_precision = transformTypeTimeWithTimeZoneType_precision(node)
            val new_metas = transformTypeTimeWithTimeZoneType_metas(node)
            return if (
                node.precision !== new_precision ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.TimeWithTimeZoneType(
                    precision = new_precision,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeTimeWithTimeZoneType_precision(node: PartiqlAst.Type.TimeWithTimeZoneType) =
            node.precision?.let { transformLongPrimitive(it) }
        open fun transformTypeTimeWithTimeZoneType_metas(node: PartiqlAst.Type.TimeWithTimeZoneType) =
            transformMetas(node.metas)
    
        // Variant TypeStructType
        open fun transformTypeStructType(node: PartiqlAst.Type.StructType): PartiqlAst.Type  {
            val new_metas = transformTypeStructType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.StructType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeStructType_metas(node: PartiqlAst.Type.StructType) =
            transformMetas(node.metas)
    
        // Variant TypeTupleType
        open fun transformTypeTupleType(node: PartiqlAst.Type.TupleType): PartiqlAst.Type  {
            val new_metas = transformTypeTupleType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.TupleType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeTupleType_metas(node: PartiqlAst.Type.TupleType) =
            transformMetas(node.metas)
    
        // Variant TypeListType
        open fun transformTypeListType(node: PartiqlAst.Type.ListType): PartiqlAst.Type  {
            val new_metas = transformTypeListType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.ListType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeListType_metas(node: PartiqlAst.Type.ListType) =
            transformMetas(node.metas)
    
        // Variant TypeSexpType
        open fun transformTypeSexpType(node: PartiqlAst.Type.SexpType): PartiqlAst.Type  {
            val new_metas = transformTypeSexpType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SexpType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSexpType_metas(node: PartiqlAst.Type.SexpType) =
            transformMetas(node.metas)
    
        // Variant TypeBagType
        open fun transformTypeBagType(node: PartiqlAst.Type.BagType): PartiqlAst.Type  {
            val new_metas = transformTypeBagType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.BagType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeBagType_metas(node: PartiqlAst.Type.BagType) =
            transformMetas(node.metas)
    
        // Variant TypeAnyType
        open fun transformTypeAnyType(node: PartiqlAst.Type.AnyType): PartiqlAst.Type  {
            val new_metas = transformTypeAnyType_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.AnyType(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeAnyType_metas(node: PartiqlAst.Type.AnyType) =
            transformMetas(node.metas)
    
        // Variant TypeEsBoolean
        open fun transformTypeEsBoolean(node: PartiqlAst.Type.EsBoolean): PartiqlAst.Type  {
            val new_metas = transformTypeEsBoolean_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.EsBoolean(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeEsBoolean_metas(node: PartiqlAst.Type.EsBoolean) =
            transformMetas(node.metas)
    
        // Variant TypeEsInteger
        open fun transformTypeEsInteger(node: PartiqlAst.Type.EsInteger): PartiqlAst.Type  {
            val new_metas = transformTypeEsInteger_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.EsInteger(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeEsInteger_metas(node: PartiqlAst.Type.EsInteger) =
            transformMetas(node.metas)
    
        // Variant TypeEsFloat
        open fun transformTypeEsFloat(node: PartiqlAst.Type.EsFloat): PartiqlAst.Type  {
            val new_metas = transformTypeEsFloat_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.EsFloat(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeEsFloat_metas(node: PartiqlAst.Type.EsFloat) =
            transformMetas(node.metas)
    
        // Variant TypeEsText
        open fun transformTypeEsText(node: PartiqlAst.Type.EsText): PartiqlAst.Type  {
            val new_metas = transformTypeEsText_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.EsText(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeEsText_metas(node: PartiqlAst.Type.EsText) =
            transformMetas(node.metas)
    
        // Variant TypeEsAny
        open fun transformTypeEsAny(node: PartiqlAst.Type.EsAny): PartiqlAst.Type  {
            val new_metas = transformTypeEsAny_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.EsAny(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeEsAny_metas(node: PartiqlAst.Type.EsAny) =
            transformMetas(node.metas)
    
        // Variant TypeSparkShort
        open fun transformTypeSparkShort(node: PartiqlAst.Type.SparkShort): PartiqlAst.Type  {
            val new_metas = transformTypeSparkShort_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkShort(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkShort_metas(node: PartiqlAst.Type.SparkShort) =
            transformMetas(node.metas)
    
        // Variant TypeSparkInteger
        open fun transformTypeSparkInteger(node: PartiqlAst.Type.SparkInteger): PartiqlAst.Type  {
            val new_metas = transformTypeSparkInteger_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkInteger(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkInteger_metas(node: PartiqlAst.Type.SparkInteger) =
            transformMetas(node.metas)
    
        // Variant TypeSparkLong
        open fun transformTypeSparkLong(node: PartiqlAst.Type.SparkLong): PartiqlAst.Type  {
            val new_metas = transformTypeSparkLong_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkLong(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkLong_metas(node: PartiqlAst.Type.SparkLong) =
            transformMetas(node.metas)
    
        // Variant TypeSparkDouble
        open fun transformTypeSparkDouble(node: PartiqlAst.Type.SparkDouble): PartiqlAst.Type  {
            val new_metas = transformTypeSparkDouble_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkDouble(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkDouble_metas(node: PartiqlAst.Type.SparkDouble) =
            transformMetas(node.metas)
    
        // Variant TypeSparkBoolean
        open fun transformTypeSparkBoolean(node: PartiqlAst.Type.SparkBoolean): PartiqlAst.Type  {
            val new_metas = transformTypeSparkBoolean_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkBoolean(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkBoolean_metas(node: PartiqlAst.Type.SparkBoolean) =
            transformMetas(node.metas)
    
        // Variant TypeSparkFloat
        open fun transformTypeSparkFloat(node: PartiqlAst.Type.SparkFloat): PartiqlAst.Type  {
            val new_metas = transformTypeSparkFloat_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.SparkFloat(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeSparkFloat_metas(node: PartiqlAst.Type.SparkFloat) =
            transformMetas(node.metas)
    
        // Variant TypeRsVarcharMax
        open fun transformTypeRsVarcharMax(node: PartiqlAst.Type.RsVarcharMax): PartiqlAst.Type  {
            val new_metas = transformTypeRsVarcharMax_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsVarcharMax(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsVarcharMax_metas(node: PartiqlAst.Type.RsVarcharMax) =
            transformMetas(node.metas)
    
        // Variant TypeRsInteger
        open fun transformTypeRsInteger(node: PartiqlAst.Type.RsInteger): PartiqlAst.Type  {
            val new_metas = transformTypeRsInteger_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsInteger(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsInteger_metas(node: PartiqlAst.Type.RsInteger) =
            transformMetas(node.metas)
    
        // Variant TypeRsBigint
        open fun transformTypeRsBigint(node: PartiqlAst.Type.RsBigint): PartiqlAst.Type  {
            val new_metas = transformTypeRsBigint_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsBigint(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsBigint_metas(node: PartiqlAst.Type.RsBigint) =
            transformMetas(node.metas)
    
        // Variant TypeRsBoolean
        open fun transformTypeRsBoolean(node: PartiqlAst.Type.RsBoolean): PartiqlAst.Type  {
            val new_metas = transformTypeRsBoolean_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsBoolean(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsBoolean_metas(node: PartiqlAst.Type.RsBoolean) =
            transformMetas(node.metas)
    
        // Variant TypeRsReal
        open fun transformTypeRsReal(node: PartiqlAst.Type.RsReal): PartiqlAst.Type  {
            val new_metas = transformTypeRsReal_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsReal(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsReal_metas(node: PartiqlAst.Type.RsReal) =
            transformMetas(node.metas)
    
        // Variant TypeRsDoublePrecision
        open fun transformTypeRsDoublePrecision(node: PartiqlAst.Type.RsDoublePrecision): PartiqlAst.Type  {
            val new_metas = transformTypeRsDoublePrecision_metas(node)
            return if (
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.RsDoublePrecision(
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeRsDoublePrecision_metas(node: PartiqlAst.Type.RsDoublePrecision) =
            transformMetas(node.metas)
    
        // Variant TypeCustomType
        open fun transformTypeCustomType(node: PartiqlAst.Type.CustomType): PartiqlAst.Type  {
            val new_name = transformTypeCustomType_name(node)
            val new_metas = transformTypeCustomType_metas(node)
            return if (
                node.name !== new_name ||
                node.metas !== new_metas
            ) {
                PartiqlAst.Type.CustomType(
                    name = new_name,
                    metas = new_metas
                )
            } else {
                node
            }
        }
        open fun transformTypeCustomType_name(node: PartiqlAst.Type.CustomType) =
            transformSymbolPrimitive(node.name)
        open fun transformTypeCustomType_metas(node: PartiqlAst.Type.CustomType) =
            transformMetas(node.metas)
    
    }
}



//////////////////////////////////////
// Cross domain transforms
//////////////////////////////////////

