package org.partiql.lang.eval

import junitparams.JUnitParamsRunner
import junitparams.Parameters
import org.junit.Test
import org.junit.runner.RunWith
import org.partiql.lang.SqlException
import org.partiql.lang.errors.ErrorCode
import org.partiql.lang.errors.Property

/** Integration tests showing the how [TypingMode.LEGACY] differs from [TypingMode.PERMISSIVE]. */
@RunWith(JUnitParamsRunner::class)
class TypingModeTests : EvaluatorTestBase() {

    data class ExpectedError(
        val errorCode: ErrorCode,
        val lineNum: Int,
        val charOffset: Int
    )

    data class TestCase(
        /**
         * The SQL statment under.
         *
         * This is expected to yield an error in [TypingMode.LEGACY] and some missing value in [TypingMode.PERMISSIVE].
         */
        val sql: String,
        /**
         * Contains details about the expected error generated by [sql] when running under [TypingMode.LEGACY].
         */
        val expectedLegacyError: ExpectedError,

        /**
         * Contains (in PartiQL syntax) the expected result when running under [TypingMode.PERMISSIVE].
         */
        val expectedPermissiveModeResult: String
    )

    fun parametersForTypingModeTests() = listOf(
        TestCase("1 / 0", ExpectedError(ErrorCode.EVALUATOR_DIVIDE_BY_ZERO, 1, 3), "MISSING"),
        TestCase("[1.0 / 2.0, 1.0 / 0.0, 1.0 / 4.0]", ExpectedError(ErrorCode.EVALUATOR_DIVIDE_BY_ZERO, 1, 17), "[0.5, MISSING, 0.25]"),
        TestCase("1 + 'foo'", ExpectedError(ErrorCode.EVALUATOR_UNEXPECTED_VALUE_TYPE, 1, 3), "MISSING"),
        TestCase("[1.0 + 2.0, 1.0 + 2, 1.0 + 'foo', 1 + '4', 1 + 5.5]", ExpectedError(ErrorCode.EVALUATOR_UNEXPECTED_VALUE_TYPE, 1, 26), "[3.0, 3.0, MISSING, MISSING, 6.5]"),
        // Cannot convert index from float to integer. Return MISSING in permissive mode
        TestCase("[1,2,3][1.0]", ExpectedError(ErrorCode.EVALUATOR_INVALID_CONVERSION, 1, 9), "MISSING"),
        TestCase("CAST(3 AS TIMESTAMP)", ExpectedError(ErrorCode.EVALUATOR_INVALID_CAST, 1, 1), "MISSING"),
        TestCase("SELECT VALUE size(a) FROM [{ 'a' : [1,2] }, { 'a' : << 1, 2, 3>> }, { 'a' : 'not_collection' }]", ExpectedError(ErrorCode.EVALUATOR_INCORRECT_TYPE_OF_ARGUMENTS_TO_FUNC_CALL, 1, 14), "<<2,3,MISSING>>"),
        // Incorrect value for list index
        TestCase("[1,2,3][1.0]", ExpectedError(ErrorCode.EVALUATOR_INVALID_CONVERSION, 1, 9), "MISSING"),
        TestCase("[1,2,3][true]", ExpectedError(ErrorCode.EVALUATOR_INVALID_CONVERSION, 1, 9), "MISSING")
    )

    @Test
    @Parameters
    fun typingModeTests(tc: TestCase) {
        runEvaluatorErrorTestCase(
            query = tc.sql,
            expectedErrorCode = tc.expectedLegacyError.errorCode,
            expectedPermissiveModeResult = tc.expectedPermissiveModeResult,
            addtionalExceptionAssertBlock = { ex: SqlException ->
                // Have to use the additionalExceptionAssertBlock instead of error context for this
                // because there are a few cases with error context values other than line & column that we don't
                // account for in [TestCase].
                assertEquals(
                    "line number",
                    tc.expectedLegacyError.lineNum.toLong(),
                    ex.errorContext[Property.LINE_NUMBER]?.longValue()
                )
                assertEquals(
                    "column number",
                    tc.expectedLegacyError.charOffset.toLong(),
                    ex.errorContext[Property.COLUMN_NUMBER]?.longValue()
                )
            }
        )
    }
}
