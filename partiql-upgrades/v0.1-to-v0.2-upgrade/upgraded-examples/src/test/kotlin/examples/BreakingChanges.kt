/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package examples

import com.amazon.ion.system.IonSystemBuilder
import com.amazon.ionelement.api.IntElement
import com.amazon.ionelement.api.ionInt
import org.partiql.lang.CompilerPipeline
import org.partiql.lang.ast.CaseSensitivity
import org.partiql.lang.ast.FromSourceExpr
import org.partiql.lang.ast.FromSourceUnpivot
import org.partiql.lang.ast.LetVariables
import org.partiql.lang.ast.Literal
import org.partiql.lang.ast.Seq
import org.partiql.lang.ast.SeqType
import org.partiql.lang.ast.SymbolicName
import org.partiql.lang.ast.VariableReference
import org.partiql.lang.ast.metaContainerOf
import org.partiql.lang.domains.PartiqlAst
import org.partiql.lang.eval.EvaluationSession
import org.partiql.lang.syntax.ParserException
import org.partiql.lang.syntax.SqlParser
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith

class BreakingChanges {
    @Test
    fun `behavioral change - JOIN requires ON clause`() {
        // Initialization of components related to parsing a query end-to-end
        val ion = IonSystemBuilder.standard().build()
        val parser = SqlParser(ion)
        val pipeline = CompilerPipeline.standard(ion)
        val evaluationSession = EvaluationSession.standard()

        // Query with a JOIN without an ON clause. Starting in v0.2.0, the ON condition is REQUIRED except for cross
        // joins. When not provided, a parser error is thrown.
        val query = "SELECT * FROM <<{'a': 1}>> INNER JOIN <<{'a': 2}>>"
        assertFailsWith<ParserException> {
            parser.parseExprNode(query)
        }

        // Query with an ON clause still successfully parses and can be evaluated in v0.2.* onwards
        val resultWithOn = pipeline.compile("SELECT * FROM <<{'a': 1}>> INNER JOIN <<{'a': 2}>> ON true").eval(evaluationSession)
        assertEquals("<<{'a': 1, 'a': 2}>>", resultWithOn.toString())
    }

    @Test
    fun `api change - different modeling of FROM source in AST`() {
        // FROM source and FROM source UNPIVOT are modeled differently between v0.1.* and v0.2.*
        // The following is an AstNode/ExprNode representation of '... FROM foo AS f AT g'
        val fromExpr = VariableReference(id = "foo", case = CaseSensitivity.INSENSITIVE, metas = metaContainerOf())
        FromSourceExpr(
            expr = fromExpr,
            variables = LetVariables(
                asName = SymbolicName(name = "f", metas = metaContainerOf()),
                atName = SymbolicName(name = "g", metas = metaContainerOf())
                // v0.2.0 onwards also allows specifying a `BY` variable in FROM sources
            )
        )

        // The following models '... FROM UNPIVOT foo AS f AT g'
        FromSourceUnpivot(
            expr = fromExpr,
            variables = LetVariables(
                asName = SymbolicName(name = "f", metas = metaContainerOf()),
                atName = SymbolicName(name = "g", metas = metaContainerOf())
            ),
            metas = metaContainerOf()
        )
    }

    @Test
    fun `api change - different modeling of LIST and BAG nodes in AST`() {
        val ion = IonSystemBuilder.standard().build()
        val elem1 = Literal(ionValue = ion.singleValue("1"), metas = metaContainerOf())
        val elem2 = Literal(ionValue = ion.singleValue("2"), metas = metaContainerOf())
        val elem3 = Literal(ionValue = ion.singleValue("3"), metas = metaContainerOf())

        // LIST and BAG are modeled differently between v0.1.* and v0.2.*
        // The following is an AstNode/ExprNode representation of [1, 2, 3]
        Seq(
            type = SeqType.LIST,
            values = listOf(
                elem1,
                elem2,
                elem3
            ),
            metas = metaContainerOf()
        )

        // The following is an AstNode/ExprNode representation of <<1, 2, 3>>
        Seq(
            type = SeqType.BAG,
            values = listOf(
                elem1,
                elem2,
                elem3
            ),
            metas = metaContainerOf()
        )

        // v0.2.0 onwards also allows for specifying s-expressions. E.g. (1 2 3)
        Seq(
            type = SeqType.SEXP,
            values = listOf(
                elem1,
                elem2,
                elem3
            ),
            metas = metaContainerOf()
        )
    }

    @Test
    fun `deprecated api - rewriting ASTs`() {
        val ion = IonSystemBuilder.standard().build()
        // v0.2.* onwards recommend using the PartiqlAst over any other AST versions
        val partiqlAst = SqlParser(ion).parseAstStatement("SELECT * FROM <<{'a': 1, 'b': {'c': 23}}>>")

        // below shows a way to create the same recursive rewriting function on PartiqlAst statements using the
        // VisitorTransform class
        class RewriteIntsTo42 : PartiqlAst.VisitorTransform() {
            override fun transformExprLit(node: PartiqlAst.Expr.Lit): PartiqlAst.Expr {
                val newValue = when (node.value) {
                    is IntElement -> ionInt(42)
                    else -> node.value
                }
                val newNode = PartiqlAst.build {
                    lit(newValue)
                }
                return super.transformExprLit(newNode)
            }
        }
        val rewrittenStatement = RewriteIntsTo42().transformStatement(partiqlAst)
        val expectedPartiqlAst = SqlParser(ion).parseAstStatement("SELECT * FROM <<{'a': 42, 'b': {'c': 42}}>>")
        assertEquals(expectedPartiqlAst, rewrittenStatement)
    }
}
